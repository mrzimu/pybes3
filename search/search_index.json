{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pybes3","text":"<p><code>pybes3</code> is an unofficial python module that aims to make BES3 user easier to work with Python.</p> <ul> <li> <p> Install <code>pybes3</code> using <code>pip</code> </p> </li> <li> <p> Get started with user manual   </p> </li> </ul> <p>Tip</p> <p>It is highly recommended to take a look at these Python modules before using <code>pybes3</code>:</p> <ul> <li><code>awkward</code>: A Python module that can handle ragged-like array.</li> <li><code>uproot</code>: A ROOT I/O Python module. <code>pybes3</code> uses <code>uproot</code> to read BES3 ROOT files.</li> </ul>"},{"location":"#user-manual","title":"User manual","text":"<ul> <li> <p> BES3 data reading <p>Read <code>rtraw</code>, <code>rec</code>, <code>dst</code>, and even <code>raw</code> files.   </p> <ul> <li> <p> Digi identifier <p>Convert digi identifier id number to a human-readable format.   </p> <ul> <li> <p> Global ID <p>Global ID numbers for each detector element in <code>pybes3</code>.   </p> <ul> <li> <p> Geometry <p>Retrieve and compute geometry information of detectors.   </p> <ul> <li> <p> Tracks <p>Parse and transform track parameters, such as helix, etc.   </p>"},{"location":"installation/","title":"Installation","text":"<p>Info</p> <p><code>pybes3</code> requires Python 3.9 or higher.</p>"},{"location":"installation/#users-on-lxlogin-server","title":"Users on lxlogin Server","text":"<p>\"lxlogin server\" means the login server of computation clusters of IHEP. Since there is a quota limitation on user's home path (<code>~/</code>), you may also need to create symbolinks for <code>~/.local</code> and <code>~/.cache</code>, which contains pip caches and packages that installed in \"user mode\":</p> <pre><code># Check whether a `.local` directory and `.cache` already exists.\n# If so, move it to somewhere else.\nls -a ~\nmv ~/.local /path/to/somewhere/\nmv ~/.cache /path/to/somewhere\n\n# If no `.local` or `.cache` exists, create them\nmkdir /path/to/somewhere/.local\nmkdir /path/to/somewhere/.cache\n\n# After moving or creating them, link them back to `~`\nln -s /path/to/somewhere/.local ~/.local\nln -s /path/to/somewhere/.cache ~/.cache\n</code></pre>"},{"location":"installation/#install-pybes3-using-pip","title":"Install <code>pybes3</code> using pip","text":"<pre><code>pip install pybes3\n</code></pre>"},{"location":"api/pybes3.besio/","title":"pybes3.besio","text":"<p>Rare Help for Users</p> <p>There is rare help for users in this page. It is recommended to see BESIII Data Reading.</p>"},{"location":"api/pybes3.besio/#besio","title":"besio","text":""},{"location":"api/pybes3.besio/#pybes3.besio.open","title":"<code>open(file, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.open</code> that automatically calls <code>wrap_uproot</code> before opening the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | IO | dict[str | Path | IO, str]</code> <p>The file to open.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.open</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The uproot file object.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open(file, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.open` that automatically calls `wrap_uproot` before opening the file.\n\n    Parameters:\n        file (str | Path | IO | dict[str | Path | IO, str]): The file to open.\n        **kwargs (dict): Additional arguments to pass to `uproot.open`.\n\n    Returns:\n        The uproot file object.\n    \"\"\"\n    wrap_uproot()\n    return uproot.open(file, **kwargs)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.concatenate","title":"<code>concatenate(files, branch, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.concatenate</code> that automatically calls <code>wrap_uproot</code> before concatenating the files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str | Path | IO, str]</code> <p>The files to concatenate.</p> required <code>branch</code> <code>str</code> <p>The branch to concatenate.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.concatenate</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The concatenated array.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def concatenate(files, branch: str, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.concatenate` that automatically calls `wrap_uproot` before concatenating the files.\n\n    Parameters:\n        files (list[str | Path | IO, str]): The files to concatenate.\n        branch (str): The branch to concatenate.\n        **kwargs (dict): Additional arguments to pass to `uproot.concatenate`.\n\n    Returns:\n        The concatenated array.\n    \"\"\"\n    wrap_uproot()\n    return uproot.concatenate({str(f): branch for f in files}, **kwargs)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.open_raw","title":"<code>open_raw(file)</code>","text":"<p>Open a raw binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The file to open.</p> required <p>Returns:</p> Type Description <code>RawBinaryReader</code> <p>The raw binary reader.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open_raw(file: str) -&gt; RawBinaryReader:\n    \"\"\"\n    Open a raw binary file.\n\n    Parameters:\n        file (str): The file to open.\n\n    Returns:\n        (RawBinaryReader): The raw binary reader.\n    \"\"\"\n    return RawBinaryReader(file)\n</code></pre>"},{"location":"api/pybes3.besio/#root_io","title":"root_io","text":""},{"location":"api/pybes3.besio/#pybes3.besio.root_io.get_top_type_name","title":"<code>get_top_type_name(type_name)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def get_top_type_name(type_name: str) -&gt; str:\n    if type_name in CTYPE_NAMES:\n        return kCtype\n\n    elif \"&lt;\" in type_name:\n        top_type_name = type_name.split(\"&lt;\")[0]\n        if top_type_name in STL_NAMES:\n            return top_type_name\n        else:\n            raise NotImplementedError(f\"Unsupported type_name: {type_name}\")\n\n    elif type_name == kTString:\n        return kTString\n\n    else:\n        if type_name.endswith(\"*\"):\n            type_name = type_name[:-1]\n        return type_name\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.get_vector_subtype","title":"<code>get_vector_subtype(type_name)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def get_vector_subtype(type_name: str) -&gt; str:\n    assert type_name.startswith(\"vector&lt;\") and type_name.endswith(\n        \"&gt;\"\n    ), f\"Unsupported type_name: {type_name}\"\n    return type_name[7:-1].strip()\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.get_map_subtypes","title":"<code>get_map_subtypes(type_name)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def get_map_subtypes(type_name: str) -&gt; tuple[str, str]:\n    assert type_name.startswith(\"map&lt;\") and type_name.endswith(\n        \"&gt;\"\n    ), f\"Unsupported type_name: {type_name}\"\n\n    pos_split = 0\n    n_level = 0\n    for i, c in enumerate(type_name):\n        if c == \"&lt;\":\n            n_level += 1\n        elif c == \"&gt;\":\n            n_level -= 1\n        if n_level == 1 and c == \",\":\n            pos_split = i\n            break\n\n    assert pos_split != 0, f\"Unsupported type_name: {type_name}\"\n    return type_name[4:pos_split].strip(), type_name[pos_split + 1 : -1].strip()\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.recover_basic_element","title":"<code>recover_basic_element(streamer_info, org_data, all_streamer_info)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def recover_basic_element(\n    streamer_info: dict, org_data: tuple, all_streamer_info: dict\n) -&gt; awkward.contents.Content:\n    fTypeName = streamer_info[\"fTypeName\"]\n    fName = streamer_info[\"fName\"]\n    top_type_name = get_top_type_name(fTypeName)\n\n    if \"fArrayDim\" in streamer_info and streamer_info[\"fArrayDim\"] &gt; 0:\n        fMaxIndex = streamer_info[\"fMaxIndex\"]\n\n        new_info = streamer_info.copy()\n        new_info[\"fArrayDim\"] = 0\n\n        flat_content = recover_basic_element(new_info, org_data, all_streamer_info)\n        shape = deque(fMaxIndex[fMaxIndex &gt; 0].tolist())\n        return recover_array_shape(flat_content, shape)\n\n    if top_type_name == kCtype:\n        return awkward.contents.NumpyArray(org_data[0])\n\n    elif top_type_name == kTString:\n        offset, data = org_data\n        return awkward.contents.ListOffsetArray(\n            awkward.index.Index(offset),\n            awkward.contents.NumpyArray(data.view(np.uint8), parameters={\"__array__\": \"char\"}),\n            parameters={\"__array__\": \"string\"},\n        )\n\n    elif top_type_name in STL_NAMES:\n        if top_type_name == kVector:\n            element_type = get_vector_subtype(fTypeName)\n            element_info = {\n                \"fName\": fName + \"_element\",\n                \"fTypeName\": element_type,\n                \"fType\": -1,\n            }\n\n            offsets, sub_org_data = org_data\n            sub_content = recover_basic_element(element_info, sub_org_data, all_streamer_info)\n\n            return awkward.contents.ListOffsetArray(awkward.index.Index(offsets), sub_content)\n\n        elif top_type_name == kMap or top_type_name == kMultiMap:\n            key_type, val_type = get_map_subtypes(fTypeName)\n\n            key_info = {\"fName\": fName + \"_key\", \"fTypeName\": key_type, \"fType\": -1}\n            val_info = {\"fName\": fName + \"_val\", \"fTypeName\": val_type, \"fType\": -1}\n\n            offset, key_org_data, val_org_data = org_data\n\n            key_content = recover_basic_element(key_info, key_org_data, all_streamer_info)\n            val_content = recover_basic_element(val_info, val_org_data, all_streamer_info)\n\n            return awkward.contents.ListOffsetArray(\n                awkward.index.Index(offset),\n                awkward.contents.RecordArray([key_content, val_content], [\"key\", \"val\"]),\n            )\n        else:\n            raise NotImplementedError(f\"Unsupported STL type: {top_type_name}\")\n\n    elif top_type_name == kBASE:\n        fType = streamer_info[\"fType\"]\n        if fType == 66:\n            return None\n\n        elif fType == 0:\n            sub_streamers = all_streamer_info[fName]\n            sub_field_names = []\n            sub_field_contents = []\n            for s_info, s_data in zip(sub_streamers, org_data):\n                sub_content = recover_basic_element(s_info, s_data, all_streamer_info)\n                sub_name = s_info[\"fName\"]\n\n                # skip TObject result\n                if sub_content is not None:\n                    sub_field_contents.append(sub_content)\n                    sub_field_names.append(sub_name)\n            return awkward.contents.RecordArray(sub_field_contents, sub_field_names)\n\n        else:\n            raise NotImplementedError(f\"Unsupported fType: {fType}\")\n\n    elif top_type_name in TARRAY_NAMES:\n        offsets, sub_org_data = org_data\n        return awkward.contents.ListOffsetArray(\n            awkward.index.Index(offsets), awkward.contents.NumpyArray(sub_org_data)\n        )\n\n    else:\n        sub_streamers = all_streamer_info[top_type_name]\n        sub_field_names = []\n        sub_field_contents = []\n        for s_info, s_data in zip(sub_streamers, org_data):\n            sub_content = recover_basic_element(s_info, s_data, all_streamer_info)\n            sub_name = s_info[\"fName\"]\n\n            # skip TObject result\n            if sub_content is not None:\n                sub_field_contents.append(sub_content)\n                sub_field_names.append(sub_name)\n\n        return awkward.contents.RecordArray(sub_field_contents, sub_field_names)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.recover_array_shape","title":"<code>recover_array_shape(content, shape)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def recover_array_shape(\n    content: awkward.contents.Content, shape: deque[int]\n) -&gt; awkward.contents.Content:\n    cur_shape = shape.popleft()\n    if len(shape) &gt; 0:\n        content = recover_array_shape(content, shape)\n    return awkward.contents.RegularArray(content, cur_shape)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.tobjarray_np2ak","title":"<code>tobjarray_np2ak(element_type_name, org_array_dict, all_streamer_info)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def tobjarray_np2ak(\n    element_type_name: str, org_array_dict: dict, all_streamer_info: dict\n) -&gt; awkward.Array:\n    org_data_tuple: tuple = org_array_dict[\"data\"]\n    obj_offsets: np.ndarray = org_array_dict[\"obj_offsets\"]\n    element_streamer_info = all_streamer_info[element_type_name]\n\n    field_names = []\n    field_contents = []\n    for s, org_data in zip(element_streamer_info, org_data_tuple):\n        element_content = recover_basic_element(s, org_data, all_streamer_info)\n        if element_content is None:\n            continue\n\n        # Make object-offsets, then it's event-by-event array\n        evt_contents = awkward.contents.ListOffsetArray(\n            awkward.index.Index(obj_offsets), element_content\n        )\n\n        field_names.append(s[\"fName\"])\n        field_contents.append(evt_contents)\n\n    return awkward.Array(awkward.contents.RecordArray(field_contents, field_names))\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.tobject_np2ak","title":"<code>tobject_np2ak(element_type_name, org_data_list, all_streamer_info)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def tobject_np2ak(\n    element_type_name: str, org_data_list: tuple, all_streamer_info: dict\n) -&gt; awkward.Array:\n    field_names = []\n    field_contents = []\n    element_streamer_info = all_streamer_info[element_type_name]\n    for s, org_data in zip(element_streamer_info, org_data_list):\n        element_content = recover_basic_element(s, org_data, all_streamer_info)\n        if element_content is None:\n            continue\n\n        field_names.append(s[\"fName\"])\n        field_contents.append(element_content)\n\n    return awkward.Array(awkward.contents.RecordArray(field_contents, field_names))\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.stl_np2ak","title":"<code>stl_np2ak(org_data, type_name, all_streamer_info)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def stl_np2ak(org_data: tuple, type_name: str, all_streamer_info: dict) -&gt; awkward.Array:\n    tmp_info = {\n        \"fName\": \"tmp\",\n        \"fTypeName\": type_name,\n        \"fType\": -1,\n    }\n    element_content = recover_basic_element(tmp_info, org_data, all_streamer_info)\n    return awkward.Array(element_content)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.get_symetric_matrix_idx","title":"<code>get_symetric_matrix_idx(i, j, ndim)</code>","text":"<p>Returns the index of the similarity matrix given the row and column indices.</p> <p>The matrix is assumed to be symmetric-like. (i, j) -&gt; index relationship is:</p> i=0 i=1 i=2 j=0 0 j=1 1 2 j=2 3 4 5 <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[int, Array, ndarray]</code> <p>The row index or array of row indices.</p> required <code>j</code> <code>Union[int, Array, ndarray]</code> <p>The column index or array of column indices.</p> required <code>ndim</code> <code>int</code> <p>The dimension of the similarity matrix.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index or array of indices corresponding to the given row and column indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the row and column indices are not of the same type, or if one of them is not an integer.</p> <code>ValueError</code> <p>If the row or column indices are greater than or equal to the dimension of the similarity matrix.</p> <code>ValueError</code> <p>If the row or column indices are negative.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def get_symetric_matrix_idx(\n    i: Union[int, ak.Array, np.ndarray], j: Union[int, ak.Array, np.ndarray], ndim: int\n) -&gt; int:\n    r\"\"\"\n    Returns the index of the similarity matrix given the row and column indices.\n\n    The matrix is assumed to be symmetric-like. (i, j) -&gt; index relationship is:\n\n    |     | i=0 | i=1 | i=2 |\n    | :-: | :-: | :-: | :-: |\n    | j=0 |  0  |     |     |\n    | j=1 |  1  |  2  |     |\n    | j=2 |  3  |  4  |  5  |\n\n    Parameters:\n        i (Union[int, ak.Array, np.ndarray]): The row index or array of row indices.\n        j (Union[int, ak.Array, np.ndarray]): The column index or array of column indices.\n        ndim (int): The dimension of the similarity matrix.\n\n    Returns:\n        The index or array of indices corresponding to the given row and column indices.\n\n    Raises:\n        ValueError: If the row and column indices are not of the same type, or if one of them is not an integer.\n        ValueError: If the row or column indices are greater than or equal to the dimension of the similarity matrix.\n        ValueError: If the row or column indices are negative.\n    \"\"\"\n    # Check type\n    return_type: Literal[\"ak\", \"np\"] = \"ak\"\n    if type(i) != type(j):\n        if isinstance(i, int):\n            return_type = \"np\" if isinstance(j, np.ndarray) else \"ak\"\n            i = ak.ones_like(j) * i\n        elif isinstance(j, int):\n            return_type = \"np\" if isinstance(i, np.ndarray) else \"ak\"\n            j = ak.ones_like(i) * j\n        else:\n            raise ValueError(\n                \"i and j should be the same type, or one of them should be an integer.\"\n            )\n    else:\n        return_type = \"np\" if isinstance(i, np.ndarray) else \"ak\"\n\n    i, j = ak.sort([i, j], axis=0)\n    res = j * (j + 1) // 2 + i\n\n    # Check dimension\n    if ak.any([i &gt;= ndim, j &gt;= ndim]):\n        raise ValueError(\n            \"Indices i and j should be less than the dimension of the similarity matrix.\"\n        )\n    if ak.any([i &lt; 0, j &lt; 0]):\n        raise ValueError(\"Indices i and j should be non-negative.\")\n\n    if return_type == \"np\" and isinstance(res, ak.Array):\n        res = res.to_numpy()\n\n    return res\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.expand_zipped_symetric_matrix","title":"<code>expand_zipped_symetric_matrix(arr)</code>","text":"<p>Recover a flattened simplified symmetric matrix represented as a 1D array back to a 2D matrix. This function assumes the last dimension of the input array is the flattened symmetric matrix, and will transform array</p> <pre><code>[[a11, a12, a22, a13, a23, a33],\n [b11, b12, b22, b13, b23, b33]]\n</code></pre> <p>to</p> <pre><code>[[[a11, a12, a13],\n  [a12, a22, a23],\n  [a13, a23, a33]],\n\n [[b11, b12, b13],\n  [b12, b22, b23],\n  [b13, b23, b33]]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Union[Array, ndarray]</code> <p>The input array representing the flattened simplified symmetric matrix.</p> required <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The reshaped symmetric matrix as a 2D array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input array does not have a symmetric shape.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def expand_zipped_symetric_matrix(\n    arr: Union[ak.Array, np.ndarray],\n) -&gt; Union[ak.Array, np.ndarray]:\n    \"\"\"\n    Recover a flattened simplified symmetric matrix represented as a 1D array back to a 2D matrix.\n    This function assumes the last dimension of the input array is the flattened symmetric matrix,\n    and will transform array\n\n    ```\n    [[a11, a12, a22, a13, a23, a33],\n     [b11, b12, b22, b13, b23, b33]]\n    ```\n\n    to\n\n    ```\n    [[[a11, a12, a13],\n      [a12, a22, a23],\n      [a13, a23, a33]],\n\n     [[b11, b12, b13],\n      [b12, b22, b23],\n      [b13, b23, b33]]]\n    ```\n\n    Parameters:\n        arr (Union[ak.Array, np.ndarray]): The input array representing the flattened simplified symmetric matrix.\n\n    Returns:\n        The reshaped symmetric matrix as a 2D array.\n\n    Raises:\n        ValueError: If the input array does not have a symmetric shape.\n    \"\"\"\n    ndim_data: int = arr.ndim\n\n    # Get the number of elements in the symmetric matrix\n    if isinstance(arr, ak.Array):\n        type_strs = [i.strip() for i in arr.typestr.split(\"*\")[:-1]]\n        n_err_elements = int(type_strs[-1])\n\n        ndim_err = (np.sqrt(1 + 8 * n_err_elements) - 1) / 2\n        if not ndim_err.is_integer():\n            raise ValueError(\"The array does not have a symmetric shape.\")\n        ndim_err = int(ndim_err)\n    elif isinstance(arr, np.ndarray):\n        n_err_elements = arr.shape[-1]\n\n    # Reshape the array\n    tmp_matrix = []\n    for i in range(ndim_err):\n        tmp_row = []\n        for j in range(ndim_err):\n            tmp_idx = tuple(\n                [slice(None)] * (ndim_data - 1)\n                + [get_symetric_matrix_idx(i, j, ndim_err), np.newaxis, np.newaxis]\n            )\n            tmp_row.append(arr[tmp_idx])\n\n        if isinstance(arr, ak.Array):\n            tmp_matrix.append(ak.concatenate(tmp_row, axis=-1))\n        else:\n            tmp_matrix.append(np.concatenate(tmp_row, axis=-1))\n\n    if isinstance(arr, ak.Array):\n        res = ak.concatenate(tmp_matrix, axis=-2)\n    else:\n        res = np.concatenate(tmp_matrix, axis=-2)\n\n    return res\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.expand_subbranch_symetric_matrix","title":"<code>expand_subbranch_symetric_matrix(sub_br_arr, matrix_fields)</code>","text":"<p>Recover simplified symmetric matrix back to 2D matrix from specified fields of a branch array.</p> <p>Parameters:</p> Name Type Description Default <code>sub_br_arr</code> <code>Array</code> <p>Subbranch array that need to be recovered.</p> required <code>matrix_fields</code> <code>Union[str, list[str]]</code> <p>Name of list of names of fields to be recovered.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>An array with recovered fields.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def expand_subbranch_symetric_matrix(\n    sub_br_arr: ak.Array, matrix_fields: Union[str, list[str]]\n) -&gt; ak.Array:\n    \"\"\"\n    Recover simplified symmetric matrix back to 2D matrix from specified fields of a branch array.\n\n    Parameters:\n        sub_br_arr: Subbranch array that need to be recovered.\n        matrix_fields: Name of list of names of fields to be recovered.\n\n    Returns:\n        An array with recovered fields.\n    \"\"\"\n    if isinstance(matrix_fields, str):\n        matrix_fields = {matrix_fields}\n    matrix_fields = set(matrix_fields)\n\n    res_dict = {}\n    for field_name in sub_br_arr.fields:\n        if field_name in matrix_fields:\n            res_dict[field_name] = expand_zipped_symetric_matrix(sub_br_arr[field_name])\n        else:\n            res_dict[field_name] = sub_br_arr[field_name]\n    return ak.Array(res_dict)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_digi_subbranch","title":"<code>process_digi_subbranch(org_arr)</code>","text":"<p>Processes the <code>TRawData</code> subbranch of the input awkward array and returns a new array with the subbranch fields merged into the top level.</p> <p>Parameters:</p> Name Type Description Default <code>org_arr</code> <code>Array</code> <p>The input awkward array containing the <code>TRawData</code> subbranch.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A new awkward array with the fields of <code>TRawData</code> merged into the top level.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>TRawData</code> is not found in the input array fields.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_digi_subbranch(org_arr: ak.Array) -&gt; ak.Array:\n    \"\"\"\n    Processes the `TRawData` subbranch of the input awkward array and returns a new array with the subbranch fields\n    merged into the top level.\n\n    Parameters:\n        org_arr (ak.Array): The input awkward array containing the `TRawData` subbranch.\n\n    Returns:\n        A new awkward array with the fields of `TRawData` merged into the top level.\n\n    Raises:\n        AssertionError: If `TRawData` is not found in the input array fields.\n    \"\"\"\n    assert \"TRawData\" in org_arr.fields, \"TRawData not found in the input array\"\n\n    fields = {}\n    for field_name in org_arr.fields:\n        if field_name == \"TRawData\":\n            for raw_field_name in org_arr[field_name].fields:\n                fields[raw_field_name] = org_arr[field_name][raw_field_name]\n        else:\n            fields[field_name] = org_arr[field_name]\n\n    return ak.Array(fields)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_evtrec_m_Evtx","title":"<code>process_evtrec_m_Evtx(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_evtrec_m_Evtx(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_Evtx\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_evtrec_m_evtRecVeeVertexCol","title":"<code>process_evtrec_m_evtRecVeeVertexCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_evtrec_m_evtRecVeeVertexCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_Ew\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_dst_m_mdcTrackCol","title":"<code>process_dst_m_mdcTrackCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_dst_m_mdcTrackCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_err\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_dst_m_emcTrackCol","title":"<code>process_dst_m_emcTrackCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_dst_m_emcTrackCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_err\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_dst_m_extTrackCol","title":"<code>process_dst_m_extTrackCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_dst_m_extTrackCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(\n        org_arr,\n        {\n            \"myEmcErrorMatrix\",\n            \"myMucErrorMatrix\",\n            \"myTof1ErrorMatrix\",\n            \"myTof2ErrorMatrix\",\n        },\n    )\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_rec_m_recMdcTrackCol","title":"<code>process_rec_m_recMdcTrackCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_rec_m_recMdcTrackCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_err\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_rec_m_recEmcShowerCol","title":"<code>process_rec_m_recEmcShowerCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_rec_m_recEmcShowerCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_err\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_rec_m_recMdcKalTrackCol","title":"<code>process_rec_m_recMdcKalTrackCol(org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_rec_m_recMdcKalTrackCol(org_arr: ak.Array) -&gt; ak.Array:\n    return expand_subbranch_symetric_matrix(org_arr, \"m_terror\")\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.preprocess_subbranch","title":"<code>preprocess_subbranch(full_branch_path, org_arr)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def preprocess_subbranch(full_branch_path: str, org_arr: ak.Array) -&gt; ak.Array:\n    evt_name, subbranch_name = full_branch_path.split(\"/\")\n\n    if evt_name == \"TDigiEvent\" and subbranch_name != \"m_fromMc\":\n        return process_digi_subbranch(org_arr)\n\n    if evt_name == \"TEvtRecObject\":\n        if subbranch_name == \"m_Evtx\":\n            return process_evtrec_m_Evtx(org_arr)\n        if subbranch_name == \"m_evtRecVeeVertexCol\":\n            return process_evtrec_m_evtRecVeeVertexCol(org_arr)\n\n    if evt_name == \"TDstEvent\":\n        if subbranch_name == \"m_mdcTrackCol\":\n            return process_dst_m_mdcTrackCol(org_arr)\n        if subbranch_name == \"m_emcTrackCol\":\n            return process_dst_m_emcTrackCol(org_arr)\n        if subbranch_name == \"m_extTrackCol\":\n            return process_dst_m_extTrackCol(org_arr)\n\n    if evt_name == \"TRecEvent\":\n        if subbranch_name == \"m_recMdcTrackCol\":\n            return process_rec_m_recMdcTrackCol(org_arr)\n        if subbranch_name == \"m_recEmcShowerCol\":\n            return process_rec_m_recEmcShowerCol(org_arr)\n        if subbranch_name == \"m_recMdcKalTrackCol\":\n            return process_rec_m_recMdcKalTrackCol(org_arr)\n\n    # Default return\n    return org_arr\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.BesInterpretation","title":"<code>BesInterpretation</code>","text":"<p>               Bases: <code>Interpretation</code></p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>class BesInterpretation(uproot.interpretation.Interpretation):\n    def __init__(self, full_branch_name: str) -&gt; None:\n        super().__init__()\n\n        self.full_branch_name = full_branch_name\n        self.parse_rule, self.element_type_name = branchname_to_element_type[full_branch_name]\n\n    def final_array(\n        self,\n        basket_arrays,\n        entry_start,\n        entry_stop,\n        entry_offsets,\n        library,\n        branch,\n        options,\n    ):\n        basket_entry_starts = np.array(entry_offsets[:-1])\n        basket_entry_stops = np.array(entry_offsets[1:])\n\n        basket_start_idx = np.where(basket_entry_starts &lt;= entry_start)[0].max()\n        basket_end_idx = np.where(basket_entry_stops &gt;= entry_stop)[0].min()\n\n        arr_to_concat = [basket_arrays[i] for i in range(basket_start_idx, basket_end_idx + 1)]\n        tot_array = ak.concatenate(arr_to_concat)\n\n        relative_entry_start = entry_start - basket_entry_starts[basket_start_idx]\n        relative_entry_stop = entry_stop - basket_entry_starts[basket_start_idx]\n\n        return tot_array[relative_entry_start:relative_entry_stop]\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__)\n\n    def __repr__(self) -&gt; str:\n        return f\"BES::As({self.typename})\"\n\n    @property\n    def cache_key(self):\n        return str(self.__class__)\n\n    @property\n    def typename(self):\n        res = \"BES::\"\n        if self.parse_rule == kTObjArray:\n            res += f\"TObjArray&lt;{self.element_type_name}&gt;\"\n        elif self.parse_rule == kTObject:\n            res += self.element_type_name\n        elif self.parse_rule == kSTL:\n            res += self.element_type_name\n        else:\n            raise NotImplementedError(\n                f\"Unsupported parse_rule: {self.parse_rule}, {self.element_type_name}\"\n            )\n        return res\n\n    def basket_array(\n        self,\n        data: np.ndarray,\n        byte_offsets: np.ndarray,\n        basket,\n        branch: uproot.models.TBranch.Model_TBranchElement,\n        context,\n        cursor_offset,\n        library,\n        options,\n    ):\n        # For BES TObject and TObjArray, element class streamers are needed\n        # Check streamers and versions\n        if self.parse_rule == kTObjArray or self.parse_rule == kTObject:\n            obj_streamer = branch.file.streamers.get(self.element_type_name)\n            if obj_streamer is None:\n                raise ValueError(\n                    f\"Streamer for {self.element_type_name} not found, maybe this branch is empty?\"\n                )\n\n            obj_versions = list(obj_streamer.keys())\n            assert (\n                len(obj_versions) == 1\n            ), \"Only one version of streamer is supported. Maybe you mixed data from different versions?\"\n\n        def get_streamer_list(type_name: str) -&gt; list[dict]:\n            return [\n                i.all_members\n                for i in list(branch.file.streamers[type_name].values())[0].member(\"fElements\")\n            ]\n\n        all_streamer_info = {k: get_streamer_list(k) for k in branch.file.streamers.keys()}\n\n        if self.parse_rule == kTObjArray:\n            org_data = read_bes_tobjarray(\n                data, byte_offsets, self.element_type_name, all_streamer_info\n            )\n        elif self.parse_rule == kTObject:\n            org_data = read_bes_tobject(\n                data, byte_offsets, self.element_type_name, all_streamer_info\n            )\n        elif self.parse_rule == kSTL:\n            org_data = read_bes_stl(\n                data, byte_offsets, self.element_type_name, all_streamer_info\n            )\n        else:\n            raise NotImplementedError(\n                f\"Unsupported parse_rule: {self.parse_rule}, {self.element_type_name}\"\n            )\n\n        if isinstance(library, uproot.interpretation.library.NumPy):\n            raise NotImplementedError(\"Numpy library is not supported\")\n\n        if isinstance(library, uproot.interpretation.library.Pandas):\n            raise NotImplementedError(\"Pandas library is not supported\")\n\n        assert isinstance(library, uproot.interpretation.library.Awkward), (\n            \"Unknown library: %s\" % library\n        )\n\n        if self.parse_rule == kTObjArray:\n            ak_arr = tobjarray_np2ak(self.element_type_name, org_data, all_streamer_info)\n        elif self.parse_rule == kTObject:\n            ak_arr = tobject_np2ak(self.element_type_name, org_data, all_streamer_info)\n        elif self.parse_rule == kSTL:\n            ak_arr = stl_np2ak(org_data, self.element_type_name, all_streamer_info)\n        else:\n            raise NotImplementedError(\n                f\"Unsupported parse_rule: {self.parse_rule}, {self.element_type_name}\"\n            )\n\n        # preprocess awkward array\n        return preprocess_subbranch(self.full_branch_name, ak_arr)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.bes_interpretation_of","title":"<code>bes_interpretation_of(branch, context, simplify=True)</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def bes_interpretation_of(\n    branch: uproot.behaviors.TBranch.TBranch, context: dict, simplify: bool = True\n) -&gt; uproot.interpretation.Interpretation:\n    if not hasattr(branch, \"parent\"):\n        return _uproot_interpretation_of(branch, context, simplify)\n\n    parent_name = branch.parent.name\n    full_branch_name = f\"{parent_name}/{branch.name}\"\n\n    if full_branch_name not in branchname_to_element_type.keys():\n        return _uproot_interpretation_of(branch, context, simplify)\n\n    if branchname_to_element_type[full_branch_name][0] == kFallBack:\n        return _uproot_interpretation_of(branch, context, simplify)\n\n    return BesInterpretation(full_branch_name=full_branch_name)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.wrap_uproot_interpretation","title":"<code>wrap_uproot_interpretation()</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot_interpretation():\n    global _is_uproot_interpretation_of_wrapped\n    if not _is_uproot_interpretation_of_wrapped:\n        _is_uproot_interpretation_of_wrapped = True\n        uproot.interpretation.identify.interpretation_of = bes_interpretation_of\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.wrap_uproot_TBranchElement_branches","title":"<code>wrap_uproot_TBranchElement_branches()</code>","text":"Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot_TBranchElement_branches():\n    def branches(self):\n        if self.name not in BES_BRANCH_NAMES:\n            return self.member(\"fBranches\")\n        else:\n            res = []\n            for br in self.member(\"fBranches\"):\n                if br.name == \"TObject\":\n                    continue\n\n                interpret_type, class_name = branchname_to_element_type[\n                    f\"{self.name}/{br.name}\"\n                ]\n                if interpret_type == kFallBack or class_name in self.file.streamers:\n                    res.append(br)\n                else:\n                    continue\n            return res\n\n    global _is_TBranchElement_branches_wrapped\n    if not _is_TBranchElement_branches_wrapped:\n        _is_TBranchElement_branches_wrapped = True\n        uproot.models.TBranch.Model_TBranchElement.branches = property(branches)\n        for v in uproot.models.TBranch.Model_TBranchElement.known_versions.values():\n            v.branches = property(branches)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.wrap_uproot","title":"<code>wrap_uproot()</code>","text":"<p>Wraps the uproot functions to use the BES interpretation.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot():\n    \"\"\"\n    Wraps the uproot functions to use the BES interpretation.\n    \"\"\"\n    wrap_uproot_interpretation()\n    wrap_uproot_TBranchElement_branches()\n</code></pre>"},{"location":"api/pybes3.besio/#raw_io","title":"raw_io","text":""},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.BesFlag","title":"<code>BesFlag</code>  <code>dataclass</code>","text":"Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>@dataclass\nclass BesFlag:\n    FILE_START = 0x1234AAAA\n    FILE_NAME = 0x1234AABB\n    RUN_PARAMS = 0x1234BBBB\n    DATA_SEPERATOR = 0x1234CCCC\n    FILE_TAIL_START = 0x1234DDDD\n    FILE_END = 0x1234EEEE\n\n    FULL_EVENT_FRAGMENT = 0xAA1234AA\n    SUB_DETECTOR = 0xBB1234BB\n    ROS = 0xCC1234CC\n    ROB = 0xDD1234DD\n    ROD = 0xEE1234EE\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io._raw_dict_to_ak","title":"<code>_raw_dict_to_ak(raw_dict)</code>","text":"Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def _raw_dict_to_ak(raw_dict: dict):\n    contents = {}\n\n    for field_name, org_data in raw_dict.items():\n        if field_name == \"evt_header\":\n            contents[field_name] = awkward.contents.RecordArray(\n                [awkward.contents.NumpyArray(i) for i in org_data.values()],\n                list(org_data.keys()),\n            )\n\n        elif field_name in {\"mdc\", \"tof\", \"emc\", \"muc\"}:\n            offsets, data_dict = org_data\n            contents[field_name] = awkward.contents.ListOffsetArray(\n                awkward.index.Index(offsets),\n                awkward.contents.RecordArray(\n                    [awkward.contents.NumpyArray(i) for i in data_dict.values()],\n                    list(data_dict.keys()),\n                ),\n            )\n        else:\n            offsets, data = org_data\n            contents[field_name] = awkward.contents.ListOffsetArray(\n                awkward.index.Index(offsets),\n                awkward.contents.NumpyArray(data),\n            )\n\n    return ak.Array(contents)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.RawBinaryReader","title":"<code>RawBinaryReader</code>","text":"Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>class RawBinaryReader:\n    def __init__(\n        self,\n        file: str,\n    ):\n        self.file = str(Path(file).resolve())\n        self._file = open(file, \"rb\")\n\n        self.file_version: int = -1\n        self.file_number: int = -1\n        self.file_date: int = -1\n        self.file_time: int = -1\n\n        self.app_name: str = \"None\"\n        self.app_tag: str = \"None\"\n\n        self.run_number: int = -1\n        self.max_events: int = -1\n        self.rec_enable: int = -1\n        self.trigger_type: int = -1\n        self.detector_mask: int = -1\n        self.beam_type: int = -1\n        self.beam_energy: int = -1\n\n        self.entries: int = -1\n\n        self.data_start: int = 0  # in char\n        self.data_end: int = 0  # in char\n        self.file_size: int = 0  # in char\n        self.data_size: int = 0  # in char\n\n        self.event_starts: np.ndarray = np.empty(0, dtype=np.uint32)  # in char\n        self.event_stops: np.ndarray = np.empty(0, dtype=np.uint32)  # in char\n        self.max_event_offset: int = 0\n        self.current_entry: int = -1\n\n        self._preprocess_file()\n\n    def arrays(\n        self,\n        n_blocks: int = -1,\n        n_block_per_batch: int = 1000,\n        sub_detectors: Union[list[str], None] = None,\n        max_workers: Union[int, None] = None,\n    ) -&gt; ak.Array:\n        \"\"\"\n        Read and return arrays of data from the BES raw file.\n\n        Parameters:\n            n_blocks (int, optional): The number of blocks to read. Defaults to -1, which means read all blocks.\n            n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n            sub_detectors (Union[list[str], None], optional): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n            max_workers (Union[int, None], optional): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n\n        Returns:\n            An Awkward Array containing the read data.\n        \"\"\"\n\n        self._reset_cursor()\n\n        if sub_detectors is None:\n            sub_detectors = []\n\n        executor = ThreadPoolExecutor(max_workers=max_workers)\n\n        n_total_blocks_read = 0\n\n        futures: list[Future] = []\n        while n_total_blocks_read &lt; n_blocks or (\n            n_blocks == -1 and self._file.tell() &lt; self.data_end\n        ):\n            n_tlock_to_read = (\n                min(n_blocks - n_total_blocks_read, n_block_per_batch)\n                if n_blocks != -1\n                else n_block_per_batch\n            )\n\n            batch_data, n_read = self._read_batch(n_tlock_to_read)\n            futures.append(executor.submit(read_bes_raw, batch_data, sub_detectors))\n            n_total_blocks_read += n_read\n\n        res = []\n        for future in futures:\n            org_dict = future.result()\n            res.append(_raw_dict_to_ak(org_dict))\n\n        return ak.concatenate(res)\n\n    def _read(self) -&gt; int:\n        return int.from_bytes(self._file.read(4), \"little\")\n\n    def _skip(self, n: int = 1) -&gt; None:\n        self._file.seek(4 * n, 1)\n\n    def _preprocess_file(self):\n        # file header\n        assert self._read() == BesFlag.FILE_START, \"Invalid start flag\"\n        self._skip()\n\n        self.file_version = self._read()\n        self.file_number = self._read()\n        self.file_date = self._read()\n        self.file_time = self._read()\n        self._skip(2)\n\n        # file name\n        assert self._read() == BesFlag.FILE_NAME, \"Invalid file name flag\"\n\n        nchar_name = self._read()\n        nbytes_name = np.ceil(nchar_name / 4).astype(int)\n        self.file_name = self._file.read(nbytes_name * 4).decode(\"utf-8\").strip()\n\n        nchar_tag = self._read()\n        nbytes_tag = np.ceil(nchar_tag / 4).astype(int)\n        self.file_tag = self._file.read(nbytes_tag * 4).decode(\"utf-8\").strip()\n\n        # run parameters\n        assert self._read() == BesFlag.RUN_PARAMS, \"Invalid run params flag\"\n        self._skip()\n\n        self.run_number = self._read()\n        self.max_events = self._read()\n        self.rec_enable = self._read()\n        self.trigger_type = self._read()\n        self.detector_mask = self._read()\n        self.beam_type = self._read()\n        self.beam_energy = self._read()\n\n        # other information\n        self.data_start = self._file.tell()\n        self._file.seek(0, 2)\n        self.file_size = self._file.tell()\n        self.data_end = self.file_size - 10 * 4\n        self.data_size = self.data_end - self.data_start\n\n        # read file tail\n        self._file.seek(-10 * 4, 2)\n        assert self._read() == BesFlag.FILE_TAIL_START, \"Invalid file tail start flag\"\n        self._skip(3)\n        self.entries = self._read()\n        self._skip(4)\n        assert self._read() == BesFlag.FILE_END, \"Invalid file end flag\"\n\n        self._reset_cursor()\n\n    def _reset_cursor(self):\n        self._file.seek(self.data_start)\n        self.current_entry = 0\n\n    def _skip_event(self):\n        flag = self._read()\n        if flag == BesFlag.DATA_SEPERATOR:\n            self._skip(3)\n            flag = self._read()\n\n        assert flag == BesFlag.FULL_EVENT_FRAGMENT, \"Invalid event fragment flag\"\n\n        total_size = self._read()\n\n        if self.current_entry &gt; self.max_event_offset:\n            self.event_starts[self.current_entry] = self._file.tell() - 4 * 2\n            self.event_stops[self.current_entry] = (\n                self.event_starts[self.current_entry] + total_size\n            )\n\n        self._skip(total_size - 2)\n        self.current_entry += 1\n\n    def _read_batch(self, n_blocks: int):\n        pos_start = self._file.tell()\n        block_counter = 0\n        for _ in range(n_blocks):\n            if self._file.tell() &gt;= self.data_end:\n                assert self._file.tell() == self.data_end, \"Invalid data end\"\n                break\n\n            assert self._read() == BesFlag.DATA_SEPERATOR, \"Invalid data seperator flag\"\n            self._skip(2)\n            block_size = self._read()\n            self._skip(block_size // 4)\n            block_counter += 1\n\n        pos_end = self._file.tell()\n\n        self._file.seek(pos_start, 0)\n        batch_data = np.frombuffer(self._file.read(pos_end - pos_start), dtype=np.uint32)\n\n        return batch_data, block_counter\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"BesRawReader\\n\"\n            f\"- File: {self.file}\\n\"\n            f\"- Run Number: {self.run_number}\\n\"\n            f\"- Entries: {self.entries}\\n\"\n            f\"- File Size: {self.file_size//1024//1024} MB\\n\"\n        )\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.RawBinaryReader.arrays","title":"<code>arrays(n_blocks=-1, n_block_per_batch=1000, sub_detectors=None, max_workers=None)</code>","text":"<p>Read and return arrays of data from the BES raw file.</p> <p>Parameters:</p> Name Type Description Default <code>n_blocks</code> <code>int</code> <p>The number of blocks to read. Defaults to -1, which means read all blocks.</p> <code>-1</code> <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>1000</code> <code>sub_detectors</code> <code>Union[list[str], None]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Union[int, None]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array</code> <p>An Awkward Array containing the read data.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def arrays(\n    self,\n    n_blocks: int = -1,\n    n_block_per_batch: int = 1000,\n    sub_detectors: Union[list[str], None] = None,\n    max_workers: Union[int, None] = None,\n) -&gt; ak.Array:\n    \"\"\"\n    Read and return arrays of data from the BES raw file.\n\n    Parameters:\n        n_blocks (int, optional): The number of blocks to read. Defaults to -1, which means read all blocks.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Union[list[str], None], optional): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Union[int, None], optional): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n\n    Returns:\n        An Awkward Array containing the read data.\n    \"\"\"\n\n    self._reset_cursor()\n\n    if sub_detectors is None:\n        sub_detectors = []\n\n    executor = ThreadPoolExecutor(max_workers=max_workers)\n\n    n_total_blocks_read = 0\n\n    futures: list[Future] = []\n    while n_total_blocks_read &lt; n_blocks or (\n        n_blocks == -1 and self._file.tell() &lt; self.data_end\n    ):\n        n_tlock_to_read = (\n            min(n_blocks - n_total_blocks_read, n_block_per_batch)\n            if n_blocks != -1\n            else n_block_per_batch\n        )\n\n        batch_data, n_read = self._read_batch(n_tlock_to_read)\n        futures.append(executor.submit(read_bes_raw, batch_data, sub_detectors))\n        n_total_blocks_read += n_read\n\n    res = []\n    for future in futures:\n        org_dict = future.result()\n        res.append(_raw_dict_to_ak(org_dict))\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io._is_raw","title":"<code>_is_raw(file)</code>","text":"Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def _is_raw(file):\n    f = open(file, \"rb\")\n    if int.from_bytes(f.read(4), \"little\") == BesFlag.FILE_START:\n        f.close()\n        return True\n    return False\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.concatenate","title":"<code>concatenate(files, n_block_per_batch=10000, sub_detectors=None, max_workers=None, verbose=False)</code>","text":"<p>Concatenate multiple raw binary files into <code>ak.Array</code></p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[Union[str, Path], list[Union[str, Path]]]</code> <p>files to be read.</p> required <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>10000</code> <code>sub_detectors</code> <code>Union[list[str], None]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Union[int, None]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Show reading process.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>Concatenated raw data array.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def concatenate(\n    files: Union[Union[str, Path], list[Union[str, Path]]],\n    n_block_per_batch: int = 10000,\n    sub_detectors: Union[list[str], None] = None,\n    max_workers: Union[int, None] = None,\n    verbose: bool = False,\n) -&gt; ak.Array:\n    \"\"\"\n    Concatenate multiple raw binary files into `ak.Array`\n\n    Parameters:\n        files (Union[Union[str, Path], list[Union[str, Path]]]): files to be read.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Union[list[str], None], optional): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Union[int, None], optional): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n        verbose (bool): Show reading process.\n\n    Returns:\n        Concatenated raw data array.\n    \"\"\"\n\n    if not isinstance(files, list):\n        files = glob.glob(files)\n\n    files = [str(Path(file).resolve()) for file in files if _is_raw(file)]\n\n    if len(files) == 0:\n        raise ValueError(\"No valid raw files found\")\n\n    res = []\n    for i, f in enumerate(files):\n        if verbose:\n            print(f\"\\rreading file {i+1}/{len(files)} ...\", end=\"\")\n\n        res.append(\n            RawBinaryReader(f).arrays(-1, n_block_per_batch, sub_detectors, max_workers)\n        )\n\n    if verbose:\n        print()\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3.detectors/","title":"pybes3.detectors","text":""},{"location":"api/pybes3.detectors/#parsing-methods","title":"Parsing methods","text":""},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_mdc_gid","title":"<code>parse_mdc_gid(gid, with_pos=True)</code>","text":"<p>Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795. When <code>gid</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>layer</code>: Layer number.</li> <li><code>wire</code>: Local wire number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_gid(gid: IntLike, with_pos: bool = True) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795.\n    When `gid` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `layer`: Layer number.\n    - `wire`: Local wire number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        gid: The gid of the wire.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    layer = mdc_gid_to_layer(gid)\n    wire = mdc_gid_to_wire(gid)\n\n    res = {\n        \"gid\": gid,\n        \"layer\": layer,\n        \"wire\": wire,\n        \"stereo\": mdc_gid_to_stereo(gid),\n        \"is_stereo\": mdc_gid_to_is_stereo(gid),\n        \"superlayer\": mdc_gid_to_superlayer(gid),\n    }\n\n    if with_pos:\n        west_x = mdc_gid_to_west_x(gid)\n        west_y = mdc_gid_to_west_y(gid)\n        east_x = mdc_gid_to_east_x(gid)\n        east_y = mdc_gid_to_east_y(gid)\n        res[\"mid_x\"] = (west_x + east_x) / 2\n        res[\"mid_y\"] = (west_y + east_y) / 2\n        res[\"west_x\"] = west_x\n        res[\"west_y\"] = west_y\n        res[\"west_z\"] = mdc_gid_to_west_z(gid)\n        res[\"east_x\"] = east_x\n        res[\"east_y\"] = east_y\n        res[\"east_z\"] = mdc_gid_to_east_z(gid)\n\n    if isinstance(gid, ak.Array):\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_mdc_digi_id","title":"<code>parse_mdc_digi_id(mdc_digi_id, with_pos=False)</code>","text":"<p>Parse MDC digi ID.</p> <p>When <code>mdc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>wire</code>: Local wire number.</li> <li><code>layer</code>: Layer number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_digi_id(\n    mdc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse MDC digi ID.\n\n    When `mdc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `wire`: Local wire number.\n    - `layer`: Layer number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    wire = digi_id.mdc_id_to_wire(mdc_digi_id)\n    layer = digi_id.mdc_id_to_layer(mdc_digi_id)\n    gid = get_mdc_gid(layer, wire)\n    return parse_mdc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_tof_digi_id","title":"<code>parse_tof_digi_id(tof_digi_id, flat=False, library='ak')</code>","text":"<p>Parse TOF digi ID. If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number. <code>0,1,2</code> for scintillator endcap0, barrel, endcap1; <code>3,4</code> for MRPC endcap0, endcap1.</li> <li><code>layer_or_module</code>: The scintillator layer or MRPC module number, based on the part number.</li> <li><code>phi_or_strip</code>: The scintillator phi or MRPC strip ID, based on the part number.</li> <li><code>end</code>: The readout end ID.</li> </ul> <p>The return value is based on the part number.</p> <p>Rows where <code>part &lt; 3</code> are scintillator and <code>layer_or_module</code> represents layer number, <code>phi_or_strip</code> represents phi number.</p> <p>Rows where <code>part &gt;= 3</code> are MRPC and <code>layer_or_module</code> represents module number, <code>phi_or_strip</code> represents strip ID.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed TOF ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_tof_digi_id(\n    tof_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse TOF digi ID.\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number. `0,1,2` for scintillator endcap0, barrel, endcap1; `3,4` for MRPC endcap0, endcap1.\n    - `layer_or_module`: The scintillator layer or MRPC module number, based on the part number.\n    - `phi_or_strip`: The scintillator phi or MRPC strip ID, based on the part number.\n    - `end`: The readout end ID.\n\n    The return value is based on the part number.\n\n    Rows where `part &lt; 3` are scintillator and `layer_or_module` represents layer number, `phi_or_strip` represents phi number.\n\n    Rows where `part &gt;= 3` are MRPC and `layer_or_module` represents module number, `phi_or_strip` represents strip ID.\n\n    Parameters:\n        tof_digi_id: The TOF ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed TOF ID.\n\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(tof_digi_id, ak.Array):\n        tof_digi_id = ak.flatten(tof_digi_id)\n\n    part = digi_id.tof_id_to_part(tof_digi_id)\n    res = {\n        \"part\": part,\n        \"layer_or_module\": digi_id.tof_id_to_layer_or_module(tof_digi_id, part),\n        \"phi_or_strip\": digi_id.tof_id_to_phi_or_strip(tof_digi_id, part),\n        \"end\": digi_id.tof_id_to_end(tof_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_emc_digi_id","title":"<code>parse_emc_digi_id(emc_digi_id, with_pos=False)</code>","text":"<p>Parse EMC digi ID.</p> <p>When <code>emc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the crystal.</li> <li><code>part</code>: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.</li> <li><code>theta</code>: Theta number.</li> <li><code>phi</code>: Phi number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>front_center_x</code>: x position of the front center of the crystal.</li> <li><code>front_center_y</code>: y position of the front center of the crystal.</li> <li><code>front_center_z</code>: z position of the front center of the crystal.</li> <li><code>center_x</code>: x position of the center of the crystal.</li> <li><code>center_y</code>: y position of the center of the crystal.</li> <li><code>center_z</code>: z position of the center of the crystal.</li> </ul> <p>Info</p> <p>The 8 points of the crystal will not be returned here. If you need the 8 points of the crystal, use <code>emc_gid_to_point_x</code>, <code>emc_gid_to_point_y</code> and <code>emc_gid_to_point_z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed EMC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_emc_digi_id(\n    emc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse EMC digi ID.\n\n    When `emc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the crystal.\n    - `part`: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.\n    - `theta`: Theta number.\n    - `phi`: Phi number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `front_center_x`: x position of the front center of the crystal.\n    - `front_center_y`: y position of the front center of the crystal.\n    - `front_center_z`: z position of the front center of the crystal.\n    - `center_x`: x position of the center of the crystal.\n    - `center_y`: y position of the center of the crystal.\n    - `center_z`: z position of the center of the crystal.\n\n    !!! info\n        The 8 points of the crystal will not be returned here.\n        If you need the 8 points of the crystal, use `emc_gid_to_point_x`, `emc_gid_to_point_y`\n        and `emc_gid_to_point_z`.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed EMC digi ID.\n\n    \"\"\"\n    part = digi_id.emc_id_to_module(emc_digi_id)\n    theta = digi_id.emc_id_to_theta(emc_digi_id)\n    phi = digi_id.emc_id_to_phi(emc_digi_id)\n    gid = get_emc_gid(part, theta, phi)\n    return parse_emc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_muc_digi_id","title":"<code>parse_muc_digi_id(muc_digi_id, flat=False, library='ak')</code>","text":"<p>Parse MUC digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number.</li> <li><code>segment</code>: The segment number.</li> <li><code>layer</code>: The layer number.</li> <li><code>channel</code>: The channel number.</li> <li><code>gap</code>: The gap number, which is equivalent to layer number.</li> <li><code>strip</code>: The strip number, which is equivalent to channel number.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed MUC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_muc_digi_id(\n    muc_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse MUC digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number.\n    - `segment`: The segment number.\n    - `layer`: The layer number.\n    - `channel`: The channel number.\n    - `gap`: The gap number, which is equivalent to layer number.\n    - `strip`: The strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed MUC digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(muc_digi_id, ak.Array):\n        muc_digi_id = ak.flatten(muc_digi_id)\n\n    part = digi_id.muc_id_to_part(muc_digi_id)\n    segment = digi_id.muc_id_to_segment(muc_digi_id)\n    layer = digi_id.muc_id_to_layer(muc_digi_id)\n    channel = digi_id.muc_id_to_channel(muc_digi_id)\n\n    res = {\n        \"part\": part,\n        \"segment\": segment,\n        \"layer\": layer,\n        \"channel\": channel,\n        \"gap\": layer,\n        \"strip\": channel,\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_cgem_digi_id","title":"<code>parse_cgem_digi_id(cgem_digi_id, flat=False, library='ak')</code>","text":"<p>Parse CGEM digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>layer</code>: The layer number.</li> <li><code>sheet</code>: The sheet ID.</li> <li><code>strip</code>: The strip ID.</li> <li><code>is_x_strip</code>: Whether the strip is an X-strip.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed CGEM digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_cgem_digi_id(\n    cgem_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse CGEM digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `layer`: The layer number.\n    - `sheet`: The sheet ID.\n    - `strip`: The strip ID.\n    - `is_x_strip`: Whether the strip is an X-strip.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed CGEM digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(cgem_digi_id, ak.Array):\n        cgem_digi_id = ak.flatten(cgem_digi_id)\n\n    res = {\n        \"layer\": digi_id.cgem_id_to_layer(cgem_digi_id),\n        \"sheet\": digi_id.cgem_id_to_sheet(cgem_digi_id),\n        \"strip\": digi_id.cgem_id_to_strip(cgem_digi_id),\n        \"is_x_strip\": digi_id.cgem_id_to_is_x_strip(cgem_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#geometry","title":"Geometry","text":""},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_mdc_wire_position","title":"<code>get_mdc_wire_position(library='np')</code>","text":"<p>Get the MDC wire position table.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>Literal['np', 'ak', 'pd']</code> <p>The library to return the data in. Choose from 'ak', 'np', 'pd'.</p> <code>'np'</code> <p>Returns:</p> Type Description <code>Array | dict[str, ndarray] | DataFrame</code> <p>The MDC wire position table.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the library is not 'ak', 'np', or 'pd'.</p> <code>ImportError</code> <p>If the library is 'pd' but pandas is not installed.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>def get_mdc_wire_position(library: Literal[\"np\", \"ak\", \"pd\"] = \"np\"):\n    \"\"\"\n    Get the MDC wire position table.\n\n    Parameters:\n        library: The library to return the data in. Choose from 'ak', 'np', 'pd'.\n\n    Returns:\n        (ak.Array | dict[str, np.ndarray] | pd.DataFrame): The MDC wire position table.\n\n    Raises:\n        ValueError: If the library is not 'ak', 'np', or 'pd'.\n        ImportError: If the library is 'pd' but pandas is not installed.\n    \"\"\"\n    cp: dict[str, np.ndarray] = {k: v.copy() for k, v in _mdc_wire_position.items()}\n\n    if library == \"ak\":\n        return ak.Array(cp)\n    elif library == \"np\":\n        return cp\n    elif library == \"pd\":\n        try:\n            import pandas as pd  # type: ignore\n        except ImportError:\n            raise ImportError(\"Pandas is not installed. Run `pip install pandas`.\")\n        return pd.DataFrame(cp)\n    else:\n        raise ValueError(f\"Invalid library {library}. Choose from 'ak', 'np', 'pd'.\")\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_mdc_gid","title":"<code>get_mdc_gid(layer, wire)</code>","text":"<p>Get MDC gid of given layer and wire.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>wire</code> <code>IntLike</code> <p>The wire number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The gid of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.uint16(nb.int_, nb.int_)])\ndef get_mdc_gid(layer: IntLike, wire: IntLike) -&gt; IntLike:\n    \"\"\"\n    Get MDC gid of given layer and wire.\n\n    Parameters:\n        layer: The layer number.\n        wire: The wire number.\n\n    Returns:\n        The gid of the wire.\n    \"\"\"\n    return layer_start_gid[layer] + wire\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_layer","title":"<code>mdc_gid_to_layer(gid)</code>","text":"<p>Convert gid to layer.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef mdc_gid_to_layer(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert gid to layer.\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The layer number of the wire.\n    \"\"\"\n    return _layer[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_wire","title":"<code>mdc_gid_to_wire(gid)</code>","text":"<p>Convert gid to wire.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The wire number of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.uint16(nb.int_)])\ndef mdc_gid_to_wire(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert gid to wire.\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The wire number of the wire.\n    \"\"\"\n    return _wire[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_is_stereo","title":"<code>mdc_gid_to_is_stereo(gid)</code>","text":"<p>Convert gid to is_stereo.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>The is_stereo of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef mdc_gid_to_is_stereo(gid: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Convert gid to is_stereo.\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The is_stereo of the wire.\n    \"\"\"\n    return _is_stereo[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_layer_to_is_stereo","title":"<code>mdc_layer_to_is_stereo(layer)</code>","text":"<p>Convert layer to is_stereo.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>The is_stereo of the layer.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef mdc_layer_to_is_stereo(layer: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Convert layer to is_stereo.\n\n    Parameters:\n        layer: The layer number.\n\n    Returns:\n        The is_stereo of the layer.\n    \"\"\"\n    return is_layer_stereo[layer]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_east_x","title":"<code>mdc_gid_to_east_x(gid)</code>","text":"<p>Convert gid to east_x (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The east_x (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef mdc_gid_to_east_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to east_x (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The east_x (cm) of the wire.\n    \"\"\"\n    return _east_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_east_y","title":"<code>mdc_gid_to_east_y(gid)</code>","text":"<p>Convert gid to east_y (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The east_y (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef mdc_gid_to_east_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to east_y (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The east_y (cm) of the wire.\n    \"\"\"\n    return _east_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_east_z","title":"<code>mdc_gid_to_east_z(gid)</code>","text":"<p>Convert gid to east_z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The east_z (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef mdc_gid_to_east_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to east_z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The east_z (cm) of the wire.\n    \"\"\"\n    return _east_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_west_x","title":"<code>mdc_gid_to_west_x(gid)</code>","text":"<p>Convert gid to west_x (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The west_x (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef mdc_gid_to_west_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to west_x (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The west_x (cm) of the wire.\n    \"\"\"\n    return _west_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_west_y","title":"<code>mdc_gid_to_west_y(gid)</code>","text":"<p>Convert gid to west_y (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The west_y (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef mdc_gid_to_west_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to west_y (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The west_y (cm) of the wire.\n    \"\"\"\n    return _west_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_west_z","title":"<code>mdc_gid_to_west_z(gid)</code>","text":"<p>Convert gid to west_z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The west_z (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef mdc_gid_to_west_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to west_z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The west_z (cm) of the wire.\n    \"\"\"\n    return _west_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_z_to_x","title":"<code>mdc_gid_z_to_x(gid, z)</code>","text":"<p>Get the x (cm) position of the wire at z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>z</code> <code>FloatLike</code> <p>The z (cm) position.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x (cm) position of the wire at z (cm).</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_, nb.float64)])\ndef mdc_gid_z_to_x(gid: IntLike, z: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Get the x (cm) position of the wire at z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n        z: The z (cm) position.\n\n    Returns:\n        The x (cm) position of the wire at z (cm).\n    \"\"\"\n    return _west_x[gid] + dx_dz[gid] * (z - _west_z[gid])\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_z_to_y","title":"<code>mdc_gid_z_to_y(gid, z)</code>","text":"<p>Get the y (cm) position of the wire at z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>z</code> <code>FloatLike</code> <p>The z (cm) position.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y (cm) position of the wire at z (cm).</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_, nb.float64)])\ndef mdc_gid_z_to_y(gid: IntLike, z: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Get the y (cm) position of the wire at z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n        z: The z (cm) position.\n\n    Returns:\n        The y (cm) position of the wire at z (cm).\n    \"\"\"\n    return _west_y[gid] + dy_dz[gid] * (z - _west_z[gid])\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_emc_crystal_position","title":"<code>get_emc_crystal_position(library='np')</code>","text":"<p>Get EMC crystal position table.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>Literal['np', 'ak', 'pd']</code> <p>The library to return the data in. Choose from 'ak', 'np', 'pd'.</p> <code>'np'</code> <p>Returns:</p> Type Description <code>Array | dict[str, ndarray] | DataFrame</code> <p>The EMC crystal position table.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the library is not 'ak', 'np', or 'pd'.</p> <code>ImportError</code> <p>If the library is 'pd' but pandas is not installed.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>def get_emc_crystal_position(library: Literal[\"np\", \"ak\", \"pd\"] = \"np\"):\n    \"\"\"\n    Get EMC crystal position table.\n\n    Parameters:\n        library: The library to return the data in. Choose from 'ak', 'np', 'pd'.\n\n    Returns:\n        (ak.Array | dict[str, np.ndarray] | pd.DataFrame): The EMC crystal position table.\n\n    Raises:\n        ValueError: If the library is not 'ak', 'np', or 'pd'.\n        ImportError: If the library is 'pd' but pandas is not installed.\n    \"\"\"\n    cp: dict[str, np.ndarray] = {k: v.copy() for k, v in _emc_geom.items()}\n\n    res: dict[str, np.ndarray] = {}\n\n    for k in [\n        \"gid\",\n        \"center_x\",\n        \"center_y\",\n        \"center_z\",\n        \"front_center_x\",\n        \"front_center_y\",\n        \"front_center_z\",\n    ]:\n        res[k] = cp[k]\n\n    # flatten crystal points\n    for i in range(8):\n        res[f\"points_x_{i}\"] = cp[\"points_x\"][:, i]\n        res[f\"points_y_{i}\"] = cp[\"points_y\"][:, i]\n        res[f\"points_z_{i}\"] = cp[\"points_z\"][:, i]\n\n    if library == \"ak\":\n        return ak.Array(res)\n    elif library == \"np\":\n        return res\n    elif library == \"pd\":\n        try:\n            import pandas as pd  # type: ignore\n        except ImportError:\n            raise ImportError(\"Pandas is not installed. Run `pip install pandas`.\")\n        return pd.DataFrame(res)\n    else:\n        raise ValueError(f\"Invalid library {library}. Choose from 'ak', 'np', 'pd'.\")\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_emc_gid","title":"<code>get_emc_gid(part, theta, phi)</code>","text":"<p>Get EMC gid of given part, theta, and phi.</p> <ul> <li>part 0: 0-479<ul> <li>theta 0: 0-63</li> <li>theta 1: 64-127</li> <li>theta 2: 128-207</li> <li>theta 3: 208-287</li> <li>theta 4: 288-383</li> <li>theta 5: 384-479</li> </ul> </li> <li>part 1: 480-5759 (theta 0-47)</li> <li>part 2: 5760-6239<ul> <li>theta 5: 5760-5855 (96)</li> <li>theta 4: 5856-5951 (96)</li> <li>theta 3: 5952-6031 (80)</li> <li>theta 2: 6032-6111 (80)</li> <li>theta 1: 6112-6175 (64)</li> <li>theta 0: 6176-6239 (64)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>IntLike</code> <p>part number</p> required <code>theta</code> <code>IntLike</code> <p>theta number</p> required <code>phi</code> <code>IntLike</code> <p>phi number</p> required <p>Returns:</p> Name Type Description <code>index</code> <code>IntLike</code> <p>EMC index</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.uint16(nb.int_, nb.int_, nb.int_)])\ndef get_emc_gid(part: IntLike, theta: IntLike, phi: IntLike) -&gt; IntLike:\n    \"\"\"\n    Get EMC gid of given part, theta, and phi.\n\n    - part 0: 0-479\n        - theta 0: 0-63\n        - theta 1: 64-127\n        - theta 2: 128-207\n        - theta 3: 208-287\n        - theta 4: 288-383\n        - theta 5: 384-479\n    - part 1: 480-5759 (theta 0-47)\n    - part 2: 5760-6239\n        - theta 5: 5760-5855 (96)\n        - theta 4: 5856-5951 (96)\n        - theta 3: 5952-6031 (80)\n        - theta 2: 6032-6111 (80)\n        - theta 1: 6112-6175 (64)\n        - theta 0: 6176-6239 (64)\n\n    Parameters:\n        part: part number\n        theta: theta number\n        phi: phi number\n\n    Returns:\n        index: EMC index\n    \"\"\"\n    if part == 0:\n        res = 0\n        if theta == 0 or theta == 1:\n            return theta * ENDCAP_PHI_01 + phi\n\n        res += 2 * ENDCAP_PHI_01\n        if theta == 2 or theta == 3:\n            return res + (theta - 2) * ENDCAP_PHI_23 + phi\n\n        res += 2 * ENDCAP_PHI_23\n        if theta == 4 or theta == 5:\n            return res + (theta - 4) * ENDCAP_PHI_45 + phi\n\n    if part == 1:\n        return ENDCAP_CRYSTALS + theta * BARREL_PHI + phi\n\n    if part == 2:\n        res = ENDCAP_CRYSTALS + BARREL_CRYSTALS\n\n        if theta == 4 or theta == 5:\n            return res + (5 - theta) * ENDCAP_PHI_45 + phi\n\n        res += 2 * ENDCAP_PHI_45\n        if theta == 2 or theta == 3:\n            return res + (3 - theta) * ENDCAP_PHI_23 + phi\n\n        res += 2 * ENDCAP_PHI_23\n        if theta == 0 or theta == 1:\n            return res + (1 - theta) * ENDCAP_PHI_01 + phi\n\n    return 65535\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_center_x","title":"<code>emc_gid_to_center_x(gid)</code>","text":"<p>Convert EMC gid to x coordinate of the crystal's center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x coordinate of the crystal's center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef emc_gid_to_center_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to x coordinate of the crystal's center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The x coordinate of the crystal's center.\n    \"\"\"\n    return _center_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_center_y","title":"<code>emc_gid_to_center_y(gid)</code>","text":"<p>Convert EMC gid to y coordinate of the crystal's center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y coordinate of the crystal's center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef emc_gid_to_center_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to y coordinate of the crystal's center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The y coordinate of the crystal's center.\n    \"\"\"\n    return _center_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_center_z","title":"<code>emc_gid_to_center_z(gid)</code>","text":"<p>Convert EMC gid to z coordinate of the crystal's center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The z coordinate of the crystal's center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef emc_gid_to_center_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to z coordinate of the crystal's center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The z coordinate of the crystal's center.\n    \"\"\"\n    return _center_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_front_center_x","title":"<code>emc_gid_to_front_center_x(gid)</code>","text":"<p>Convert EMC gid to x coordinate of the crystal's front center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x coordinate of the crystal's front center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef emc_gid_to_front_center_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to x coordinate of the crystal's front center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The x coordinate of the crystal's front center.\n    \"\"\"\n    return _front_center_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_front_center_y","title":"<code>emc_gid_to_front_center_y(gid)</code>","text":"<p>Convert EMC gid to y coordinate of the crystal's front center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y coordinate of the crystal's front center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef emc_gid_to_front_center_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to y coordinate of the crystal's front center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The y coordinate of the crystal's front center.\n    \"\"\"\n    return _front_center_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_front_center_z","title":"<code>emc_gid_to_front_center_z(gid)</code>","text":"<p>Convert EMC gid to z coordinate of the crystal's front center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The z coordinate of the crystal's front center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_)])\ndef emc_gid_to_front_center_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to z coordinate of the crystal's front center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The z coordinate of the crystal's front center.\n    \"\"\"\n    return _front_center_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_part","title":"<code>emc_gid_to_part(gid)</code>","text":"<p>Convert EMC gid to part.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The part number of the crystal.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef emc_gid_to_part(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC gid to part.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The part number of the crystal.\n    \"\"\"\n    return _part[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_phi","title":"<code>emc_gid_to_phi(gid)</code>","text":"<p>Convert EMC gid to phi.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The phi number of the crystal.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef emc_gid_to_phi(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC gid to phi.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The phi number of the crystal.\n    \"\"\"\n    return _phi[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_point_x","title":"<code>emc_gid_to_point_x(gid, point)</code>","text":"<p>Convert EMC gid to x coordinate of the point.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <code>point</code> <code>IntLike</code> <p>The point number, 0-7.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x coordinate of the point.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_, nb.int_)])\ndef emc_gid_to_point_x(gid: IntLike, point: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to x coordinate of the point.\n\n    Parameters:\n        gid: The gid of the crystal.\n        point: The point number, 0-7.\n\n    Returns:\n        The x coordinate of the point.\n    \"\"\"\n    return _points_x[gid, point]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_point_y","title":"<code>emc_gid_to_point_y(gid, point)</code>","text":"<p>Convert EMC gid to y coordinate of the point.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <code>point</code> <code>IntLike</code> <p>The point number, 0-7.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y coordinate of the point.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_, nb.int_)])\ndef emc_gid_to_point_y(gid: IntLike, point: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to y coordinate of the point.\n\n    Parameters:\n        gid: The gid of the crystal.\n        point: The point number, 0-7.\n\n    Returns:\n        The y coordinate of the point.\n    \"\"\"\n    return _points_y[gid, point]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_point_z","title":"<code>emc_gid_to_point_z(gid, point)</code>","text":"<p>Convert EMC gid to z coordinate of the point.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <code>point</code> <code>IntLike</code> <p>The point number, 0-7.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The z coordinate of the point.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.float64(nb.int_, nb.int_)])\ndef emc_gid_to_point_z(gid: IntLike, point: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to z coordinate of the point.\n\n    Parameters:\n        gid: The gid of the crystal.\n        point: The point number, 0-7.\n\n    Returns:\n        The z coordinate of the point.\n    \"\"\"\n    return _points_z[gid, point]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_theta","title":"<code>emc_gid_to_theta(gid)</code>","text":"<p>Convert EMC gid to theta.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The theta number of the crystal.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef emc_gid_to_theta(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC gid to theta.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The theta number of the crystal.\n    \"\"\"\n    return _theta[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#digi-identifier","title":"Digi Identifier","text":""},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_mdc_id","title":"<code>check_mdc_id(mdc_digi_id)</code>","text":"<p>Check if the MDC digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef check_mdc_id(\n    mdc_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Check if the MDC digi ID is valid.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (mdc_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_MDC_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.mdc_id_to_wire","title":"<code>mdc_id_to_wire(mdc_digi_id)</code>","text":"<p>Convert MDC digi ID to wire number.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The wire number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint16(nb.int_)])\ndef mdc_id_to_wire(\n    mdc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert MDC digi ID to wire number.\n\n    Parameters:\n        mdc_digi_id: MDC digi ID array or value.\n\n    Returns:\n        The wire number.\n    \"\"\"\n    return (mdc_digi_id &amp; DIGI_MDC_WIRE_MASK) &gt;&gt; DIGI_MDC_WIRE_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.mdc_id_to_layer","title":"<code>mdc_id_to_layer(mdc_digi_id)</code>","text":"<p>Convert the MDC digi ID to the layer number.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef mdc_id_to_layer(\n    mdc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the MDC digi ID to the layer number.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID array or value.\n\n    Returns:\n        The layer number.\n    \"\"\"\n    return (mdc_digi_id &amp; DIGI_MDC_LAYER_MASK) &gt;&gt; DIGI_MDC_LAYER_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.mdc_id_to_is_stereo","title":"<code>mdc_id_to_is_stereo(mdc_digi_id)</code>","text":"<p>Convert the MDC digi ID to whether it is a stereo wire.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the wire is a stereo wire.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef mdc_id_to_is_stereo(\n    mdc_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Convert the MDC digi ID to whether it is a stereo wire.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID array or value.\n\n    Returns:\n        Whether the wire is a stereo wire.\n    \"\"\"\n    return (\n        mdc_digi_id &amp; DIGI_MDC_WIRETYPE_MASK\n    ) &gt;&gt; DIGI_MDC_WIRETYPE_OFFSET == DIGI_MDC_STEREO_WIRE\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_mdc_digi_id","title":"<code>get_mdc_digi_id(wire, layer, wire_type)</code>","text":"<p>Generate MDC digi ID based on the wire number, layer number, and wire type.</p> <p>Parameters:</p> Name Type Description Default <code>wire</code> <code>IntLike</code> <p>The wire number.</p> required <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>wire_type</code> <code>IntLike</code> <p>The wire type.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The MDC digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint32(nb.int_, nb.int_, nb.int_), nb.uint32(nb.int_, nb.int_, nb.boolean)])\ndef get_mdc_digi_id(\n    wire: IntLike,\n    layer: IntLike,\n    wire_type: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate MDC digi ID based on the wire number, layer number, and wire type.\n\n    Parameters:\n        wire: The wire number.\n        layer: The layer number.\n        wire_type: The wire type.\n\n    Returns:\n        The MDC digi ID.\n    \"\"\"\n    return (\n        ((wire &lt;&lt; DIGI_MDC_WIRE_OFFSET) &amp; DIGI_MDC_WIRE_MASK)\n        | ((layer &lt;&lt; DIGI_MDC_LAYER_OFFSET) &amp; DIGI_MDC_LAYER_MASK)\n        | ((wire_type &lt;&lt; DIGI_MDC_WIRETYPE_OFFSET) &amp; DIGI_MDC_WIRETYPE_MASK)\n        | (DIGI_MDC_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_tof_id","title":"<code>check_tof_id(tof_digi_id)</code>","text":"<p>Check if the TOF digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef check_tof_id(\n    tof_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Check if the TOF digi ID is valid.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (tof_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_TOF_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_part","title":"<code>tof_id_to_part(tof_digi_id)</code>","text":"<p>Convert TOF digi ID to part number. 0, 1, 2 for scintillator endcap0/barrel/endcap1, 3, 4 for MRPC endcap0/endcap1.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>TOF digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The part number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef tof_id_to_part(\n    tof_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert TOF digi ID to part number. 0, 1, 2 for scintillator endcap0/barrel/endcap1,\n    3, 4 for MRPC endcap0/endcap1.\n\n    Parameters:\n        tof_digi_id: TOF digi ID array or value.\n\n    Returns:\n        The part number.\n    \"\"\"\n    part = (tof_digi_id &amp; DIGI_TOF_PART_MASK) &gt;&gt; DIGI_TOF_PART_OFFSET\n    if part == 3:  # += MRPC endcap number\n        part += (tof_digi_id &amp; DIGI_TOF_MRPC_ENDCAP_MASK) &gt;&gt; DIGI_TOF_MRPC_ENDCAP_OFFSET\n    return part\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_layer_or_module","title":"<code>tof_id_to_layer_or_module(tof_digi_id, part=None)</code>","text":"<p>Convert the TOF digi ID to the scintillator layer or MRPC module number. If <code>part &lt; 3</code>, it is scintillator and the return value is layer number. Otherwise, it is MRPC and the return value is module number.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <code>part</code> <code>Union[IntLike, None]</code> <p>The part number. If not provided, it will be calculated based on the TOF digi ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>IntLike</code> <p>The scintillator layer or MRPC module number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def tof_id_to_layer_or_module(\n    tof_digi_id: IntLike,\n    part: Union[IntLike, None] = None,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the TOF digi ID to the scintillator layer or MRPC module number.\n    If `part &lt; 3`, it is scintillator and the return value is layer number. Otherwise, it is\n    MRPC and the return value is module number.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n        part: The part number. If not provided, it will be calculated based on the TOF digi ID.\n\n    Returns:\n        The scintillator layer or MRPC module number.\n    \"\"\"\n    if part is None:\n        return _tof_id_to_layer_or_module_1(tof_digi_id)\n    else:\n        return _tof_id_to_layer_or_module_2(tof_digi_id, part)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_phi_or_strip","title":"<code>tof_id_to_phi_or_strip(tof_digi_id, part=None)</code>","text":"<p>Convert the TOF digi ID to the scintillator phi or MRPC strip number, based on the part number. If <code>part &lt; 3</code>, it is scintillator and the return value is phi number. Otherwise, it is MRPC and the return value is strip number.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <code>part</code> <code>Union[IntLike, None]</code> <p>The part number. If not provided, it will be calculated based on the TOF digi ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>IntLike</code> <p>The scintillator phi or MRPC strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def tof_id_to_phi_or_strip(\n    tof_digi_id: IntLike,\n    part: Union[IntLike, None] = None,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the TOF digi ID to the scintillator phi or MRPC strip number, based on the part number.\n    If `part &lt; 3`, it is scintillator and the return value is phi number. Otherwise, it is\n    MRPC and the return value is strip number.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n        part: The part number. If not provided, it will be calculated based on the TOF digi ID.\n\n    Returns:\n        The scintillator phi or MRPC strip number.\n    \"\"\"\n    if part is None:\n        return _tof_id_to_phi_or_strip_1(tof_digi_id)\n    else:\n        return _tof_id_to_phi_or_strip_2(tof_digi_id, part)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_end","title":"<code>tof_id_to_end(tof_digi_id)</code>","text":"<p>Convert the TOF digi ID to the readout end number.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The readout end number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef tof_id_to_end(\n    tof_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the TOF digi ID to the readout end number.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n\n    Returns:\n        The readout end number.\n    \"\"\"\n    return tof_digi_id % 2\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_tof_digi_id","title":"<code>get_tof_digi_id(part, layer_or_module, phi_or_strip, end)</code>","text":"<p>Generate TOF scintillator ID based on the part number, layer number, phi number, and readout end number.</p> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>IntLike</code> <p>The part number.</p> required <code>layer_or_module</code> <code>IntLike</code> <p>The scintillator layer or MRPC module number.</p> required <code>phi_or_strip</code> <code>IntLike</code> <p>The scintillator phi or MRPC strip number.</p> required <code>end</code> <code>IntLike</code> <p>The readout end number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The TOF digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint32(nb.int_, nb.int_, nb.int_, nb.int_)])\ndef get_tof_digi_id(\n    part: IntLike,\n    layer_or_module: IntLike,\n    phi_or_strip: IntLike,\n    end: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate TOF scintillator ID based on the part number, layer number, phi number, and readout end number.\n\n    Parameters:\n        part: The part number.\n        layer_or_module: The scintillator layer or MRPC module number.\n        phi_or_strip: The scintillator phi or MRPC strip number.\n        end: The readout end number.\n\n    Returns:\n        The TOF digi ID.\n    \"\"\"\n    if part &lt; 3:\n        return (\n            ((part &lt;&lt; DIGI_TOF_PART_OFFSET) &amp; DIGI_TOF_PART_MASK)\n            | ((layer_or_module &lt;&lt; DIGI_TOF_SCINT_LAYER_OFFSET) &amp; DIGI_TOF_SCINT_LAYER_MASK)\n            | ((phi_or_strip &lt;&lt; DIGI_TOF_SCINT_PHI_OFFSET) &amp; DIGI_TOF_SCINT_PHI_MASK)\n            | ((end &lt;&lt; DIGI_TOF_END_OFFSET) &amp; DIGI_TOF_END_MASK)\n            | (DIGI_TOF_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n        )\n    else:\n        return (\n            ((3 &lt;&lt; DIGI_TOF_PART_OFFSET) &amp; DIGI_TOF_PART_MASK)\n            | (((part - 3) &lt;&lt; DIGI_TOF_MRPC_ENDCAP_OFFSET) &amp; DIGI_TOF_MRPC_ENDCAP_MASK)\n            | ((layer_or_module &lt;&lt; DIGI_TOF_MRPC_MODULE_OFFSET) &amp; DIGI_TOF_MRPC_MODULE_MASK)\n            | ((phi_or_strip &lt;&lt; DIGI_TOF_MRPC_STRIP_OFFSET) &amp; DIGI_TOF_MRPC_STRIP_MASK)\n            | ((end &lt;&lt; DIGI_TOF_END_OFFSET) &amp; DIGI_TOF_END_MASK)\n            | (DIGI_TOF_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n        )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_emc_id","title":"<code>check_emc_id(emc_digi_id)</code>","text":"<p>Check if the EMC digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef check_emc_id(\n    emc_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Check if the EMC digi ID is valid.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (emc_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_EMC_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.emc_id_to_module","title":"<code>emc_id_to_module(emc_digi_id)</code>","text":"<p>Convert EMC digi ID to module number</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The module number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef emc_id_to_module(\n    emc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert EMC digi ID to module number\n\n    Parameters:\n        emc_digi_id: EMC digi ID array or value.\n\n    Returns:\n        The module number.\n    \"\"\"\n    return (emc_digi_id &amp; DIGI_EMC_MODULE_MASK) &gt;&gt; DIGI_EMC_MODULE_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.emc_id_to_theta","title":"<code>emc_id_to_theta(emc_digi_id)</code>","text":"<p>Convert the EMC digi ID to the theta number.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The theta number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef emc_id_to_theta(\n    emc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the EMC digi ID to the theta number.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID array or value.\n\n    Returns:\n        The theta number.\n    \"\"\"\n    return (emc_digi_id &amp; DIGI_EMC_THETA_MASK) &gt;&gt; DIGI_EMC_THETA_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.emc_id_to_phi","title":"<code>emc_id_to_phi(emc_digi_id)</code>","text":"<p>Convert the EMC digi ID to the phi number.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The phi number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef emc_id_to_phi(\n    emc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the EMC digi ID to the phi number.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID array or value.\n\n    Returns:\n        The phi number.\n    \"\"\"\n    return (emc_digi_id &amp; DIGI_EMC_PHI_MASK) &gt;&gt; DIGI_EMC_PHI_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_emc_digi_id","title":"<code>get_emc_digi_id(module, theta, phi)</code>","text":"<p>Generate EMC digi ID based on the module number, theta number, and phi number.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>IntLike</code> <p>The module number.</p> required <code>theta</code> <code>IntLike</code> <p>The theta number.</p> required <code>phi</code> <code>IntLike</code> <p>The phi number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The EMC digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint32(nb.int_, nb.int_, nb.int_)])\ndef get_emc_digi_id(\n    module: IntLike,\n    theta: IntLike,\n    phi: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate EMC digi ID based on the module number, theta number, and phi number.\n\n    Parameters:\n        module: The module number.\n        theta: The theta number.\n        phi: The phi number.\n\n    Returns:\n        The EMC digi ID.\n    \"\"\"\n    return (\n        ((module &lt;&lt; DIGI_EMC_MODULE_OFFSET) &amp; DIGI_EMC_MODULE_MASK)\n        | ((theta &lt;&lt; DIGI_EMC_THETA_OFFSET) &amp; DIGI_EMC_THETA_MASK)\n        | ((phi &lt;&lt; DIGI_EMC_PHI_OFFSET) &amp; DIGI_EMC_PHI_MASK)\n        | (DIGI_EMC_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_muc_id","title":"<code>check_muc_id(muc_digi_id)</code>","text":"<p>Check if the MUC digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef check_muc_id(\n    muc_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Check if the MUC digi ID is valid.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (muc_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_MUC_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_part","title":"<code>muc_id_to_part(muc_digi_id)</code>","text":"<p>Convert MUC digi ID to part number</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The part number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef muc_id_to_part(\n    muc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert MUC digi ID to part number\n\n    Parameters:\n        muc_digi_id: MUC digi ID array or value.\n\n    Returns:\n        The part number.\n    \"\"\"\n    return (muc_digi_id &amp; DIGI_MUC_PART_MASK) &gt;&gt; DIGI_MUC_PART_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_segment","title":"<code>muc_id_to_segment(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the segment number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The segment number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef muc_id_to_segment(\n    muc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the segment number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The segment number.\n    \"\"\"\n    return (muc_digi_id &amp; DIGI_MUC_SEGMENT_MASK) &gt;&gt; DIGI_MUC_SEGMENT_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_layer","title":"<code>muc_id_to_layer(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the layer number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef muc_id_to_layer(\n    muc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the layer number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The layer number.\n    \"\"\"\n    return (muc_digi_id &amp; DIGI_MUC_LAYER_MASK) &gt;&gt; DIGI_MUC_LAYER_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_strip","title":"<code>muc_id_to_strip(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the strip number, which is equivalent to channel number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def muc_id_to_strip(\n    muc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The strip number.\n    \"\"\"\n    return muc_id_to_channel(muc_digi_id)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_gap","title":"<code>muc_id_to_gap(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the gap ID, which is equivalent to layer number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The gap ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def muc_id_to_gap(\n    muc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the gap ID, which is equivalent to layer number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The gap ID.\n    \"\"\"\n    return muc_id_to_layer(muc_digi_id)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_strip","title":"<code>muc_id_to_strip(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the strip number, which is equivalent to channel number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def muc_id_to_strip(\n    muc_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The strip number.\n    \"\"\"\n    return muc_id_to_channel(muc_digi_id)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_muc_digi_id","title":"<code>get_muc_digi_id(part, segment, layer, channel)</code>","text":"<p>Generate MUC digi ID based on the part number, segment number, layer number, and channel number.</p> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>IntLike</code> <p>The part number.</p> required <code>segment</code> <code>IntLike</code> <p>The segment number.</p> required <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>channel</code> <code>IntLike</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The MUC digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint32(nb.int_, nb.int_, nb.int_, nb.int_)])\ndef get_muc_digi_id(\n    part: IntLike,\n    segment: IntLike,\n    layer: IntLike,\n    channel: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate MUC digi ID based on the part number, segment number, layer number, and channel number.\n\n    Parameters:\n        part: The part number.\n        segment: The segment number.\n        layer: The layer number.\n        channel: The channel number.\n\n    Returns:\n        The MUC digi ID.\n    \"\"\"\n    return (\n        ((part &lt;&lt; DIGI_MUC_PART_OFFSET) &amp; DIGI_MUC_PART_MASK)\n        | ((segment &lt;&lt; DIGI_MUC_SEGMENT_OFFSET) &amp; DIGI_MUC_SEGMENT_MASK)\n        | ((layer &lt;&lt; DIGI_MUC_LAYER_OFFSET) &amp; DIGI_MUC_LAYER_MASK)\n        | ((channel &lt;&lt; DIGI_MUC_CHANNEL_OFFSET) &amp; DIGI_MUC_CHANNEL_MASK)\n        | (DIGI_MUC_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_cgem_id","title":"<code>check_cgem_id(cgem_digi_id)</code>","text":"<p>Check if the CGEM digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef check_cgem_id(\n    cgem_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Check if the CGEM digi ID is valid.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (cgem_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_CGEM_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_layer","title":"<code>cgem_id_to_layer(cgem_digi_id)</code>","text":"<p>Convert the CGEM digi ID to the layer number.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef cgem_id_to_layer(\n    cgem_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the CGEM digi ID to the layer number.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        The layer number.\n    \"\"\"\n    return (cgem_digi_id &amp; DIGI_CGEM_LAYER_MASK) &gt;&gt; DIGI_CGEM_LAYER_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_sheet","title":"<code>cgem_id_to_sheet(cgem_digi_id)</code>","text":"<p>Convert the CGEM digi ID to the sheet number.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The sheet number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint8(nb.int_)])\ndef cgem_id_to_sheet(\n    cgem_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the CGEM digi ID to the sheet number.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        The sheet number.\n    \"\"\"\n    return (cgem_digi_id &amp; DIGI_CGEM_SHEET_MASK) &gt;&gt; DIGI_CGEM_SHEET_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_strip","title":"<code>cgem_id_to_strip(cgem_digi_id)</code>","text":"<p>Convert CGEM digi ID to strip number</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint16(nb.int_)])\ndef cgem_id_to_strip(\n    cgem_digi_id: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Convert CGEM digi ID to strip number\n\n    Parameters:\n        cgem_digi_id: CGEM digi ID array or value.\n\n    Returns:\n        The strip number.\n    \"\"\"\n    return (cgem_digi_id &amp; DIGI_CGEM_STRIP_MASK) &gt;&gt; DIGI_CGEM_STRIP_OFFSET\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_is_x_strip","title":"<code>cgem_id_to_is_x_strip(cgem_digi_id)</code>","text":"<p>Convert the CGEM digi ID to whether it is an X-strip.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the strip is an X-strip</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.boolean(nb.int_)])\ndef cgem_id_to_is_x_strip(\n    cgem_digi_id: IntLike,\n) -&gt; BoolLike:\n    \"\"\"\n    Convert the CGEM digi ID to whether it is an X-strip.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        Whether the strip is an X-strip\n    \"\"\"\n    return (\n        (cgem_digi_id &amp; DIGI_CGEM_STRIPTYPE_MASK) &gt;&gt; DIGI_CGEM_STRIPTYPE_OFFSET\n    ) == DIGI_CGEM_XSTRIP\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_cgem_digi_id","title":"<code>get_cgem_digi_id(layer, sheet, strip, is_x_strip)</code>","text":"<p>Generate CGEM digi ID based on the strip number, strip type, sheet number, and layer number.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>sheet</code> <code>IntLike</code> <p>The sheet number.</p> required <code>strip</code> <code>IntLike</code> <p>The strip number.</p> required <code>is_x_strip</code> <code>BoolLike</code> <p>Whether the strip is an X-strip.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The CGEM digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize([nb.uint32(nb.int_, nb.int_, nb.int_, nb.boolean)])\ndef get_cgem_digi_id(\n    layer: IntLike,\n    sheet: IntLike,\n    strip: IntLike,\n    is_x_strip: BoolLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate CGEM digi ID based on the strip number, strip type, sheet number, and layer number.\n\n    Parameters:\n        layer: The layer number.\n        sheet: The sheet number.\n        strip: The strip number.\n        is_x_strip: Whether the strip is an X-strip.\n\n    Returns:\n        The CGEM digi ID.\n    \"\"\"\n    return (\n        ((strip &lt;&lt; DIGI_CGEM_STRIP_OFFSET) &amp; DIGI_CGEM_STRIP_MASK)\n        | ((~is_x_strip &lt;&lt; DIGI_CGEM_STRIPTYPE_OFFSET) &amp; DIGI_CGEM_STRIPTYPE_MASK)\n        | ((sheet &lt;&lt; DIGI_CGEM_SHEET_OFFSET) &amp; DIGI_CGEM_SHEET_MASK)\n        | ((layer &lt;&lt; DIGI_CGEM_LAYER_OFFSET) &amp; DIGI_CGEM_LAYER_MASK)\n        | (DIGI_CGEM_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3/","title":"pybes3","text":""},{"location":"api/pybes3/#besio","title":"besio","text":""},{"location":"api/pybes3/#pybes3.wrap_uproot","title":"<code>wrap_uproot()</code>","text":"<p>Wraps the uproot functions to use the BES interpretation.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot():\n    \"\"\"\n    Wraps the uproot functions to use the BES interpretation.\n    \"\"\"\n    wrap_uproot_interpretation()\n    wrap_uproot_TBranchElement_branches()\n</code></pre>"},{"location":"api/pybes3/#pybes3.open","title":"<code>open(file, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.open</code> that automatically calls <code>wrap_uproot</code> before opening the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | IO | dict[str | Path | IO, str]</code> <p>The file to open.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.open</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The uproot file object.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open(file, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.open` that automatically calls `wrap_uproot` before opening the file.\n\n    Parameters:\n        file (str | Path | IO | dict[str | Path | IO, str]): The file to open.\n        **kwargs (dict): Additional arguments to pass to `uproot.open`.\n\n    Returns:\n        The uproot file object.\n    \"\"\"\n    wrap_uproot()\n    return uproot.open(file, **kwargs)\n</code></pre>"},{"location":"api/pybes3/#pybes3.concatenate","title":"<code>concatenate(files, branch, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.concatenate</code> that automatically calls <code>wrap_uproot</code> before concatenating the files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str | Path | IO, str]</code> <p>The files to concatenate.</p> required <code>branch</code> <code>str</code> <p>The branch to concatenate.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.concatenate</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The concatenated array.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def concatenate(files, branch: str, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.concatenate` that automatically calls `wrap_uproot` before concatenating the files.\n\n    Parameters:\n        files (list[str | Path | IO, str]): The files to concatenate.\n        branch (str): The branch to concatenate.\n        **kwargs (dict): Additional arguments to pass to `uproot.concatenate`.\n\n    Returns:\n        The concatenated array.\n    \"\"\"\n    wrap_uproot()\n    return uproot.concatenate({str(f): branch for f in files}, **kwargs)\n</code></pre>"},{"location":"api/pybes3/#pybes3.open_raw","title":"<code>open_raw(file)</code>","text":"<p>Open a raw binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The file to open.</p> required <p>Returns:</p> Type Description <code>RawBinaryReader</code> <p>The raw binary reader.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open_raw(file: str) -&gt; RawBinaryReader:\n    \"\"\"\n    Open a raw binary file.\n\n    Parameters:\n        file (str): The file to open.\n\n    Returns:\n        (RawBinaryReader): The raw binary reader.\n    \"\"\"\n    return RawBinaryReader(file)\n</code></pre>"},{"location":"api/pybes3/#pybes3.concatenate_raw","title":"<code>concatenate_raw(files, n_block_per_batch=10000, sub_detectors=None, max_workers=None, verbose=False)</code>","text":"<p>Concatenate multiple raw binary files into <code>ak.Array</code></p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[Union[str, Path], list[Union[str, Path]]]</code> <p>files to be read.</p> required <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>10000</code> <code>sub_detectors</code> <code>Union[list[str], None]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Union[int, None]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Show reading process.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>Concatenated raw data array.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def concatenate(\n    files: Union[Union[str, Path], list[Union[str, Path]]],\n    n_block_per_batch: int = 10000,\n    sub_detectors: Union[list[str], None] = None,\n    max_workers: Union[int, None] = None,\n    verbose: bool = False,\n) -&gt; ak.Array:\n    \"\"\"\n    Concatenate multiple raw binary files into `ak.Array`\n\n    Parameters:\n        files (Union[Union[str, Path], list[Union[str, Path]]]): files to be read.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Union[list[str], None], optional): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Union[int, None], optional): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n        verbose (bool): Show reading process.\n\n    Returns:\n        Concatenated raw data array.\n    \"\"\"\n\n    if not isinstance(files, list):\n        files = glob.glob(files)\n\n    files = [str(Path(file).resolve()) for file in files if _is_raw(file)]\n\n    if len(files) == 0:\n        raise ValueError(\"No valid raw files found\")\n\n    res = []\n    for i, f in enumerate(files):\n        if verbose:\n            print(f\"\\rreading file {i+1}/{len(files)} ...\", end=\"\")\n\n        res.append(\n            RawBinaryReader(f).arrays(-1, n_block_per_batch, sub_detectors, max_workers)\n        )\n\n    if verbose:\n        print()\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3/#detectors","title":"detectors","text":""},{"location":"api/pybes3/#pybes3.parse_cgem_digi_id","title":"<code>parse_cgem_digi_id(cgem_digi_id, flat=False, library='ak')</code>","text":"<p>Parse CGEM digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>layer</code>: The layer number.</li> <li><code>sheet</code>: The sheet ID.</li> <li><code>strip</code>: The strip ID.</li> <li><code>is_x_strip</code>: Whether the strip is an X-strip.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed CGEM digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_cgem_digi_id(\n    cgem_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse CGEM digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `layer`: The layer number.\n    - `sheet`: The sheet ID.\n    - `strip`: The strip ID.\n    - `is_x_strip`: Whether the strip is an X-strip.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed CGEM digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(cgem_digi_id, ak.Array):\n        cgem_digi_id = ak.flatten(cgem_digi_id)\n\n    res = {\n        \"layer\": digi_id.cgem_id_to_layer(cgem_digi_id),\n        \"sheet\": digi_id.cgem_id_to_sheet(cgem_digi_id),\n        \"strip\": digi_id.cgem_id_to_strip(cgem_digi_id),\n        \"is_x_strip\": digi_id.cgem_id_to_is_x_strip(cgem_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_mdc_gid","title":"<code>parse_mdc_gid(gid, with_pos=True)</code>","text":"<p>Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795. When <code>gid</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>layer</code>: Layer number.</li> <li><code>wire</code>: Local wire number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_gid(gid: IntLike, with_pos: bool = True) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795.\n    When `gid` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `layer`: Layer number.\n    - `wire`: Local wire number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        gid: The gid of the wire.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    layer = mdc_gid_to_layer(gid)\n    wire = mdc_gid_to_wire(gid)\n\n    res = {\n        \"gid\": gid,\n        \"layer\": layer,\n        \"wire\": wire,\n        \"stereo\": mdc_gid_to_stereo(gid),\n        \"is_stereo\": mdc_gid_to_is_stereo(gid),\n        \"superlayer\": mdc_gid_to_superlayer(gid),\n    }\n\n    if with_pos:\n        west_x = mdc_gid_to_west_x(gid)\n        west_y = mdc_gid_to_west_y(gid)\n        east_x = mdc_gid_to_east_x(gid)\n        east_y = mdc_gid_to_east_y(gid)\n        res[\"mid_x\"] = (west_x + east_x) / 2\n        res[\"mid_y\"] = (west_y + east_y) / 2\n        res[\"west_x\"] = west_x\n        res[\"west_y\"] = west_y\n        res[\"west_z\"] = mdc_gid_to_west_z(gid)\n        res[\"east_x\"] = east_x\n        res[\"east_y\"] = east_y\n        res[\"east_z\"] = mdc_gid_to_east_z(gid)\n\n    if isinstance(gid, ak.Array):\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_mdc_digi","title":"<code>parse_mdc_digi(mdc_digi, with_pos=False)</code>","text":"<p>Parse MDC raw digi array. The raw digi array should contain [<code>m_intId</code>, <code>m_timeChannel</code>, <code>m_chargeChannel</code>, <code>m_trackIndex</code>, <code>m_overflow</code>] fields.</p> <p>Fields of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>wire</code>: Local wire number.</li> <li><code>layer</code>: Layer number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> <li><code>charge_channel</code>: Charge channel.</li> <li><code>time_channel</code>: Time channel.</li> <li><code>track_index</code>: Track index.</li> <li><code>overflow</code>: Overflow flag.</li> <li><code>digi_id</code>: Raw digi ID.</li> </ul> <p>Optional fields of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mdc_digi</code> <code>Record</code> <p>The MDC raw digi array.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Record</code> <p>The parsed MDC digi array.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_digi(mdc_digi: ak.Record, with_pos: bool = False) -&gt; ak.Record:\n    \"\"\"\n    Parse MDC raw digi array. The raw digi array should contain [`m_intId`,\n    `m_timeChannel`, `m_chargeChannel`, `m_trackIndex`, `m_overflow`] fields.\n\n    Fields of the output:\n\n    - `gid`: Global ID of the wire.\n    - `wire`: Local wire number.\n    - `layer`: Layer number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n    - `charge_channel`: Charge channel.\n    - `time_channel`: Time channel.\n    - `track_index`: Track index.\n    - `overflow`: Overflow flag.\n    - `digi_id`: Raw digi ID.\n\n    Optional fields of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        mdc_digi: The MDC raw digi array.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed MDC digi array.\n    \"\"\"\n    gid = parse_mdc_digi_id(mdc_digi[\"m_intId\"], with_pos=with_pos)\n\n    res = {\n        \"gid\": gid[\"gid\"],\n        \"wire\": gid[\"wire\"],\n        \"layer\": gid[\"layer\"],\n        \"stereo\": gid[\"stereo\"],\n        \"is_stereo\": gid[\"is_stereo\"],\n        \"superlayer\": gid[\"superlayer\"],\n        \"charge_channel\": mdc_digi[\"m_chargeChannel\"],\n        \"time_channel\": mdc_digi[\"m_timeChannel\"],\n        \"track_index\": mdc_digi[\"m_trackIndex\"],\n        \"overflow\": mdc_digi[\"m_overflow\"],\n        \"digi_id\": mdc_digi[\"m_intId\"],\n    }\n\n    if with_pos:\n        res[\"mid_x\"] = gid[\"mid_x\"]\n        res[\"mid_y\"] = gid[\"mid_y\"]\n        res[\"west_x\"] = gid[\"west_x\"]\n        res[\"west_y\"] = gid[\"west_y\"]\n        res[\"west_z\"] = gid[\"west_z\"]\n        res[\"east_x\"] = gid[\"east_x\"]\n        res[\"east_y\"] = gid[\"east_y\"]\n        res[\"east_z\"] = gid[\"east_z\"]\n\n    return ak.zip(res)\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_mdc_digi_id","title":"<code>parse_mdc_digi_id(mdc_digi_id, with_pos=False)</code>","text":"<p>Parse MDC digi ID.</p> <p>When <code>mdc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>wire</code>: Local wire number.</li> <li><code>layer</code>: Layer number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_digi_id(\n    mdc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse MDC digi ID.\n\n    When `mdc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `wire`: Local wire number.\n    - `layer`: Layer number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    wire = digi_id.mdc_id_to_wire(mdc_digi_id)\n    layer = digi_id.mdc_id_to_layer(mdc_digi_id)\n    gid = get_mdc_gid(layer, wire)\n    return parse_mdc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_tof_digi_id","title":"<code>parse_tof_digi_id(tof_digi_id, flat=False, library='ak')</code>","text":"<p>Parse TOF digi ID. If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number. <code>0,1,2</code> for scintillator endcap0, barrel, endcap1; <code>3,4</code> for MRPC endcap0, endcap1.</li> <li><code>layer_or_module</code>: The scintillator layer or MRPC module number, based on the part number.</li> <li><code>phi_or_strip</code>: The scintillator phi or MRPC strip ID, based on the part number.</li> <li><code>end</code>: The readout end ID.</li> </ul> <p>The return value is based on the part number.</p> <p>Rows where <code>part &lt; 3</code> are scintillator and <code>layer_or_module</code> represents layer number, <code>phi_or_strip</code> represents phi number.</p> <p>Rows where <code>part &gt;= 3</code> are MRPC and <code>layer_or_module</code> represents module number, <code>phi_or_strip</code> represents strip ID.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed TOF ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_tof_digi_id(\n    tof_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse TOF digi ID.\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number. `0,1,2` for scintillator endcap0, barrel, endcap1; `3,4` for MRPC endcap0, endcap1.\n    - `layer_or_module`: The scintillator layer or MRPC module number, based on the part number.\n    - `phi_or_strip`: The scintillator phi or MRPC strip ID, based on the part number.\n    - `end`: The readout end ID.\n\n    The return value is based on the part number.\n\n    Rows where `part &lt; 3` are scintillator and `layer_or_module` represents layer number, `phi_or_strip` represents phi number.\n\n    Rows where `part &gt;= 3` are MRPC and `layer_or_module` represents module number, `phi_or_strip` represents strip ID.\n\n    Parameters:\n        tof_digi_id: The TOF ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed TOF ID.\n\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(tof_digi_id, ak.Array):\n        tof_digi_id = ak.flatten(tof_digi_id)\n\n    part = digi_id.tof_id_to_part(tof_digi_id)\n    res = {\n        \"part\": part,\n        \"layer_or_module\": digi_id.tof_id_to_layer_or_module(tof_digi_id, part),\n        \"phi_or_strip\": digi_id.tof_id_to_phi_or_strip(tof_digi_id, part),\n        \"end\": digi_id.tof_id_to_end(tof_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_emc_digi_id","title":"<code>parse_emc_digi_id(emc_digi_id, with_pos=False)</code>","text":"<p>Parse EMC digi ID.</p> <p>When <code>emc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the crystal.</li> <li><code>part</code>: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.</li> <li><code>theta</code>: Theta number.</li> <li><code>phi</code>: Phi number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>front_center_x</code>: x position of the front center of the crystal.</li> <li><code>front_center_y</code>: y position of the front center of the crystal.</li> <li><code>front_center_z</code>: z position of the front center of the crystal.</li> <li><code>center_x</code>: x position of the center of the crystal.</li> <li><code>center_y</code>: y position of the center of the crystal.</li> <li><code>center_z</code>: z position of the center of the crystal.</li> </ul> <p>Info</p> <p>The 8 points of the crystal will not be returned here. If you need the 8 points of the crystal, use <code>emc_gid_to_point_x</code>, <code>emc_gid_to_point_y</code> and <code>emc_gid_to_point_z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed EMC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_emc_digi_id(\n    emc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse EMC digi ID.\n\n    When `emc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the crystal.\n    - `part`: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.\n    - `theta`: Theta number.\n    - `phi`: Phi number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `front_center_x`: x position of the front center of the crystal.\n    - `front_center_y`: y position of the front center of the crystal.\n    - `front_center_z`: z position of the front center of the crystal.\n    - `center_x`: x position of the center of the crystal.\n    - `center_y`: y position of the center of the crystal.\n    - `center_z`: z position of the center of the crystal.\n\n    !!! info\n        The 8 points of the crystal will not be returned here.\n        If you need the 8 points of the crystal, use `emc_gid_to_point_x`, `emc_gid_to_point_y`\n        and `emc_gid_to_point_z`.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed EMC digi ID.\n\n    \"\"\"\n    part = digi_id.emc_id_to_module(emc_digi_id)\n    theta = digi_id.emc_id_to_theta(emc_digi_id)\n    phi = digi_id.emc_id_to_phi(emc_digi_id)\n    gid = get_emc_gid(part, theta, phi)\n    return parse_emc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_muc_digi_id","title":"<code>parse_muc_digi_id(muc_digi_id, flat=False, library='ak')</code>","text":"<p>Parse MUC digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number.</li> <li><code>segment</code>: The segment number.</li> <li><code>layer</code>: The layer number.</li> <li><code>channel</code>: The channel number.</li> <li><code>gap</code>: The gap number, which is equivalent to layer number.</li> <li><code>strip</code>: The strip number, which is equivalent to channel number.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed MUC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_muc_digi_id(\n    muc_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse MUC digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number.\n    - `segment`: The segment number.\n    - `layer`: The layer number.\n    - `channel`: The channel number.\n    - `gap`: The gap number, which is equivalent to layer number.\n    - `strip`: The strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed MUC digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(muc_digi_id, ak.Array):\n        muc_digi_id = ak.flatten(muc_digi_id)\n\n    part = digi_id.muc_id_to_part(muc_digi_id)\n    segment = digi_id.muc_id_to_segment(muc_digi_id)\n    layer = digi_id.muc_id_to_layer(muc_digi_id)\n    channel = digi_id.muc_id_to_channel(muc_digi_id)\n\n    res = {\n        \"part\": part,\n        \"segment\": segment,\n        \"layer\": layer,\n        \"channel\": channel,\n        \"gap\": layer,\n        \"strip\": channel,\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#tracks","title":"tracks","text":""},{"location":"api/pybes3/#pybes3.parse_helix","title":"<code>parse_helix(helix, library='auto')</code>","text":"<p>Parse helix parameters to physical parameters.</p> <p>Parameters:</p> Name Type Description Default <code>helix</code> <code>Union[Array, ndarray]</code> <p>helix parameters, the last dimension should be 5.</p> required <code>library</code> <code>Literal['ak', 'auto']</code> <p>the library to use, if \"auto\", return a dict when input is np.ndarray,             return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Union[Array, dict[str, ndarray]]</code> <p>parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position,             \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum,             \"charge\" for charge, \"r_trk\" for track radius.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>def parse_helix(\n    helix: Union[ak.Array, np.ndarray], library: Literal[\"ak\", \"auto\"] = \"auto\"\n) -&gt; Union[ak.Array, dict[str, np.ndarray]]:\n    \"\"\"\n    Parse helix parameters to physical parameters.\n\n    Parameters:\n        helix: helix parameters, the last dimension should be 5.\n        library: the library to use, if \"auto\", return a dict when input is np.ndarray, \\\n            return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.\n\n    Returns:\n        parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position, \\\n            \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum, \\\n            \"charge\" for charge, \"r_trk\" for track radius.\n    \"\"\"\n    helix0 = helix[..., 0]\n    helix1 = helix[..., 1]\n    helix2 = helix[..., 2]\n    helix3 = helix[..., 3]\n    helix4 = helix[..., 4]\n\n    x = _helix01_to_x(helix0, helix1)\n    y = _helix01_to_y(helix0, helix1)\n    z = helix3\n    r = np.abs(helix0)\n\n    pt = _helix2_to_pt(helix2)\n    px = _pt_helix1_to_px(pt, helix1)\n    py = _pt_helix1_to_py(pt, helix1)\n    pz = pt * helix4\n    p = _pt_helix4_to_p(pt, helix4)\n    theta = _pz_p_to_theta(pz, p)\n    phi = np.atan2(py, px)\n\n    charge = _helix2_to_charge(helix2)\n\n    r_trk = pt * (10 / 2.99792458)  # |pt| * [GeV/c] / 1[e] / 1[T] = |pt| * 10/3 [m]\n    r_trk = r_trk * 100  # to [cm]\n\n    res_dict = {\n        \"x\": x,\n        \"y\": y,\n        \"z\": z,\n        \"r\": r,\n        \"px\": px,\n        \"py\": py,\n        \"pz\": pz,\n        \"pt\": pt,\n        \"p\": p,\n        \"theta\": theta,\n        \"phi\": phi,\n        \"charge\": charge,\n        \"r_trk\": r_trk,\n    }\n\n    if isinstance(helix, ak.Array) or library == \"ak\":\n        return ak.zip(res_dict)\n    else:\n        return res_dict\n</code></pre>"},{"location":"api/pybes3.tracks/","title":"pybes3.tracks","text":""},{"location":"api/pybes3.tracks/#helix-parsing","title":"Helix parsing","text":""},{"location":"api/pybes3.tracks/#pybes3.tracks.parse_helix","title":"<code>parse_helix(helix, library='auto')</code>","text":"<p>Parse helix parameters to physical parameters.</p> <p>Parameters:</p> Name Type Description Default <code>helix</code> <code>Union[Array, ndarray]</code> <p>helix parameters, the last dimension should be 5.</p> required <code>library</code> <code>Literal['ak', 'auto']</code> <p>the library to use, if \"auto\", return a dict when input is np.ndarray,             return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Union[Array, dict[str, ndarray]]</code> <p>parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position,             \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum,             \"charge\" for charge, \"r_trk\" for track radius.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>def parse_helix(\n    helix: Union[ak.Array, np.ndarray], library: Literal[\"ak\", \"auto\"] = \"auto\"\n) -&gt; Union[ak.Array, dict[str, np.ndarray]]:\n    \"\"\"\n    Parse helix parameters to physical parameters.\n\n    Parameters:\n        helix: helix parameters, the last dimension should be 5.\n        library: the library to use, if \"auto\", return a dict when input is np.ndarray, \\\n            return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.\n\n    Returns:\n        parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position, \\\n            \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum, \\\n            \"charge\" for charge, \"r_trk\" for track radius.\n    \"\"\"\n    helix0 = helix[..., 0]\n    helix1 = helix[..., 1]\n    helix2 = helix[..., 2]\n    helix3 = helix[..., 3]\n    helix4 = helix[..., 4]\n\n    x = _helix01_to_x(helix0, helix1)\n    y = _helix01_to_y(helix0, helix1)\n    z = helix3\n    r = np.abs(helix0)\n\n    pt = _helix2_to_pt(helix2)\n    px = _pt_helix1_to_px(pt, helix1)\n    py = _pt_helix1_to_py(pt, helix1)\n    pz = pt * helix4\n    p = _pt_helix4_to_p(pt, helix4)\n    theta = _pz_p_to_theta(pz, p)\n    phi = np.atan2(py, px)\n\n    charge = _helix2_to_charge(helix2)\n\n    r_trk = pt * (10 / 2.99792458)  # |pt| * [GeV/c] / 1[e] / 1[T] = |pt| * 10/3 [m]\n    r_trk = r_trk * 100  # to [cm]\n\n    res_dict = {\n        \"x\": x,\n        \"y\": y,\n        \"z\": z,\n        \"r\": r,\n        \"px\": px,\n        \"py\": py,\n        \"pz\": pz,\n        \"pt\": pt,\n        \"p\": p,\n        \"theta\": theta,\n        \"phi\": phi,\n        \"charge\": charge,\n        \"r_trk\": r_trk,\n    }\n\n    if isinstance(helix, ak.Array) or library == \"ak\":\n        return ak.zip(res_dict)\n    else:\n        return res_dict\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._helix01_to_x","title":"<code>_helix01_to_x(helix0, helix1)</code>","text":"<p>Convert helix parameters to x location.</p> <p>Parameters:</p> Name Type Description Default <code>helix0</code> <code>FloatLike</code> <p>helix[0] parameter, dr.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>x location of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.float64(nb.float64, nb.float64)])\ndef _helix01_to_x(helix0: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameters to x location.\n\n    Parameters:\n        helix0: helix[0] parameter, dr.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        x location of the helix.\n    \"\"\"\n    return helix0 * np.cos(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._helix01_to_y","title":"<code>_helix01_to_y(helix0, helix1)</code>","text":"<p>Convert helix parameters to y location.</p> <p>Parameters:</p> Name Type Description Default <code>helix0</code> <code>FloatLike</code> <p>helix[0] parameter, dr.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>y location of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.float64(nb.float64, nb.float64)])\ndef _helix01_to_y(helix0: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameters to y location.\n\n    Parameters:\n        helix0: helix[0] parameter, dr.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        y location of the helix.\n    \"\"\"\n    return helix0 * np.sin(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._helix2_to_pt","title":"<code>_helix2_to_pt(helix2)</code>","text":"<p>Convert helix parameter to pt.</p> <p>Parameters:</p> Name Type Description Default <code>helix2</code> <code>FloatLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>pt of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.float64(nb.float64)])\ndef _helix2_to_pt(\n    helix2: FloatLike,\n) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter to pt.\n\n    Parameters:\n        helix2: helix[2] parameter, kappa.\n\n    Returns:\n        pt of the helix.\n    \"\"\"\n    return 1 / np.abs(helix2)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._helix2_to_charge","title":"<code>_helix2_to_charge(helix2)</code>","text":"<p>Convert helix parameter to charge.</p> <p>Parameters:</p> Name Type Description Default <code>helix2</code> <code>FloatLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>charge of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.int8(nb.float64)])\ndef _helix2_to_charge(\n    helix2: FloatLike,\n) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter to charge.\n\n    Parameters:\n        helix2: helix[2] parameter, kappa.\n\n    Returns:\n        charge of the helix.\n    \"\"\"\n    if -1e-10 &lt; helix2 &lt; 1e-10:\n        return 0\n    return 1 if helix2 &gt; 0 else -1\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._pt_helix1_to_px","title":"<code>_pt_helix1_to_px(pt, helix1)</code>","text":"<p>Convert pt and helix1 to px.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>FloatLike</code> <p>pt of the helix.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>px of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.float64(nb.float64, nb.float64)])\ndef _pt_helix1_to_px(pt: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert pt and helix1 to px.\n\n    Parameters:\n        pt: pt of the helix.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        px of the helix.\n    \"\"\"\n    return -pt * np.sin(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._pt_helix1_to_py","title":"<code>_pt_helix1_to_py(pt, helix1)</code>","text":"<p>Convert pt and helix1 to py.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>FloatLike</code> <p>pt of the helix.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>py of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.float64(nb.float64, nb.float64)])\ndef _pt_helix1_to_py(pt: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert pt and helix1 to py.\n\n    Parameters:\n        pt: pt of the helix.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        py of the helix.\n    \"\"\"\n    return pt * np.cos(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks._pt_helix4_to_p","title":"<code>_pt_helix4_to_p(pt, helix4)</code>","text":"<p>Convert pt and helix4 to p.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>FloatLike</code> <p>pt of the helix.</p> required <code>helix4</code> <code>FloatLike</code> <p>helix[4] parameter, tanl.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>p of the helix.</p> Source code in <code>src/pybes3/tracks.py</code> <pre><code>@nb.vectorize([nb.float64(nb.float64, nb.float64)])\ndef _pt_helix4_to_p(pt: FloatLike, helix4: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert pt and helix4 to p.\n\n    Parameters:\n        pt: pt of the helix.\n        helix4: helix[4] parameter, tanl.\n\n    Returns:\n        p of the helix.\n    \"\"\"\n    return pt * np.sqrt(1 + helix4**2)\n</code></pre>"},{"location":"user-manual/bes3-data-reading/","title":"BES3 Data Reading","text":""},{"location":"user-manual/bes3-data-reading/#read-root-file-rtraw-dst-rec","title":"Read ROOT file (rtraw, dst, rec)","text":"<p>To make <code>uproot</code> know about BES3 ROOT files,  call <code>pybes3.wrap_uproot()</code> before opening any file:</p> <pre><code>&gt;&gt;&gt; import uproot\n&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; p3.wrap_uproot()\n</code></pre> <p>Then, open file as using <code>uproot</code>:</p> <pre><code>&gt;&gt;&gt; f = uproot.open(\"test.rtraw\")\n&gt;&gt;&gt; evt = f[\"Event\"]\n</code></pre> <p>There is a shorthand:</p> <pre><code>&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; f = p3.open(\"test.rtraw\") # will automatically call `pybes3.wrap_uproot()`\n&gt;&gt;&gt; evt = f[\"Event\"]\n</code></pre> <p>Print information about this \"event\" tree:</p> <pre><code>&gt;&gt;&gt; evt.show(name_width=40)\nname                                     | typename                 | interpretation                \n-----------------------------------------+--------------------------+-------------------------------\nTEvtHeader                               | TEvtHeader               | AsGroup(&lt;TBranchElement 'TE...\nTEvtHeader/m_eventId                     | int32_t                  | AsDtype('&gt;i4')\nTEvtHeader/m_runId                       | int32_t                  | AsDtype('&gt;i4')\n...\nTMcEvent                                 | TMcEvent                 | AsGroup(&lt;TBranchElement 'TM...\nTMcEvent/m_mdcMcHitCol                   | BES::TObjArray&lt;TMdcMc&gt;   | BES::As(BES::TObjArray&lt;TMdc...\nTMcEvent/m_emcMcHitCol                   | BES::TObjArray&lt;TEmcMc&gt;   | BES::As(BES::TObjArray&lt;TEmc...\nTMcEvent/m_tofMcHitCol                   | BES::TObjArray&lt;TTofMc&gt;   | BES::As(BES::TObjArray&lt;TTof...\nTMcEvent/m_mucMcHitCol                   | BES::TObjArray&lt;TMucMc&gt;   | BES::As(BES::TObjArray&lt;TMuc...\nTMcEvent/m_mcParticleCol                 | BES::TObjArray&lt;TMcPar... | BES::As(BES::TObjArray&lt;TMcP...\nTDigiEvent                               | TDigiEvent               | AsGroup(&lt;TBranchElement 'TD...\nTDigiEvent/m_fromMc                      | bool                     | AsDtype('bool')\n...\n</code></pre> <p>To read <code>TMcEvent</code> (Note: use <code>arrays()</code> instead of <code>array()</code> here):</p> <pre><code>&gt;&gt;&gt; mc_evt = evt[\"TMcEvent\"].arrays()\n&gt;&gt;&gt; mc_evt.fields\n['m_mdcMcHitCol', 'm_emcMcHitCol', 'm_tofMcHitCol', 'm_mucMcHitCol', 'm_mcParticleCol']\n</code></pre> <p>Now go to event 0:</p> <pre><code>&gt;&gt;&gt; evt0 = mc_evt[0]\n&gt;&gt;&gt; evt0.m_mcParticleCol.m_particleID\n&lt;Array [23, 4, -4, 91, 443, 11, ..., 111, 211, -211, 22, 22] type='12 * int32'&gt;\n\n&gt;&gt;&gt; mc_evt[0].m_mcParticleCol.m_eInitialMomentum\n&lt;Array [3.1, 1.55, 1.55, 3.1, ..., 1.23, 0.178, 1.28] type='12 * float64'&gt;\n</code></pre> <p>This indicates that in event 0, there are 12 MC particles. Their PDGIDs are <code>23, 4, -3, ...</code> and initial energies are <code>3.1, 1.55, 1.55, ... (GeV)</code>.</p> <p>It is recommended that only read the branches you need, otherwise your memory may overflow. </p> <p>To read a specific branch (Note: use <code>array()</code> instead of <code>arrays()</code> here):</p> <pre><code>&gt;&gt;&gt; pdgid_arr = evt[\"TMcEvent/m_mcParticleCol/m_particleID\"].array()\n&gt;&gt;&gt; e_init_arr = evt[\"TMcEvent/m_mcParticleCol/m_eInitialMomentum\"].array()\n</code></pre> <p>or you can retrieve branches from <code>mc_evt</code>:</p> <pre><code>&gt;&gt;&gt; pdgid_arr = mc_evt[\"m_mcParticleCol/m_particleID\"].array()\n&gt;&gt;&gt; e_init_arr = mc_evt[\"m_mcParticleCol/m_eInitialMomentum\"].array()\n</code></pre>"},{"location":"user-manual/bes3-data-reading/#read-raw-data-file","title":"Read raw data file","text":"<p>BES3 raw data files contain only digits information. To read a raw data file, use <code>pybes3.open_raw</code>:</p> <pre><code>&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; reader = p3.open_raw(\"/bes3fs/offline/data/raw/round17/231117/run_0079017_All_file001_SFO-1.raw\")\n&gt;&gt;&gt; reader\nBesRawReader\n- File: /bes3fs/offline/data/raw/round17/231117/run_0079017_All_file001_SFO-1.raw\n- Run Number: 79017\n- Entries: 100112\n- File Size: 2010 MB\n</code></pre> <p>To read all data out:</p> <pre><code>&gt;&gt;&gt; all_digi = reader.arrays()\n&gt;&gt;&gt; all_digi\n&lt;Array [{evt_header: {...}, ...}, ..., {...}] type='100112 * {evt_header: {...'&gt;\n&gt;&gt;&gt; all_digi.fields\n['evt_header', 'mdc', 'tof', 'emc', 'muc']\n&gt;&gt;&gt; all_digi.mdc.fields\n['id', 'adc', 'tdc', 'overflow']\n</code></pre> <p>To only read some sub-detectors:</p> <pre><code>&gt;&gt;&gt; mdc_tof_digi = reader.arrays(sub_detectors=['mdc', 'tof']) # 'emc', 'muc' are also available\n&gt;&gt;&gt; mdc_tof_digi.fields\n['evt_header', 'mdc', 'tof']\n</code></pre> <p>To read part of file:</p> <pre><code>&gt;&gt;&gt; some_digi = reader.arrays(n_blocks=1000)\n&gt;&gt;&gt; some_digi\n&lt;Array [{evt_header: {...}, ...}, ..., {...}] type='1000 * {evt_header: {ev...'&gt;\n</code></pre> <p>Info</p> <p><code>n_blocks</code> instead of <code>n_entries</code> is used here because only data blocks are continuous in memory. Most of the time, there is one event in a data block.</p> <p>Warning</p> <p>By so far, <code>besio</code> can only read original raw data without any decoding. Read raw data with decoding is under development.</p>"},{"location":"user-manual/digi-identifier/","title":"Digi Identifier","text":"<p>When reading <code>TDigiEvent</code>, the <code>m_intId</code> field in <code>mdc</code>, <code>tof</code>, <code>emc</code>, <code>muc</code>, <code>cgem</code> branches are the electronics readout id (TEID), also known as <code>Identifier</code> in <code>BOSS</code>. <code>pybes3</code> provides methods to parse and calculate the digi ID for each detector.</p>"},{"location":"user-manual/digi-identifier/#digi-array-parsing","title":"Digi array parsing","text":"<p>Info</p> <p>By so far, only MDC and EMC digi parsing is supported. Whole digi parsing for other detectors is still under development. If you need to parse digi ID for other detectors, use the standalone digi ID parsing methods.</p> <pre><code>import pybes3 as p3\n\n# read raw digi array\nmdc_digi = p3.open(\"test.rtraw\")[\"Event/TDigiEvent/m_mdcDigiCol\"].array()\n\n# parse whole digi array\nmdc_digi = p3.parse_mdc_digi(mdc_digi)\n</code></pre>"},{"location":"user-manual/digi-identifier/#standalone-digi-id-parsing","title":"Standalone digi-ID parsing","text":"<p>When parsing whole digi array is not necesarry/supported, use <code>parse_xxx_digi_id</code> methods where <code>xxx</code> is the detector name (<code>cgem</code>, <code>mdc</code>, <code>tof</code>, <code>emc</code>, <code>muc</code>) to parse only the digi ID:</p> <pre><code># read raw digi array\ntof_digi = p3.open(\"test.rtraw\")[\"Event/TDigiEvent/m_tofDigiCol\"].array()\nemc_digi = p3.open(\"test.rtraw\")[\"Event/TDigiEvent/m_emcDigiCol\"].array()\n\n# parse digi ID\ntof_digi_id = p3.parse_tof_digi_id(tof_digi[\"m_intId\"])\nemc_digi_id = p3.parse_emc_digi_id(emc_digi[\"m_intId\"])\n</code></pre> <p>Info</p> <p>As the development of <code>pybes3.detectors.geometry</code>, the <code>parse_xxx_digi_id</code> methods will be updated to return more fields.</p>"},{"location":"user-manual/digi-identifier/#convert-digi-id-to-specific-field","title":"Convert digi ID to specific field","text":"<pre><code>import pybes3.detectors.digi_id as digi_id\n\n# get TOF part number\ntof_part = digi_id.tof_id_to_part(tof_digi[\"m_intId\"])\n\n# get EMC theta number\nemc_theta = digi_id.emc_id_to_theta(emc_digi[\"m_intId\"])\n</code></pre> <p>See Digi Identify API for all available methods.</p>"},{"location":"user-manual/digi-identifier/#digi-id-calculation","title":"Digi-ID calculation","text":"<p>To calculate <code>m_intId</code> of digis, use <code>get_xxx_digi_id</code> methods where <code>xxx</code> is the detector name (<code>cgem</code>, <code>mdc</code>, <code>tof</code>, <code>emc</code>, <code>muc</code>):</p> <pre><code>import pybes3.detectors as p3det\n\n# get TOF digi geometry numbers\npart = tof_digi_id[\"part\"]\nlayer_or_module = tof_digi_id[\"layer_or_module\"]\nphi_or_strip = tof_digi_id[\"phi_or_strip\"]\nend = tof_digi_id[\"end\"]\n\n# calculate TOF digi ID\ntof_digi_id = p3det.get_tof_digi_id(part, layer_or_module, phi_or_strip, end)\n</code></pre> <p>Info</p> <p><code>pybes3</code> uses different convention for TOF <code>part</code> number:</p> <ul> <li><code>0,1,2</code> for scintillator endcap0, barrel, endcap1</li> <li><code>3,4</code> for MRPC endcap0, endcap1.</li> </ul> <p>In this case, TOF ID information can be decoded to 4 fields: <code>part</code>, <code>layer_or_module</code>, <code>phi_or_strip</code>, <code>end</code>.</p>"},{"location":"user-manual/tracks/","title":"Tracks","text":""},{"location":"user-manual/tracks/#helix","title":"Helix","text":"<p>In BESIII, helix is represented by 5 parameters: <code>dr</code>, <code>phi0</code>, <code>kappa</code>, <code>dz</code>, <code>tanl</code>. To transform these parameters to <code>x</code>, <code>y</code>, <code>z</code>, <code>px</code>, <code>py</code>, <code>pz</code>, etc., use <code>pybes3.parse_helix</code>:</p> <pre><code>&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; mdc_trk = p3.open(\"test.dst\")[\"Event/TDstEvent/m_mdcTrackCol\"].array()\n&gt;&gt;&gt; helix = mdc_trk[\"m_helix\"]\n&gt;&gt;&gt; helix\n&lt;Array [[[0.0342, 0.736, ..., 0.676], ...], ...] type='10 * var * 5 * float64'&gt;\n\n&gt;&gt;&gt; phy_helix = p3.parse_helix(helix)\n&gt;&gt;&gt; phy_helix.fields\n['x', 'y', 'z', 'r', 'px', 'py', 'pz', 'pt', 'p', 'theta', 'phi', 'charge', 'r_trk']\n</code></pre> <p>Tip</p> <p>You can use <code>parse_helix</code> to decode any helix array with 5 elements in the last dimension, such as <code>m_mdcKalTrackCol[\"m_zhelix\"]</code>, <code>m_mdcKalTrackCol[\"m_zhelix_e\"]</code>, etc.</p> <p>The formulas to transform helix parameters to physical parameters are:</p> <ul> <li> <p>position:</p> <ul> <li>\\(x = dr \\times \\cos \\varphi_0\\)</li> <li>\\(y = dr \\times \\sin \\varphi_0\\)</li> <li>\\(z = dz\\)</li> <li>\\(r = \\left| dr \\right|\\)</li> </ul> </li> <li> <p>momentum:</p> <ul> <li>\\(p_t = \\frac{1}{\\left| \\kappa \\right|}\\)</li> <li>\\(p_x = p_t \\times \\sin(- \\varphi_0)\\)</li> <li>\\(p_y = p_t \\times \\cos(- \\varphi_0)\\)</li> <li>\\(p_z = p_t \\times \\tan\\lambda\\)</li> <li>\\(p = p_t \\times \\sqrt{1 + \\tan^2\\lambda}\\)</li> <li>\\(\\theta = \\arccos\\left(\\frac{p_z}{p}\\right)\\)</li> <li>\\(\\varphi = \\arctan2(p_y, p_x)\\)</li> </ul> </li> <li> <p>others:</p> <ul> <li>\\(\\mathrm{charge} = \\mathrm{sign}(\\kappa)\\)</li> <li>\\(r_{\\mathrm{trk}} =\\left| \\frac{p_t}{qB} \\right| = \\left| \\frac{p_t~[\\mathrm{GeV}/c]}{1 e \\times 1 \\mathrm{T}} \\right|\\)</li> </ul> </li> </ul> <p>Where <code>r_trk</code> is the radius of curvature of the track, and the magnetic field equals to <code>1T</code> in BESIII.</p>"},{"location":"user-manual/detector/geometry/","title":"Geometry","text":"<p><code>pybes3</code> provides a set of methods to retrieve theoretical geometry information of detectors.</p> <p>The unit of length is <code>cm</code>.</p>"},{"location":"user-manual/detector/geometry/#mdc","title":"MDC","text":""},{"location":"user-manual/detector/geometry/#gid-conversion","title":"GID conversion","text":"<pre><code>import numpy as np\nimport pybes3 as p3\n\n# generate random wire gid\ngid = np.random.randint(0, 6796, 100)\n\n# get layer, wire, stereo, is_stereo\nlayer = p3.mdc_gid_to_layer(gid)\nwire = p3.mdc_gid_to_wire(gid)\nstereo = p3.mdc_gid_to_stereo(gid)\nis_stereo = p3.mdc_gid_to_is_stereo(gid)\nsuperlayer = p3.mdc_gid_to_superlayer(gid)\n\n# is_stereo can also be obtained by layer\nis_stereo = p3.mdc_layer_to_is_stereo(layer)\n\n# superlayer can also be obtained by layer\nsuperlayer = p3.mdc_layer_to_superlayer(layer)\n\n# get gid\ngid = p3.get_mdc_gid(layer, wire)\n</code></pre> <p>Note</p> <p><code>mdc_gid_to_stereo</code> returns the stereo type of the wire, which can be <code>0</code> (axial), <code>-1</code> for <code>west_phi &lt; east_phi</code> and <code>1</code> for <code>west_phi &gt; east_phi</code>.</p>"},{"location":"user-manual/detector/geometry/#wires-position","title":"Wires position","text":"<p>To get west/east x, y, z of wires:</p> <pre><code># get west x, y, z\nwest_x = p3.mdc_gid_to_west_x(gid)\nwest_y = p3.mdc_gid_to_west_y(gid)\nwest_z = p3.mdc_gid_to_west_z(gid)\n\n# get east x, y, z\neast_x = p3.mdc_gid_to_east_x(gid)\neast_y = p3.mdc_gid_to_east_y(gid)\neast_z = p3.mdc_gid_to_east_z(gid)\n</code></pre> <p>To get x, y of wires at a specific z:</p> <pre><code># get x, y of wire 0 at z = -1, 0, 1 cm\nz = np.array([-1, 0, 1])\nx = p3.mdc_gid_z_to_x(0, z)\ny = p3.mdc_gid_z_to_y(0, z)\n\n# get x, y of wires at z = 10 cm\nx_z10 = p3.mdc_gid_z_to_x(gid, 10)\ny_z10 = p3.mdc_gid_z_to_y(gid, 10)\n</code></pre> <p>You can get the whole wires position table of MDC:</p> <pre><code># get table in `dict[str, np.ndarray]`\nwire_position_np = p3.get_mdc_wire_position() \n\n# get table in `ak.Array`\nwire_position_ak = p3.get_mdc_wire_position(library=\"ak\")\n\n# get table in `pd.DataFrame`\nwire_position_pd = p3.get_mdc_wire_position(library=\"pd\")\n</code></pre>"},{"location":"user-manual/detector/geometry/#emc","title":"EMC","text":""},{"location":"user-manual/detector/geometry/#gid-conversion_1","title":"GID conversion","text":"<pre><code>import numpy as np\nimport pybes3 as p3\n\n# generate random crystal gid\ngid = np.random.randint(0, 6240, 100)\n\n# get part, theta, phi\npart = p3.emc_gid_to_part(gid)\ntheta = p3.emc_gid_to_theta(gid)\nphi = p3.emc_gid_to_phi(gid)\n\n# get gid\ngid = p3.get_emc_gid(part, theta, phi)\n</code></pre>"},{"location":"user-manual/detector/geometry/#crystals-position","title":"Crystals position","text":"<p>To get front center, center x, y, z of crystals:</p> <pre><code># get front center x, y, z\nfront_center_x = p3.emc_gid_to_front_center_x(gid)\nfront_center_y = p3.emc_gid_to_front_center_y(gid)\nfront_center_z = p3.emc_gid_to_front_center_z(gid)\n\n# get center x, y, z\ncenter_x = p3.emc_gid_to_center_x(gid)\ncenter_y = p3.emc_gid_to_center_y(gid)\ncenter_z = p3.emc_gid_to_center_z(gid)\n</code></pre> <p>There are total 8 points on a crystal, you can get x, y, z of these points:</p> <pre><code># get x, y, z of point-0 of crystals\nx0 = p3.emc_gid_to_point_x(gid, 0)\ny0 = p3.emc_gid_to_point_y(gid, 0)\nz0 = p3.emc_gid_to_point_z(gid, 0)\n\n# get x, y, z of point-7 of crystals\nx7 = p3.emc_gid_to_point_x(gid, 7)\ny7 = p3.emc_gid_to_point_y(gid, 7)\nz7 = p3.emc_gid_to_point_z(gid, 7)\n\n# get x, y, z of all 8 points of crystal 0\npoint_id = np.arange(8)\nx = p3.emc_gid_to_point_x(0, point_id)\ny = p3.emc_gid_to_point_y(0, point_id)\nz = p3.emc_gid_to_point_z(0, point_id)\n</code></pre> <p>You can get the whole crystals position table of EMC:</p> <pre><code># get table in `dict[str, np.ndarray]`\ncrystal_position_np = p3.get_emc_crystal_position()\n\n# get table in `ak.Array`\ncrystal_position_ak = p3.get_emc_crystal_position(library=\"ak\")\n\n# get table in `pd.DataFrame`\ncrystal_position_pd = p3.get_emc_crystal_position(library=\"pd\")\n</code></pre>"},{"location":"user-manual/detector/geometry/#barrel-geometry","title":"Barrel geometry","text":"<p>Some geometry constants of EMC barrel can be obtained:</p> <pre><code>p3.emc_barrel_h1\np3.emc_barrel_h2\np3.emc_barrel_h3\np3.emc_barrel_l\np3.emc_barrel_r\np3.emc_barrel_offset_1\np3.emc_barrel_offset_2\n</code></pre> <p>These constants are exported from <code>EmcRecGeoSvc</code> in <code>BOSS</code>.</p>"},{"location":"user-manual/detector/global-id/","title":"Global ID (gid)","text":"<p>Info</p> <p>This page only illustrates the gid of each detector element. To convert gid to other information, please refer to Geometry.</p> <p>To better locate each detector element, a global ID (gid) is defined. GID always starts from 0 and increases along the detector elements. The increasing order is described by a tuple-like structure.</p> <p>For example, MDC gid can be described as <code>(layer, wire)</code>, which means it increases first along the <code>wire</code> and then along the <code>layer</code>, as shown below:</p> layer wire gid 0 0 0 0 1 1 0 ... ... 1 0 40 1 1 41 ... ... ... <p>There are 40 wires on layer-0 in MDC.</p>"},{"location":"user-manual/detector/global-id/#mdc","title":"MDC","text":"Range Increasing Order 0~6795 (layer, wire) <p>Same as BOSS</p> <p>MDC gid is same as those given by <code>MdcGeomSvc</code> in <code>BOSS</code></p>"},{"location":"user-manual/detector/global-id/#tof","title":"TOF","text":"Range Increasing Order Part 0~95 (strip, end) Scint Endcap 0 96~447 (layer, phi, end) Scint Barrel 448~543 (phi, end) Scint Endcap 1 544~1407 (module, strip, end) MRPC Endcap 0 1408~2271 (module, strip, end) MRPC Endcap 1"},{"location":"user-manual/detector/global-id/#emc","title":"EMC","text":"Range Increasing Order Part 0~479 (theta, phi) Endcap 0 480~5759 (theta, phi) Barrel 5760~6239 (-theta, phi) Endcap 1 <p>The concrete relationship between gid and <code>(theta, phi)</code> for EMC endcap 0 is:</p> Range Number of Crystals Theta Description 0~63 64 0 Innermost layer 64~127 64 1 128~207 80 2 208~287 80 3 288~383 96 4 384~479 96 5 Outermost layer <p>The concrete relationship between gid and <code>(theta, phi)</code> for EMC endcap 1 is:</p> Range Number of Crystals Theta Description 5760~5855 96 5 Outermost layer 5856~5951 96 4 5952~6031 80 3 6032~6111 80 2 6112~6175 64 1 6176~6239 64 0 Innermost layer <p>Same as BOSS</p> <p>EMC gid is same as those given by <code>EmcCalibSvc</code> in <code>BOSS</code></p>"},{"location":"user-manual/detector/global-id/#muc","title":"MUC","text":"<p>Under development</p>"},{"location":"user-manual/detector/global-id/#cgem","title":"CGEM","text":"<p>Under development</p>"}]}