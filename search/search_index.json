{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for pybes3","text":"<p><code>pybes3</code> is an unofficial python module that aims to make BES3 user easier to work with Python.</p> <p>Help us improve <code>pybes3</code>!</p> <p>If you have any suggestions, questions, or issues, please feel free to open an issue.</p> <p>See Also</p> <p>It is highly recommended to take a look at these Python modules before using <code>pybes3</code>:</p> <ul> <li><code>awkward</code>: A Python module that can handle ragged-like array.</li> <li><code>uproot</code>: A ROOT I/O Python module. <code>pybes3</code> uses <code>uproot</code> to read BES3 ROOT files.</li> </ul> <ul> <li> <p> Install <code>pybes3</code> using <code>pip</code> </p> </li> <li> <p> Get started with user manual   </p> </li> </ul>"},{"location":"#user-manual","title":"User manual","text":"<ul> <li> <p> BES3 data reading <p>Read <code>rtraw</code>, <code>rec</code>, <code>dst</code>, and even <code>raw</code> files.   </p> <ul> <li> <p> Digi identifier <p>Convert digi identifier id number to a human-readable format.   </p> <ul> <li> <p> Global ID <p>Global ID numbers for each detector element in <code>pybes3</code>.   </p> <ul> <li> <p> Geometry <p>Retrieve and compute geometry information of detectors.   </p> <ul> <li> <p> Helix operations <p>Parse and transform helix parameters.   </p>"},{"location":"#performance","title":"Performance","text":"<p><code>pybes3</code> is designed to be fast and efficient. It uses <code>numba</code> to accelerate some of the operations, such as helix operations, digi identifier conversion, etc. When <code>numba</code> is not available, <code>pybes3</code> will use C++ to accelerate the operations.</p>"},{"location":"#data-reading","title":"Data reading","text":"<p>A simple benchmark is provided to compare the performance of <code>pybes3</code> and <code>BOSS8</code> in reading <code>dst</code> files:</p> <ul> <li> <p>For <code>pybes3</code>, we directly read out the <code>Event</code> tree:</p> <pre><code>import uproot\nimport pybes3\npybes3.wrap_uproot()\n\nn_evt = ... # number of events to read\nfiles = [...] # list of ROOT files to read\n\ndata_array = uproot.concatenate({f: \"Event\" for f in files}, entry_stop=n_evt)\n</code></pre> </li> <li> <p>For <code>BOSS8</code>, since when reading reconstruction data, it will load a <code>RecMakerAlg</code> algorithm for each event, which slows down the reading performance significantly (4~5 times slower than pure reading), we test 2 cases:</p> <ul> <li> <p>A loop on all events with default job-options (with <code>RecMakerAlg</code> algorithm):</p> <pre><code>#include \"$ROOTIOROOT/share/jobOptions_ReadRec.txt\"\n#include \"$OFFLINEEVENTLOOPMGRROOT/share/OfflineEventLoopMgr_Option.txt\"\n\nEventCnvSvc.digiRootInputFile = { ... }; // list of ROOT files to read\nApplicationMgr.EvtMax = ...; // number of events to read\nMessageSvc.OutputLevel = 7; // suppress messages\n</code></pre> </li> <li> <p>A loop on all events without loading <code>RecMakerAlg</code> algorithm. This is similar to reading <code>rtraw</code> files and is the closest case to raw <code>ROOT</code> reading:</p> <pre><code>ApplicationMgr.ExtSvc += {\"EvtPersistencySvc/EventPersistencySvc\"};\nApplicationMgr.ExtSvc +={\"RootEvtSelector/EventSelector\",\"RootCnvSvc/EventCnvSvc\"};\nEventPersistencySvc.CnvServices += {\"EventCnvSvc\"};\n#include \"$OFFLINEEVENTLOOPMGRROOT/share/OfflineEventLoopMgr_Option.txt\"\n\nEventCnvSvc.digiRootInputFile = { ... }; // list of ROOT files to read\nApplicationMgr.EvtMax = ...; // number of events to read\nMessageSvc.OutputLevel = 7; // suppress messages\n</code></pre> </li> </ul> </li> </ul> <p>The machine used for the benchmark is a <code>Intel i7-12700</code> with <code>Great Wall GW7000 4TB</code> SSD. The operating system is <code>AlmaLinuxOS9</code> on <code>WSL2</code>. The number of events is set to <code>1000</code>, <code>5000</code>, <code>10000</code>, <code>50000</code>, <code>100000</code>, <code>500000</code>, and <code>1000000</code>.</p> <p>The results are shown below:</p> <p></p> <p>The fitting results with a linear function is:</p> Initialization time (s) Slope (s/10k-event) BOSS8 (with <code>RecMakerAlg</code>) 0.615 2.766 BOSS8 (no <code>RecMakerAlg</code>) 0.451 0.338 pybes3 1.135 0.326 <p>The result shows that <code>pybes3</code> is also comparable to <code>BOSS8</code> when <code>RecMakerAlg</code> is not loaded, which means that the reading performance of <code>pybes3</code> is close to the reading performance of <code>ROOT</code> itself. <code>pybes3</code> is several times faster than <code>BOSS8</code> with default settings, and slower when reading small number of events (~1000), since the module importing and initialization time is counted in the benchmark.</p> <p>Since users may have to use the default settings of <code>BOSS</code> to read reconstruction data, <code>pybes3</code> is still several times faster in this case.</p>"},{"location":"installation/","title":"Installation","text":"<p>Info</p> <p><code>pybes3</code> requires Python 3.9 or higher.</p>"},{"location":"installation/#users-on-lxlogin-server","title":"Users on lxlogin server","text":"<p>\"lxlogin server\" means the login server of computation clusters of IHEP. If you are not using lxlogin server, please skip to Install <code>pybes3</code> using pip.</p> <p>Since there is a quota limitation on user's home directory (<code>~/</code>), you need to create symbolinks for <code>~/.local</code> and <code>~/.cache</code>, which contains pip packages and caches that installed in \"user mode\":</p> <pre><code># Check whether a `.local` directory and `.cache` already exists.\n# If so, move it to somewhere else.\nls -a ~\nmv ~/.local /path/to/somewhere/\nmv ~/.cache /path/to/somewhere\n\n# If no `.local` or `.cache` exists, create them\nmkdir /path/to/somewhere/.local\nmkdir /path/to/somewhere/.cache\n\n# After moving or creating them, link them back to `~`\nln -s /path/to/somewhere/.local ~/.local\nln -s /path/to/somewhere/.cache ~/.cache\n</code></pre>"},{"location":"installation/#install-pybes3-using-pip","title":"Install <code>pybes3</code> using pip","text":"<pre><code>pip install pybes3\n</code></pre>"},{"location":"api/pybes3._cache_numba/","title":"pybes3._cache_numba","text":"<p>Rare Help for Users</p> <p>There is rare help for users in this page. <code>pybes3._cache_numba.md</code> defines internal functions and never exposed to users.</p>"},{"location":"api/pybes3._cache_numba/#pybes3._cache_numba.cache_auto_clear","title":"<code>cache_auto_clear(sources, caches, silent=True, force=False)</code>","text":"<p>Automatically clear the Numba cache if the source files have changed.</p> <p>Due to limitation of numba cache, modification of external files like geometry data will not trigger the cache clearing. This function is designed to trigger the cache clearing when those external files are modified.</p> <p>This function compares the modification times of the source files with the modification times of the cached files. If any source file is newer than the cached files, the numba cache in cache directory will be cleared.</p> <p>Note</p> <p>There is no need to trace <code>*.py</code> files, as numba will automatically clear the cache when the source code is modified.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>Union[Union[Path, str], list[Union[Path, str]]]</code> <p>A glob pattern or a list of glob patterns to match the source files.</p> required <code>caches</code> <code>Union[Union[Path, str], list[Union[Path, str]]]</code> <p>A glob pattern or a list of glob patterns to match the cached files.</p> required <code>silent</code> <code>bool</code> <p>If True, suppresses the output messages.</p> <code>True</code> <code>force</code> <code>bool</code> <p>If True, forces the cache clearing even if the source files are not newer.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of cache files that were removed.</p> Source code in <code>src/pybes3/_cache_numba.py</code> <pre><code>def cache_auto_clear(\n    sources: Union[Union[Path, str], list[Union[Path, str]]],\n    caches: Union[Union[Path, str], list[Union[Path, str]]],\n    silent: bool = True,\n    force: bool = False,\n) -&gt; list[str]:\n    \"\"\"\n    Automatically clear the Numba cache if the source files have changed.\n\n    Due to limitation of numba cache, modification of external files like\n    geometry data will not trigger the cache clearing. This function is\n    designed to trigger the cache clearing when those external files are\n    modified.\n\n    This function compares the modification times of the source files with the\n    modification times of the cached files. If any source file is newer than\n    the cached files, the numba cache in cache directory will be cleared.\n\n    !!! note\n        There is no need to trace `*.py` files, as numba will automatically\n        clear the cache when the source code is modified.\n\n    Args:\n        sources: A glob pattern or a list of glob patterns to match the source files.\n        caches: A glob pattern or a list of glob patterns to match the cached files.\n        silent: If True, suppresses the output messages.\n        force: If True, forces the cache clearing even if the source files are not newer.\n\n    Returns:\n        list[str]: A list of cache files that were removed.\n    \"\"\"\n    # Transform sources and caches to lists of strings\n    sources: list[str] = (\n        glob(str(sources))\n        if isinstance(sources, (Path, str))\n        else sum([glob(str(s)) for s in sources], [])\n    )\n\n    caches: list[str] = (\n        glob(str(caches))\n        if isinstance(caches, (Path, str))\n        else sum([glob(str(c)) for c in caches], [])\n    )\n\n    # Check if sources and caches are empty\n    if not sources:\n        raise ValueError(\"No source files found.\")\n\n    if not caches:\n        return []\n\n    # Compare modification times\n    removed_caches = []\n    failed_removed_caches = []\n\n    src_latest_mtime = max([os.path.getmtime(s) for s in sources if os.path.isfile(s)])\n    cache_earliest_mtime = min([os.path.getmtime(c) for c in caches if os.path.isfile(c)])\n\n    if src_latest_mtime &gt; cache_earliest_mtime or force:\n        # Remove the cache files\n        for c in caches:\n            try:\n                os.remove(c)\n                removed_caches.append(c)\n            except FileNotFoundError:\n                pass\n            except Exception:\n                failed_removed_caches.append(c)\n\n    # Check failure of removing\n    if failed_removed_caches:\n        error_msg = \"Cannot remove cache files:\\n\"\n        for c in failed_removed_caches:\n            error_msg += f\" - {c}\\n\"\n        error_msg += \"This may cause wrong results from corresponding functions. \"\n        error_msg += \"Please check their permissions or remove them manually.\"\n        raise ImportError(error_msg)\n\n    # Print messages if not silent\n    if not silent:\n        if removed_caches:\n            removed_caches_str = \"\\n - \".join(removed_caches)\n            print(f\"Removed cache files: {removed_caches_str}\")\n\n    # Return the list of removed caches\n    return removed_caches\n</code></pre>"},{"location":"api/pybes3._cache_numba/#pybes3._cache_numba.check_numba_cache","title":"<code>check_numba_cache()</code>","text":"<p>Check the cache files and remove them if the source files are newer. This function should be called when the module is imported.</p> <p>When environment variable <code>PYBES3_NUMBA_CACHE_SILENT</code> is set to 1, the function will print out removal messages.</p> Source code in <code>src/pybes3/_cache_numba.py</code> <pre><code>def check_numba_cache():\n    \"\"\"\n    Check the cache files and remove them if the source files are newer.\n    This function should be called when the module is imported.\n\n    When environment variable `PYBES3_NUMBA_CACHE_SILENT` is set to 1,\n    the function will print out removal messages.\n    \"\"\"\n    silent = os.getenv(\"PYBES3_NUMBA_CACHE_SILENT\", \"0\") == \"0\"\n    for src, cache in src_cache_list:\n        cache_auto_clear(\n            sources=src,\n            caches=cache,\n            silent=silent,\n            force=False,\n        )\n</code></pre>"},{"location":"api/pybes3._cache_numba/#pybes3._cache_numba.clear_numba_cache","title":"<code>clear_numba_cache()</code>","text":"<p>Clear the cache files regardless of the source files.</p> <p>When environment variable <code>PYBES3_NUMBA_CACHE_SILENT</code> is set to 1, the function will print out removal messages.</p> Source code in <code>src/pybes3/_cache_numba.py</code> <pre><code>def clear_numba_cache():\n    \"\"\"\n    Clear the cache files regardless of the source files.\n\n    When environment variable `PYBES3_NUMBA_CACHE_SILENT` is set to 1,\n    the function will print out removal messages.\n    \"\"\"\n    silent = os.getenv(\"PYBES3_NUMBA_CACHE_SILENT\", \"0\") == \"0\"\n    for src, cache in src_cache_list:\n        cache_auto_clear(\n            sources=src,\n            caches=cache,\n            silent=silent,\n            force=True,\n        )\n</code></pre>"},{"location":"api/pybes3.besio/","title":"pybes3.besio","text":"<p>Rare Help for Users</p> <p>There is rare help for users in this page. It is recommended to see BESIII Data Reading.</p>"},{"location":"api/pybes3.besio/#pybes3.besio","title":"<code>besio</code>","text":""},{"location":"api/pybes3.besio/#pybes3.besio.concatenate_raw","title":"<code>concatenate_raw(files, n_block_per_batch=10000, sub_detectors=None, max_workers=None, verbose=False)</code>","text":"<p>Concatenate multiple raw binary files into <code>ak.Array</code></p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[Union[str, Path], list[Union[str, Path]]]</code> <p>files to be read.</p> required <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>10000</code> <code>sub_detectors</code> <code>Optional[list[str]]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Optional[int]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Show reading process.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>Concatenated raw data array.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def concatenate(\n    files: Union[Union[str, Path], list[Union[str, Path]]],\n    n_block_per_batch: int = 10000,\n    sub_detectors: Optional[list[str]] = None,\n    max_workers: Optional[int] = None,\n    verbose: bool = False,\n) -&gt; ak.Array:\n    \"\"\"\n    Concatenate multiple raw binary files into `ak.Array`\n\n    Parameters:\n        files (Union[Union[str, Path], list[Union[str, Path]]]): files to be read.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Optional[list[str]]): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Optional[int]): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n        verbose (bool): Show reading process.\n\n    Returns:\n        Concatenated raw data array.\n    \"\"\"\n\n    if not isinstance(files, list):\n        files = glob.glob(files)\n\n    files = [str(Path(file).resolve()) for file in files if _is_raw(file)]\n\n    if len(files) == 0:\n        raise ValueError(\"No valid raw files found\")\n\n    res = []\n    for i, f in enumerate(files):\n        if verbose:\n            print(f\"\\rreading file {i+1}/{len(files)} ...\", end=\"\")\n\n        res.append(\n            RawBinaryReader(f).arrays(-1, n_block_per_batch, sub_detectors, max_workers)\n        )\n\n    if verbose:\n        print()\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.wrap_uproot","title":"<code>wrap_uproot()</code>","text":"<p>Wraps the uproot functions to use the BES interpretation.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot():\n    \"\"\"\n    Wraps the uproot functions to use the BES interpretation.\n    \"\"\"\n    wrap_uproot_interpretation()\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.open","title":"<code>open(file, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.open</code> that automatically calls <code>wrap_uproot</code> before opening the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | IO | dict[str | Path | IO, str]</code> <p>The file to open.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.open</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The uproot file object.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open(file, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.open` that automatically calls `wrap_uproot` before opening the file.\n\n    Parameters:\n        file (str | Path | IO | dict[str | Path | IO, str]): The file to open.\n        **kwargs (dict): Additional arguments to pass to `uproot.open`.\n\n    Returns:\n        The uproot file object.\n    \"\"\"\n    wrap_uproot()\n    return uproot.open(file, **kwargs)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.concatenate","title":"<code>concatenate(files, branch, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.concatenate</code> that automatically calls <code>wrap_uproot</code> before concatenating the files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str | Path | IO, str]</code> <p>The files to concatenate.</p> required <code>branch</code> <code>str</code> <p>The branch to concatenate.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.concatenate</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The concatenated array.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def concatenate(files, branch: str, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.concatenate` that automatically calls `wrap_uproot` before concatenating the files.\n\n    Parameters:\n        files (list[str | Path | IO, str]): The files to concatenate.\n        branch (str): The branch to concatenate.\n        **kwargs (dict): Additional arguments to pass to `uproot.concatenate`.\n\n    Returns:\n        The concatenated array.\n    \"\"\"\n    wrap_uproot()\n    return uproot.concatenate({str(f): branch for f in files}, **kwargs)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.open_raw","title":"<code>open_raw(file)</code>","text":"<p>Open a raw binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The file to open.</p> required <p>Returns:</p> Type Description <code>RawBinaryReader</code> <p>The raw binary reader.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open_raw(file: str) -&gt; RawBinaryReader:\n    \"\"\"\n    Open a raw binary file.\n\n    Parameters:\n        file (str): The file to open.\n\n    Returns:\n        (RawBinaryReader): The raw binary reader.\n    \"\"\"\n    return RawBinaryReader(file)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io","title":"<code>root_io</code>","text":""},{"location":"api/pybes3.besio/#pybes3.besio.root_io.Bes3Interpretation","title":"<code>Bes3Interpretation</code>","text":"<p>               Bases: <code>AsCustom</code></p> <p>Custom interpretation for Bes3 data.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>class Bes3Interpretation(AsCustom):\n    \"\"\"\n    Custom interpretation for Bes3 data.\n    \"\"\"\n\n    target_branches: set[str] = set(bes3_branch2types.keys())\n\n    def __init__(self, branch, context, simplify):\n        super().__init__(branch, context, simplify)\n        self._typename = bes3_branch2types[regularize_object_path(branch.object_path)]\n\n    def basket_array(\n        self,\n        data,\n        byte_offsets,\n        basket,\n        branch,\n        context,\n        cursor_offset,\n        library,\n        interp_options,\n    ):\n        raw_ak_layout = super().basket_array(\n            data,\n            byte_offsets,\n            basket,\n            branch,\n            context,\n            cursor_offset,\n            library,\n            interp_options,\n        )\n        raw_ak_arr = ak.Array(raw_ak_layout)\n\n        # preprocess awkward array and return\n        full_branch_path = regularize_object_path(branch.object_path)\n        return preprocess_subbranch(full_branch_path, raw_ak_arr)\n\n    @property\n    def typename(self) -&gt; str:\n        \"\"\"\n        The typename of the interpretation.\n        \"\"\"\n        return self._typename\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        The string representation of the interpretation.\n        \"\"\"\n        return f\"AsBes3(TObjArray[{self.typename}])\"\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.Bes3Interpretation.typename","title":"<code>typename</code>  <code>property</code>","text":"<p>The typename of the interpretation.</p>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.Bes3Interpretation.__repr__","title":"<code>__repr__()</code>","text":"<p>The string representation of the interpretation.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    The string representation of the interpretation.\n    \"\"\"\n    return f\"AsBes3(TObjArray[{self.typename}])\"\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.process_digi_subbranch","title":"<code>process_digi_subbranch(org_arr)</code>","text":"<p>Processes the <code>TRawData</code> subbranch of the input awkward array and returns a new array with the subbranch fields merged into the top level.</p> <p>Parameters:</p> Name Type Description Default <code>org_arr</code> <code>Array</code> <p>The input awkward array containing the <code>TRawData</code> subbranch.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>A new awkward array with the fields of <code>TRawData</code> merged into the top level.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>TRawData</code> is not found in the input array fields.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def process_digi_subbranch(org_arr: ak.Array) -&gt; ak.Array:\n    \"\"\"\n    Processes the `TRawData` subbranch of the input awkward array and returns a new array with the subbranch fields\n    merged into the top level.\n\n    Parameters:\n        org_arr (ak.Array): The input awkward array containing the `TRawData` subbranch.\n\n    Returns:\n        A new awkward array with the fields of `TRawData` merged into the top level.\n\n    Raises:\n        AssertionError: If `TRawData` is not found in the input array fields.\n    \"\"\"\n    if not org_arr.fields:\n        assert ak.count(org_arr) == 0, \"Input array is empty but has no fields\"\n        return org_arr\n\n    assert \"TRawData\" in org_arr.fields, \"TRawData not found in the input array\"\n\n    fields = {}\n    for field_name in org_arr.fields:\n        if field_name == \"TRawData\":\n            for raw_field_name in org_arr[field_name].fields:\n                fields[raw_field_name] = org_arr[field_name][raw_field_name]\n        else:\n            fields[field_name] = org_arr[field_name]\n\n    return ak.zip(fields)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.root_io.wrap_uproot","title":"<code>wrap_uproot()</code>","text":"<p>Wraps the uproot functions to use the BES interpretation.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot():\n    \"\"\"\n    Wraps the uproot functions to use the BES interpretation.\n    \"\"\"\n    wrap_uproot_interpretation()\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io","title":"<code>raw_io</code>","text":""},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.RawBinaryReader","title":"<code>RawBinaryReader</code>","text":"Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>class RawBinaryReader:\n    def __init__(\n        self,\n        file: str,\n    ):\n        self.file = str(Path(file).resolve())\n        self._file = open(file, \"rb\")\n\n        self.file_version: int = -1\n        self.file_number: int = -1\n        self.file_date: int = -1\n        self.file_time: int = -1\n\n        self.app_name: str = \"None\"\n        self.app_tag: str = \"None\"\n\n        self.run_number: int = -1\n        self.max_events: int = -1\n        self.rec_enable: int = -1\n        self.trigger_type: int = -1\n        self.detector_mask: int = -1\n        self.beam_type: int = -1\n        self.beam_energy: int = -1\n\n        self.entries: int = -1\n\n        self.data_start: int = 0  # in char\n        self.data_end: int = 0  # in char\n        self.file_size: int = 0  # in char\n        self.data_size: int = 0  # in char\n\n        self.event_starts: np.ndarray = np.empty(0, dtype=np.uint32)  # in char\n        self.event_stops: np.ndarray = np.empty(0, dtype=np.uint32)  # in char\n        self.max_event_offset: int = 0\n        self.current_entry: int = -1\n\n        self._preprocess_file()\n\n    def arrays(\n        self,\n        n_blocks: int = -1,\n        n_block_per_batch: int = 1000,\n        sub_detectors: Optional[list[str]] = None,\n        max_workers: Optional[int] = None,\n    ) -&gt; ak.Array:\n        \"\"\"\n        Read and return arrays of data from the BES raw file.\n\n        Parameters:\n            n_blocks (int, optional): The number of blocks to read. Defaults to -1, which means read all blocks.\n            n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n            sub_detectors (Optional[list[str]]): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n            max_workers (Optional[int]): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n\n        Returns:\n            An Awkward Array containing the read data.\n        \"\"\"\n\n        self._reset_cursor()\n\n        if sub_detectors is None:\n            sub_detectors = []\n\n        executor = ThreadPoolExecutor(max_workers=max_workers)\n\n        n_total_blocks_read = 0\n\n        futures: list[Future] = []\n        while n_total_blocks_read &lt; n_blocks or (\n            n_blocks == -1 and self._file.tell() &lt; self.data_end\n        ):\n            n_block_to_read = (\n                min(n_blocks - n_total_blocks_read, n_block_per_batch)\n                if n_blocks != -1\n                else n_block_per_batch\n            )\n\n            batch_data, n_read = self._read_batch(n_block_to_read)\n            futures.append(executor.submit(read_bes_raw, batch_data, sub_detectors))\n            n_total_blocks_read += n_read\n\n        res = []\n        for future in futures:\n            org_dict = future.result()\n            res.append(_raw_dict_to_ak(org_dict))\n\n        return ak.concatenate(res)\n\n    def _read(self) -&gt; int:\n        return int.from_bytes(self._file.read(4), \"little\")\n\n    def _skip(self, n: int = 1) -&gt; None:\n        self._file.seek(4 * n, 1)\n\n    def _preprocess_file(self):\n        # file header\n        assert self._read() == BesFlag.FILE_START, \"Invalid start flag\"\n        self._skip()\n\n        self.file_version = self._read()\n        self.file_number = self._read()\n        self.file_date = self._read()\n        self.file_time = self._read()\n        self._skip(2)\n\n        # file name\n        assert self._read() == BesFlag.FILE_NAME, \"Invalid file name flag\"\n\n        nchar_name = self._read()\n        nbytes_name = np.ceil(nchar_name / 4).astype(int)\n        self.file_name = self._file.read(nbytes_name * 4).decode(\"utf-8\").strip()\n\n        nchar_tag = self._read()\n        nbytes_tag = np.ceil(nchar_tag / 4).astype(int)\n        self.file_tag = self._file.read(nbytes_tag * 4).decode(\"utf-8\").strip()\n\n        # run parameters\n        assert self._read() == BesFlag.RUN_PARAMS, \"Invalid run params flag\"\n        self._skip()\n\n        self.run_number = self._read()\n        self.max_events = self._read()\n        self.rec_enable = self._read()\n        self.trigger_type = self._read()\n        self.detector_mask = self._read()\n        self.beam_type = self._read()\n        self.beam_energy = self._read()\n\n        # other information\n        self.data_start = self._file.tell()\n        self._file.seek(0, 2)\n        self.file_size = self._file.tell()\n        self.data_end = self.file_size - 10 * 4\n        self.data_size = self.data_end - self.data_start\n\n        # read file tail\n        self._file.seek(-10 * 4, 2)\n        assert self._read() == BesFlag.FILE_TAIL_START, \"Invalid file tail start flag\"\n        self._skip(3)\n        self.entries = self._read()\n        self._skip(4)\n        assert self._read() == BesFlag.FILE_END, \"Invalid file end flag\"\n\n        self._reset_cursor()\n\n    def _reset_cursor(self):\n        self._file.seek(self.data_start)\n        self.current_entry = 0\n\n    def _skip_event(self):\n        flag = self._read()\n        if flag == BesFlag.DATA_SEPERATOR:\n            self._skip(3)\n            flag = self._read()\n\n        assert flag == BesFlag.FULL_EVENT_FRAGMENT, \"Invalid event fragment flag\"\n\n        total_size = self._read()\n\n        if self.current_entry &gt; self.max_event_offset:\n            self.event_starts[self.current_entry] = self._file.tell() - 4 * 2\n            self.event_stops[self.current_entry] = (\n                self.event_starts[self.current_entry] + total_size\n            )\n\n        self._skip(total_size - 2)\n        self.current_entry += 1\n\n    def _read_batch(self, n_blocks: int):\n        pos_start = self._file.tell()\n        block_counter = 0\n        for _ in range(n_blocks):\n            if self._file.tell() &gt;= self.data_end:\n                assert self._file.tell() == self.data_end, \"Invalid data end\"\n                break\n\n            assert self._read() == BesFlag.DATA_SEPERATOR, \"Invalid data seperator flag\"\n            self._skip(2)\n            block_size = self._read()\n            self._skip(block_size // 4)\n            block_counter += 1\n\n        pos_end = self._file.tell()\n\n        self._file.seek(pos_start, 0)\n        batch_data = np.frombuffer(self._file.read(pos_end - pos_start), dtype=np.uint32)\n\n        return batch_data, block_counter\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"BesRawReader\\n\"\n            f\"- File: {self.file}\\n\"\n            f\"- Run Number: {self.run_number}\\n\"\n            f\"- Entries: {self.entries}\\n\"\n            f\"- File Size: {self.file_size//1024//1024} MB\\n\"\n        )\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.RawBinaryReader.arrays","title":"<code>arrays(n_blocks=-1, n_block_per_batch=1000, sub_detectors=None, max_workers=None)</code>","text":"<p>Read and return arrays of data from the BES raw file.</p> <p>Parameters:</p> Name Type Description Default <code>n_blocks</code> <code>int</code> <p>The number of blocks to read. Defaults to -1, which means read all blocks.</p> <code>-1</code> <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>1000</code> <code>sub_detectors</code> <code>Optional[list[str]]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Optional[int]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array</code> <p>An Awkward Array containing the read data.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def arrays(\n    self,\n    n_blocks: int = -1,\n    n_block_per_batch: int = 1000,\n    sub_detectors: Optional[list[str]] = None,\n    max_workers: Optional[int] = None,\n) -&gt; ak.Array:\n    \"\"\"\n    Read and return arrays of data from the BES raw file.\n\n    Parameters:\n        n_blocks (int, optional): The number of blocks to read. Defaults to -1, which means read all blocks.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Optional[list[str]]): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Optional[int]): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n\n    Returns:\n        An Awkward Array containing the read data.\n    \"\"\"\n\n    self._reset_cursor()\n\n    if sub_detectors is None:\n        sub_detectors = []\n\n    executor = ThreadPoolExecutor(max_workers=max_workers)\n\n    n_total_blocks_read = 0\n\n    futures: list[Future] = []\n    while n_total_blocks_read &lt; n_blocks or (\n        n_blocks == -1 and self._file.tell() &lt; self.data_end\n    ):\n        n_block_to_read = (\n            min(n_blocks - n_total_blocks_read, n_block_per_batch)\n            if n_blocks != -1\n            else n_block_per_batch\n        )\n\n        batch_data, n_read = self._read_batch(n_block_to_read)\n        futures.append(executor.submit(read_bes_raw, batch_data, sub_detectors))\n        n_total_blocks_read += n_read\n\n    res = []\n    for future in futures:\n        org_dict = future.result()\n        res.append(_raw_dict_to_ak(org_dict))\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3.besio/#pybes3.besio.raw_io.concatenate","title":"<code>concatenate(files, n_block_per_batch=10000, sub_detectors=None, max_workers=None, verbose=False)</code>","text":"<p>Concatenate multiple raw binary files into <code>ak.Array</code></p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[Union[str, Path], list[Union[str, Path]]]</code> <p>files to be read.</p> required <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>10000</code> <code>sub_detectors</code> <code>Optional[list[str]]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Optional[int]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Show reading process.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>Concatenated raw data array.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def concatenate(\n    files: Union[Union[str, Path], list[Union[str, Path]]],\n    n_block_per_batch: int = 10000,\n    sub_detectors: Optional[list[str]] = None,\n    max_workers: Optional[int] = None,\n    verbose: bool = False,\n) -&gt; ak.Array:\n    \"\"\"\n    Concatenate multiple raw binary files into `ak.Array`\n\n    Parameters:\n        files (Union[Union[str, Path], list[Union[str, Path]]]): files to be read.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Optional[list[str]]): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Optional[int]): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n        verbose (bool): Show reading process.\n\n    Returns:\n        Concatenated raw data array.\n    \"\"\"\n\n    if not isinstance(files, list):\n        files = glob.glob(files)\n\n    files = [str(Path(file).resolve()) for file in files if _is_raw(file)]\n\n    if len(files) == 0:\n        raise ValueError(\"No valid raw files found\")\n\n    res = []\n    for i, f in enumerate(files):\n        if verbose:\n            print(f\"\\rreading file {i+1}/{len(files)} ...\", end=\"\")\n\n        res.append(\n            RawBinaryReader(f).arrays(-1, n_block_per_batch, sub_detectors, max_workers)\n        )\n\n    if verbose:\n        print()\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3.detectors/","title":"pybes3.detectors","text":""},{"location":"api/pybes3.detectors/#parsing-methods","title":"Parsing methods","text":""},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_mdc_gid","title":"<code>parse_mdc_gid(gid, with_pos=True)</code>","text":"<p>Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795. When <code>gid</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>layer</code>: Layer number.</li> <li><code>wire</code>: Local wire number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_gid(gid: IntLike, with_pos: bool = True) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795.\n    When `gid` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `layer`: Layer number.\n    - `wire`: Local wire number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        gid: The gid of the wire.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    layer = mdc_gid_to_layer(gid)\n    wire = mdc_gid_to_wire(gid)\n\n    res = {\n        \"gid\": gid,\n        \"layer\": layer,\n        \"wire\": wire,\n        \"stereo\": mdc_gid_to_stereo(gid),\n        \"is_stereo\": mdc_gid_to_is_stereo(gid),\n        \"superlayer\": mdc_gid_to_superlayer(gid),\n    }\n\n    if with_pos:\n        west_x = mdc_gid_to_west_x(gid)\n        west_y = mdc_gid_to_west_y(gid)\n        east_x = mdc_gid_to_east_x(gid)\n        east_y = mdc_gid_to_east_y(gid)\n        res[\"mid_x\"] = (west_x + east_x) / 2\n        res[\"mid_y\"] = (west_y + east_y) / 2\n        res[\"west_x\"] = west_x\n        res[\"west_y\"] = west_y\n        res[\"west_z\"] = mdc_gid_to_west_z(gid)\n        res[\"east_x\"] = east_x\n        res[\"east_y\"] = east_y\n        res[\"east_z\"] = mdc_gid_to_east_z(gid)\n\n    if isinstance(gid, ak.Array):\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_mdc_digi_id","title":"<code>parse_mdc_digi_id(mdc_digi_id, with_pos=False)</code>","text":"<p>Parse MDC digi ID.</p> <p>When <code>mdc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>wire</code>: Local wire number.</li> <li><code>layer</code>: Layer number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_digi_id(\n    mdc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse MDC digi ID.\n\n    When `mdc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `wire`: Local wire number.\n    - `layer`: Layer number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    wire = digi_id.mdc_id_to_wire(mdc_digi_id)\n    layer = digi_id.mdc_id_to_layer(mdc_digi_id)\n    gid = get_mdc_gid(layer, wire)\n    return parse_mdc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_tof_digi_id","title":"<code>parse_tof_digi_id(tof_digi_id, flat=False, library='ak')</code>","text":"<p>Parse TOF digi ID. If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number. <code>0,1,2</code> for scintillator endcap0, barrel, endcap1; <code>3,4</code> for MRPC endcap0, endcap1.</li> <li><code>layer_or_module</code>: The scintillator layer or MRPC module number, based on the part number.</li> <li><code>phi_or_strip</code>: The scintillator phi or MRPC strip ID, based on the part number.</li> <li><code>end</code>: The readout end ID.</li> </ul> <p>The return value is based on the part number.</p> <p>Rows where <code>part &lt; 3</code> are scintillator and <code>layer_or_module</code> represents layer number, <code>phi_or_strip</code> represents phi number.</p> <p>Rows where <code>part &gt;= 3</code> are MRPC and <code>layer_or_module</code> represents module number, <code>phi_or_strip</code> represents strip ID.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed TOF ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_tof_digi_id(\n    tof_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse TOF digi ID.\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number. `0,1,2` for scintillator endcap0, barrel, endcap1; `3,4` for MRPC endcap0, endcap1.\n    - `layer_or_module`: The scintillator layer or MRPC module number, based on the part number.\n    - `phi_or_strip`: The scintillator phi or MRPC strip ID, based on the part number.\n    - `end`: The readout end ID.\n\n    The return value is based on the part number.\n\n    Rows where `part &lt; 3` are scintillator and `layer_or_module` represents layer number, `phi_or_strip` represents phi number.\n\n    Rows where `part &gt;= 3` are MRPC and `layer_or_module` represents module number, `phi_or_strip` represents strip ID.\n\n    Parameters:\n        tof_digi_id: The TOF ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed TOF ID.\n\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(tof_digi_id, ak.Array):\n        tof_digi_id = ak.flatten(tof_digi_id)\n\n    part = digi_id.tof_id_to_part(tof_digi_id)\n    res = {\n        \"part\": part,\n        \"layer_or_module\": digi_id.tof_id_to_layer_or_module(tof_digi_id, part),\n        \"phi_or_strip\": digi_id.tof_id_to_phi_or_strip(tof_digi_id, part),\n        \"end\": digi_id.tof_id_to_end(tof_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_emc_digi_id","title":"<code>parse_emc_digi_id(emc_digi_id, with_pos=False)</code>","text":"<p>Parse EMC digi ID.</p> <p>When <code>emc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the crystal.</li> <li><code>part</code>: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.</li> <li><code>theta</code>: Theta number.</li> <li><code>phi</code>: Phi number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>front_center_x</code>: x position of the front center of the crystal.</li> <li><code>front_center_y</code>: y position of the front center of the crystal.</li> <li><code>front_center_z</code>: z position of the front center of the crystal.</li> <li><code>center_x</code>: x position of the center of the crystal.</li> <li><code>center_y</code>: y position of the center of the crystal.</li> <li><code>center_z</code>: z position of the center of the crystal.</li> </ul> <p>Info</p> <p>The 8 points of the crystal will not be returned here. If you need the 8 points of the crystal, use <code>emc_gid_to_point_x</code>, <code>emc_gid_to_point_y</code> and <code>emc_gid_to_point_z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed EMC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_emc_digi_id(\n    emc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse EMC digi ID.\n\n    When `emc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the crystal.\n    - `part`: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.\n    - `theta`: Theta number.\n    - `phi`: Phi number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `front_center_x`: x position of the front center of the crystal.\n    - `front_center_y`: y position of the front center of the crystal.\n    - `front_center_z`: z position of the front center of the crystal.\n    - `center_x`: x position of the center of the crystal.\n    - `center_y`: y position of the center of the crystal.\n    - `center_z`: z position of the center of the crystal.\n\n    !!! info\n        The 8 points of the crystal will not be returned here.\n        If you need the 8 points of the crystal, use `emc_gid_to_point_x`, `emc_gid_to_point_y`\n        and `emc_gid_to_point_z`.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed EMC digi ID.\n\n    \"\"\"\n    part = digi_id.emc_id_to_module(emc_digi_id)\n    theta = digi_id.emc_id_to_theta(emc_digi_id)\n    phi = digi_id.emc_id_to_phi(emc_digi_id)\n    gid = get_emc_gid(part, theta, phi)\n    return parse_emc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_muc_digi_id","title":"<code>parse_muc_digi_id(muc_digi_id, flat=False, library='ak')</code>","text":"<p>Parse MUC digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number.</li> <li><code>segment</code>: The segment number.</li> <li><code>layer</code>: The layer number.</li> <li><code>channel</code>: The channel number.</li> <li><code>gap</code>: The gap number, which is equivalent to layer number.</li> <li><code>strip</code>: The strip number, which is equivalent to channel number.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed MUC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_muc_digi_id(\n    muc_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse MUC digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number.\n    - `segment`: The segment number.\n    - `layer`: The layer number.\n    - `channel`: The channel number.\n    - `gap`: The gap number, which is equivalent to layer number.\n    - `strip`: The strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed MUC digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(muc_digi_id, ak.Array):\n        muc_digi_id = ak.flatten(muc_digi_id)\n\n    part = digi_id.muc_id_to_part(muc_digi_id)\n    segment = digi_id.muc_id_to_segment(muc_digi_id)\n    layer = digi_id.muc_id_to_layer(muc_digi_id)\n    channel = digi_id.muc_id_to_channel(muc_digi_id)\n\n    res = {\n        \"part\": part,\n        \"segment\": segment,\n        \"layer\": layer,\n        \"channel\": channel,\n        \"gap\": layer,\n        \"strip\": channel,\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.parse_cgem_digi_id","title":"<code>parse_cgem_digi_id(cgem_digi_id, flat=False, library='ak')</code>","text":"<p>Parse CGEM digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>layer</code>: The layer number.</li> <li><code>sheet</code>: The sheet ID.</li> <li><code>strip</code>: The strip ID.</li> <li><code>is_x_strip</code>: Whether the strip is an X-strip.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed CGEM digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_cgem_digi_id(\n    cgem_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse CGEM digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `layer`: The layer number.\n    - `sheet`: The sheet ID.\n    - `strip`: The strip ID.\n    - `is_x_strip`: Whether the strip is an X-strip.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed CGEM digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(cgem_digi_id, ak.Array):\n        cgem_digi_id = ak.flatten(cgem_digi_id)\n\n    res = {\n        \"layer\": digi_id.cgem_id_to_layer(cgem_digi_id),\n        \"sheet\": digi_id.cgem_id_to_sheet(cgem_digi_id),\n        \"strip\": digi_id.cgem_id_to_strip(cgem_digi_id),\n        \"is_x_strip\": digi_id.cgem_id_to_is_x_strip(cgem_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3.detectors/#geometry","title":"Geometry","text":""},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_mdc_wire_position","title":"<code>get_mdc_wire_position(library='np')</code>","text":"<p>Get the MDC wire position table.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>Literal['np', 'ak', 'pd']</code> <p>The library to return the data in. Choose from 'ak', 'np', 'pd'.</p> <code>'np'</code> <p>Returns:</p> Type Description <code>Array | dict[str, ndarray] | DataFrame</code> <p>The MDC wire position table.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the library is not 'ak', 'np', or 'pd'.</p> <code>ImportError</code> <p>If the library is 'pd' but pandas is not installed.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>def get_mdc_wire_position(library: Literal[\"np\", \"ak\", \"pd\"] = \"np\"):\n    \"\"\"\n    Get the MDC wire position table.\n\n    Parameters:\n        library: The library to return the data in. Choose from 'ak', 'np', 'pd'.\n\n    Returns:\n        (ak.Array | dict[str, np.ndarray] | pd.DataFrame): The MDC wire position table.\n\n    Raises:\n        ValueError: If the library is not 'ak', 'np', or 'pd'.\n        ImportError: If the library is 'pd' but pandas is not installed.\n    \"\"\"\n    cp: dict[str, np.ndarray] = {k: v.copy() for k, v in _mdc_wire_position.items()}\n\n    if library == \"ak\":\n        return ak.Array(cp)\n    elif library == \"np\":\n        return cp\n    elif library == \"pd\":\n        try:\n            import pandas as pd  # type: ignore\n        except ImportError:\n            raise ImportError(\"Pandas is not installed. Run `pip install pandas`.\")\n        return pd.DataFrame(cp)\n    else:\n        raise ValueError(f\"Invalid library {library}. Choose from 'ak', 'np', 'pd'.\")\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_mdc_gid","title":"<code>get_mdc_gid(layer, wire)</code>","text":"<p>Get MDC gid of given layer and wire.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>wire</code> <code>IntLike</code> <p>The wire number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The gid of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_mdc_gid(layer: IntLike, wire: IntLike) -&gt; IntLike:\n    \"\"\"\n    Get MDC gid of given layer and wire.\n\n    Parameters:\n        layer: The layer number.\n        wire: The wire number.\n\n    Returns:\n        The gid of the wire.\n    \"\"\"\n    return layer_start_gid[layer] + wire\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_layer","title":"<code>mdc_gid_to_layer(gid)</code>","text":"<p>Convert gid to layer.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_layer(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert gid to layer.\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The layer number of the wire.\n    \"\"\"\n    return _layer[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_wire","title":"<code>mdc_gid_to_wire(gid)</code>","text":"<p>Convert gid to wire.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The wire number of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_wire(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert gid to wire.\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The wire number of the wire.\n    \"\"\"\n    return _wire[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_is_stereo","title":"<code>mdc_gid_to_is_stereo(gid)</code>","text":"<p>Convert gid to is_stereo.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>The is_stereo of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_is_stereo(gid: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Convert gid to is_stereo.\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The is_stereo of the wire.\n    \"\"\"\n    return _is_stereo[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_layer_to_is_stereo","title":"<code>mdc_layer_to_is_stereo(layer)</code>","text":"<p>Convert layer to is_stereo.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>The is_stereo of the layer.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_layer_to_is_stereo(layer: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Convert layer to is_stereo.\n\n    Parameters:\n        layer: The layer number.\n\n    Returns:\n        The is_stereo of the layer.\n    \"\"\"\n    return is_layer_stereo[layer]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_east_x","title":"<code>mdc_gid_to_east_x(gid)</code>","text":"<p>Convert gid to east_x (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The east_x (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_east_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to east_x (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The east_x (cm) of the wire.\n    \"\"\"\n    return _east_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_east_y","title":"<code>mdc_gid_to_east_y(gid)</code>","text":"<p>Convert gid to east_y (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The east_y (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_east_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to east_y (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The east_y (cm) of the wire.\n    \"\"\"\n    return _east_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_east_z","title":"<code>mdc_gid_to_east_z(gid)</code>","text":"<p>Convert gid to east_z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The east_z (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_east_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to east_z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The east_z (cm) of the wire.\n    \"\"\"\n    return _east_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_west_x","title":"<code>mdc_gid_to_west_x(gid)</code>","text":"<p>Convert gid to west_x (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The west_x (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_west_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to west_x (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The west_x (cm) of the wire.\n    \"\"\"\n    return _west_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_west_y","title":"<code>mdc_gid_to_west_y(gid)</code>","text":"<p>Convert gid to west_y (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The west_y (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_west_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to west_y (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The west_y (cm) of the wire.\n    \"\"\"\n    return _west_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_to_west_z","title":"<code>mdc_gid_to_west_z(gid)</code>","text":"<p>Convert gid to west_z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The west_z (cm) of the wire.</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_to_west_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert gid to west_z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n\n    Returns:\n        The west_z (cm) of the wire.\n    \"\"\"\n    return _west_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_z_to_x","title":"<code>mdc_gid_z_to_x(gid, z)</code>","text":"<p>Get the x (cm) position of the wire at z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>z</code> <code>FloatLike</code> <p>The z (cm) position.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x (cm) position of the wire at z (cm).</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_z_to_x(gid: IntLike, z: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Get the x (cm) position of the wire at z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n        z: The z (cm) position.\n\n    Returns:\n        The x (cm) position of the wire at z (cm).\n    \"\"\"\n    return _west_x[gid] + dx_dz[gid] * (z - _west_z[gid])\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.mdc_gid_z_to_y","title":"<code>mdc_gid_z_to_y(gid, z)</code>","text":"<p>Get the y (cm) position of the wire at z (cm).</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>z</code> <code>FloatLike</code> <p>The z (cm) position.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y (cm) position of the wire at z (cm).</p> Source code in <code>src/pybes3/detectors/geometry/mdc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_gid_z_to_y(gid: IntLike, z: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Get the y (cm) position of the wire at z (cm).\n\n    Parameters:\n        gid: The gid of the wire.\n        z: The z (cm) position.\n\n    Returns:\n        The y (cm) position of the wire at z (cm).\n    \"\"\"\n    return _west_y[gid] + dy_dz[gid] * (z - _west_z[gid])\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_emc_crystal_position","title":"<code>get_emc_crystal_position(library='np')</code>","text":"<p>Get EMC crystal position table.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>Literal['np', 'ak', 'pd']</code> <p>The library to return the data in. Choose from 'ak', 'np', 'pd'.</p> <code>'np'</code> <p>Returns:</p> Type Description <code>Array | dict[str, ndarray] | DataFrame</code> <p>The EMC crystal position table.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the library is not 'ak', 'np', or 'pd'.</p> <code>ImportError</code> <p>If the library is 'pd' but pandas is not installed.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>def get_emc_crystal_position(library: Literal[\"np\", \"ak\", \"pd\"] = \"np\"):\n    \"\"\"\n    Get EMC crystal position table.\n\n    Parameters:\n        library: The library to return the data in. Choose from 'ak', 'np', 'pd'.\n\n    Returns:\n        (ak.Array | dict[str, np.ndarray] | pd.DataFrame): The EMC crystal position table.\n\n    Raises:\n        ValueError: If the library is not 'ak', 'np', or 'pd'.\n        ImportError: If the library is 'pd' but pandas is not installed.\n    \"\"\"\n    cp: dict[str, np.ndarray] = {k: v.copy() for k, v in _emc_geom.items()}\n\n    res: dict[str, np.ndarray] = {}\n\n    for k in [\n        \"gid\",\n        \"center_x\",\n        \"center_y\",\n        \"center_z\",\n        \"front_center_x\",\n        \"front_center_y\",\n        \"front_center_z\",\n    ]:\n        res[k] = cp[k]\n\n    # flatten crystal points\n    for i in range(8):\n        res[f\"points_x_{i}\"] = cp[\"points_x\"][:, i]\n        res[f\"points_y_{i}\"] = cp[\"points_y\"][:, i]\n        res[f\"points_z_{i}\"] = cp[\"points_z\"][:, i]\n\n    if library == \"ak\":\n        return ak.Array(res)\n    elif library == \"np\":\n        return res\n    elif library == \"pd\":\n        try:\n            import pandas as pd  # type: ignore\n        except ImportError:\n            raise ImportError(\"Pandas is not installed. Run `pip install pandas`.\")\n        return pd.DataFrame(res)\n    else:\n        raise ValueError(f\"Invalid library {library}. Choose from 'ak', 'np', 'pd'.\")\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.get_emc_gid","title":"<code>get_emc_gid(part, theta, phi)</code>","text":"<p>Get EMC gid of given part, theta, and phi.</p> <ul> <li>part 0: 0-479<ul> <li>theta 0: 0-63</li> <li>theta 1: 64-127</li> <li>theta 2: 128-207</li> <li>theta 3: 208-287</li> <li>theta 4: 288-383</li> <li>theta 5: 384-479</li> </ul> </li> <li>part 1: 480-5759 (theta 0-47)</li> <li>part 2: 5760-6239<ul> <li>theta 5: 5760-5855 (96)</li> <li>theta 4: 5856-5951 (96)</li> <li>theta 3: 5952-6031 (80)</li> <li>theta 2: 6032-6111 (80)</li> <li>theta 1: 6112-6175 (64)</li> <li>theta 0: 6176-6239 (64)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>IntLike</code> <p>part number</p> required <code>theta</code> <code>IntLike</code> <p>theta number</p> required <code>phi</code> <code>IntLike</code> <p>phi number</p> required <p>Returns:</p> Name Type Description <code>index</code> <code>IntLike</code> <p>EMC index</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_emc_gid(part: IntLike, theta: IntLike, phi: IntLike) -&gt; IntLike:\n    \"\"\"\n    Get EMC gid of given part, theta, and phi.\n\n    - part 0: 0-479\n        - theta 0: 0-63\n        - theta 1: 64-127\n        - theta 2: 128-207\n        - theta 3: 208-287\n        - theta 4: 288-383\n        - theta 5: 384-479\n    - part 1: 480-5759 (theta 0-47)\n    - part 2: 5760-6239\n        - theta 5: 5760-5855 (96)\n        - theta 4: 5856-5951 (96)\n        - theta 3: 5952-6031 (80)\n        - theta 2: 6032-6111 (80)\n        - theta 1: 6112-6175 (64)\n        - theta 0: 6176-6239 (64)\n\n    Parameters:\n        part: part number\n        theta: theta number\n        phi: phi number\n\n    Returns:\n        index: EMC index\n    \"\"\"\n    if part == 0:\n        res = 0\n        if theta == 0 or theta == 1:\n            return np.uint16(theta * ENDCAP_PHI_01 + phi)\n\n        res += 2 * ENDCAP_PHI_01\n        if theta == 2 or theta == 3:\n            return np.uint16(res + (theta - 2) * ENDCAP_PHI_23 + phi)\n\n        res += 2 * ENDCAP_PHI_23\n        if theta == 4 or theta == 5:\n            return np.uint16(res + (theta - 4) * ENDCAP_PHI_45 + phi)\n\n    if part == 1:\n        return np.uint16(ENDCAP_CRYSTALS + theta * BARREL_PHI + phi)\n\n    if part == 2:\n        res = ENDCAP_CRYSTALS + BARREL_CRYSTALS\n\n        if theta == 4 or theta == 5:\n            return np.uint16(res + (5 - theta) * ENDCAP_PHI_45 + phi)\n\n        res += 2 * ENDCAP_PHI_45\n        if theta == 2 or theta == 3:\n            return np.uint16(res + (3 - theta) * ENDCAP_PHI_23 + phi)\n\n        res += 2 * ENDCAP_PHI_23\n        if theta == 0 or theta == 1:\n            return np.uint16(res + (1 - theta) * ENDCAP_PHI_01 + phi)\n\n    return np.uint16(65535)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_center_x","title":"<code>emc_gid_to_center_x(gid)</code>","text":"<p>Convert EMC gid to x coordinate of the crystal's center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x coordinate of the crystal's center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_center_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to x coordinate of the crystal's center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The x coordinate of the crystal's center.\n    \"\"\"\n    return _center_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_center_y","title":"<code>emc_gid_to_center_y(gid)</code>","text":"<p>Convert EMC gid to y coordinate of the crystal's center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y coordinate of the crystal's center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_center_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to y coordinate of the crystal's center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The y coordinate of the crystal's center.\n    \"\"\"\n    return _center_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_center_z","title":"<code>emc_gid_to_center_z(gid)</code>","text":"<p>Convert EMC gid to z coordinate of the crystal's center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The z coordinate of the crystal's center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_center_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to z coordinate of the crystal's center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The z coordinate of the crystal's center.\n    \"\"\"\n    return _center_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_front_center_x","title":"<code>emc_gid_to_front_center_x(gid)</code>","text":"<p>Convert EMC gid to x coordinate of the crystal's front center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x coordinate of the crystal's front center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_front_center_x(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to x coordinate of the crystal's front center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The x coordinate of the crystal's front center.\n    \"\"\"\n    return _front_center_x[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_front_center_y","title":"<code>emc_gid_to_front_center_y(gid)</code>","text":"<p>Convert EMC gid to y coordinate of the crystal's front center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y coordinate of the crystal's front center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_front_center_y(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to y coordinate of the crystal's front center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The y coordinate of the crystal's front center.\n    \"\"\"\n    return _front_center_y[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_front_center_z","title":"<code>emc_gid_to_front_center_z(gid)</code>","text":"<p>Convert EMC gid to z coordinate of the crystal's front center.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The z coordinate of the crystal's front center.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_front_center_z(gid: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to z coordinate of the crystal's front center.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The z coordinate of the crystal's front center.\n    \"\"\"\n    return _front_center_z[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_part","title":"<code>emc_gid_to_part(gid)</code>","text":"<p>Convert EMC gid to part.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The part number of the crystal.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_part(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC gid to part.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The part number of the crystal.\n    \"\"\"\n    return _part[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_phi","title":"<code>emc_gid_to_phi(gid)</code>","text":"<p>Convert EMC gid to phi.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The phi number of the crystal.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_phi(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC gid to phi.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The phi number of the crystal.\n    \"\"\"\n    return _phi[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_point_x","title":"<code>emc_gid_to_point_x(gid, point)</code>","text":"<p>Convert EMC gid to x coordinate of the point.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <code>point</code> <code>IntLike</code> <p>The point number, 0-7.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The x coordinate of the point.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_point_x(gid: IntLike, point: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to x coordinate of the point.\n\n    Parameters:\n        gid: The gid of the crystal.\n        point: The point number, 0-7.\n\n    Returns:\n        The x coordinate of the point.\n    \"\"\"\n    return _points_x[gid, point]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_point_y","title":"<code>emc_gid_to_point_y(gid, point)</code>","text":"<p>Convert EMC gid to y coordinate of the point.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <code>point</code> <code>IntLike</code> <p>The point number, 0-7.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The y coordinate of the point.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_point_y(gid: IntLike, point: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to y coordinate of the point.\n\n    Parameters:\n        gid: The gid of the crystal.\n        point: The point number, 0-7.\n\n    Returns:\n        The y coordinate of the point.\n    \"\"\"\n    return _points_y[gid, point]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_point_z","title":"<code>emc_gid_to_point_z(gid, point)</code>","text":"<p>Convert EMC gid to z coordinate of the point.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <code>point</code> <code>IntLike</code> <p>The point number, 0-7.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>The z coordinate of the point.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_point_z(gid: IntLike, point: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert EMC gid to z coordinate of the point.\n\n    Parameters:\n        gid: The gid of the crystal.\n        point: The point number, 0-7.\n\n    Returns:\n        The z coordinate of the point.\n    \"\"\"\n    return _points_z[gid, point]\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.geometry.emc_gid_to_theta","title":"<code>emc_gid_to_theta(gid)</code>","text":"<p>Convert EMC gid to theta.</p> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the crystal.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The theta number of the crystal.</p> Source code in <code>src/pybes3/detectors/geometry/emc.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_gid_to_theta(gid: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC gid to theta.\n\n    Parameters:\n        gid: The gid of the crystal.\n\n    Returns:\n        The theta number of the crystal.\n    \"\"\"\n    return _theta[gid]\n</code></pre>"},{"location":"api/pybes3.detectors/#digi-identifier","title":"Digi Identifier","text":""},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_mdc_id","title":"<code>check_mdc_id(mdc_digi_id)</code>","text":"<p>Check if the MDC digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef check_mdc_id(mdc_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Check if the MDC digi ID is valid.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (mdc_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_MDC_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.mdc_id_to_wire","title":"<code>mdc_id_to_wire(mdc_digi_id)</code>","text":"<p>Convert MDC digi ID to wire number.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The wire number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_id_to_wire(mdc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert MDC digi ID to wire number.\n\n    Parameters:\n        mdc_digi_id: MDC digi ID array or value.\n\n    Returns:\n        The wire number.\n    \"\"\"\n    return np.uint16((mdc_digi_id &amp; DIGI_MDC_WIRE_MASK) &gt;&gt; DIGI_MDC_WIRE_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.mdc_id_to_layer","title":"<code>mdc_id_to_layer(mdc_digi_id)</code>","text":"<p>Convert the MDC digi ID to the layer number.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_id_to_layer(mdc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the MDC digi ID to the layer number.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID array or value.\n\n    Returns:\n        The layer number.\n    \"\"\"\n    return np.uint8((mdc_digi_id &amp; DIGI_MDC_LAYER_MASK) &gt;&gt; DIGI_MDC_LAYER_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.mdc_id_to_is_stereo","title":"<code>mdc_id_to_is_stereo(mdc_digi_id)</code>","text":"<p>Convert the MDC digi ID to whether it is a stereo wire.</p> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the wire is a stereo wire.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef mdc_id_to_is_stereo(mdc_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Convert the MDC digi ID to whether it is a stereo wire.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID array or value.\n\n    Returns:\n        Whether the wire is a stereo wire.\n    \"\"\"\n    return (\n        mdc_digi_id &amp; DIGI_MDC_WIRETYPE_MASK\n    ) &gt;&gt; DIGI_MDC_WIRETYPE_OFFSET == DIGI_MDC_STEREO_WIRE\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_mdc_digi_id","title":"<code>get_mdc_digi_id(wire, layer, wire_type)</code>","text":"<p>Generate MDC digi ID based on the wire number, layer number, and wire type.</p> <p>Parameters:</p> Name Type Description Default <code>wire</code> <code>IntLike</code> <p>The wire number.</p> required <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>wire_type</code> <code>IntLike</code> <p>The wire type.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The MDC digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_mdc_digi_id(\n    wire: IntLike,\n    layer: IntLike,\n    wire_type: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate MDC digi ID based on the wire number, layer number, and wire type.\n\n    Parameters:\n        wire: The wire number.\n        layer: The layer number.\n        wire_type: The wire type.\n\n    Returns:\n        The MDC digi ID.\n    \"\"\"\n    return np.uint32(\n        ((wire &lt;&lt; DIGI_MDC_WIRE_OFFSET) &amp; DIGI_MDC_WIRE_MASK)\n        | ((layer &lt;&lt; DIGI_MDC_LAYER_OFFSET) &amp; DIGI_MDC_LAYER_MASK)\n        | ((wire_type &lt;&lt; DIGI_MDC_WIRETYPE_OFFSET) &amp; DIGI_MDC_WIRETYPE_MASK)\n        | (DIGI_MDC_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_tof_id","title":"<code>check_tof_id(tof_digi_id)</code>","text":"<p>Check if the TOF digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef check_tof_id(tof_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Check if the TOF digi ID is valid.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (tof_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_TOF_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_part","title":"<code>tof_id_to_part(tof_digi_id)</code>","text":"<p>Convert TOF digi ID to part number. 0, 1, 2 for scintillator endcap0/barrel/endcap1, 3, 4 for MRPC endcap0/endcap1.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>TOF digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The part number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef tof_id_to_part(tof_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert TOF digi ID to part number. 0, 1, 2 for scintillator endcap0/barrel/endcap1,\n    3, 4 for MRPC endcap0/endcap1.\n\n    Parameters:\n        tof_digi_id: TOF digi ID array or value.\n\n    Returns:\n        The part number.\n    \"\"\"\n    part = (tof_digi_id &amp; DIGI_TOF_PART_MASK) &gt;&gt; DIGI_TOF_PART_OFFSET\n    if part == 3:  # += MRPC endcap number\n        part += (tof_digi_id &amp; DIGI_TOF_MRPC_ENDCAP_MASK) &gt;&gt; DIGI_TOF_MRPC_ENDCAP_OFFSET\n    return np.uint8(part)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_layer_or_module","title":"<code>tof_id_to_layer_or_module(tof_digi_id, part=None)</code>","text":"<p>Convert the TOF digi ID to the scintillator layer or MRPC module number. If <code>part &lt; 3</code>, it is scintillator and the return value is layer number. Otherwise, it is MRPC and the return value is module number.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <code>part</code> <code>Optional[IntLike]</code> <p>The part number. If not provided, it will be calculated based on the TOF digi ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>IntLike</code> <p>The scintillator layer or MRPC module number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def tof_id_to_layer_or_module(\n    tof_digi_id: IntLike,\n    part: Optional[IntLike] = None,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the TOF digi ID to the scintillator layer or MRPC module number.\n    If `part &lt; 3`, it is scintillator and the return value is layer number. Otherwise, it is\n    MRPC and the return value is module number.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n        part: The part number. If not provided, it will be calculated based on the TOF digi ID.\n\n    Returns:\n        The scintillator layer or MRPC module number.\n    \"\"\"\n    if part is None:\n        return _tof_id_to_layer_or_module_1(tof_digi_id)\n    else:\n        return _tof_id_to_layer_or_module_2(tof_digi_id, part)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_phi_or_strip","title":"<code>tof_id_to_phi_or_strip(tof_digi_id, part=None)</code>","text":"<p>Convert the TOF digi ID to the scintillator phi or MRPC strip number, based on the part number. If <code>part &lt; 3</code>, it is scintillator and the return value is phi number. Otherwise, it is MRPC and the return value is strip number.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <code>part</code> <code>Optional[IntLike]</code> <p>The part number. If not provided, it will be calculated based on the TOF digi ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>IntLike</code> <p>The scintillator phi or MRPC strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def tof_id_to_phi_or_strip(\n    tof_digi_id: IntLike,\n    part: Optional[IntLike] = None,\n) -&gt; IntLike:\n    \"\"\"\n    Convert the TOF digi ID to the scintillator phi or MRPC strip number, based on the part number.\n    If `part &lt; 3`, it is scintillator and the return value is phi number. Otherwise, it is\n    MRPC and the return value is strip number.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n        part: The part number. If not provided, it will be calculated based on the TOF digi ID.\n\n    Returns:\n        The scintillator phi or MRPC strip number.\n    \"\"\"\n    if part is None:\n        return _tof_id_to_phi_or_strip_1(tof_digi_id)\n    else:\n        return _tof_id_to_phi_or_strip_2(tof_digi_id, part)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.tof_id_to_end","title":"<code>tof_id_to_end(tof_digi_id)</code>","text":"<p>Convert the TOF digi ID to the readout end number.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The readout end number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef tof_id_to_end(tof_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the TOF digi ID to the readout end number.\n\n    Parameters:\n        tof_digi_id: The TOF digi ID array or value.\n\n    Returns:\n        The readout end number.\n    \"\"\"\n    return np.uint8(tof_digi_id % 2)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_tof_digi_id","title":"<code>get_tof_digi_id(part, layer_or_module, phi_or_strip, end)</code>","text":"<p>Generate TOF scintillator ID based on the part number, layer number, phi number, and readout end number.</p> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>IntLike</code> <p>The part number.</p> required <code>layer_or_module</code> <code>IntLike</code> <p>The scintillator layer or MRPC module number.</p> required <code>phi_or_strip</code> <code>IntLike</code> <p>The scintillator phi or MRPC strip number.</p> required <code>end</code> <code>IntLike</code> <p>The readout end number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The TOF digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_tof_digi_id(\n    part: IntLike,\n    layer_or_module: IntLike,\n    phi_or_strip: IntLike,\n    end: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate TOF scintillator ID based on the part number, layer number, phi number, and readout end number.\n\n    Parameters:\n        part: The part number.\n        layer_or_module: The scintillator layer or MRPC module number.\n        phi_or_strip: The scintillator phi or MRPC strip number.\n        end: The readout end number.\n\n    Returns:\n        The TOF digi ID.\n    \"\"\"\n    if part &lt; 3:\n        return np.uint32(\n            ((part &lt;&lt; DIGI_TOF_PART_OFFSET) &amp; DIGI_TOF_PART_MASK)\n            | ((layer_or_module &lt;&lt; DIGI_TOF_SCINT_LAYER_OFFSET) &amp; DIGI_TOF_SCINT_LAYER_MASK)\n            | ((phi_or_strip &lt;&lt; DIGI_TOF_SCINT_PHI_OFFSET) &amp; DIGI_TOF_SCINT_PHI_MASK)\n            | ((end &lt;&lt; DIGI_TOF_END_OFFSET) &amp; DIGI_TOF_END_MASK)\n            | (DIGI_TOF_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n        )\n    else:\n        return np.uint32(\n            ((3 &lt;&lt; DIGI_TOF_PART_OFFSET) &amp; DIGI_TOF_PART_MASK)\n            | (((part - 3) &lt;&lt; DIGI_TOF_MRPC_ENDCAP_OFFSET) &amp; DIGI_TOF_MRPC_ENDCAP_MASK)\n            | ((layer_or_module &lt;&lt; DIGI_TOF_MRPC_MODULE_OFFSET) &amp; DIGI_TOF_MRPC_MODULE_MASK)\n            | ((phi_or_strip &lt;&lt; DIGI_TOF_MRPC_STRIP_OFFSET) &amp; DIGI_TOF_MRPC_STRIP_MASK)\n            | ((end &lt;&lt; DIGI_TOF_END_OFFSET) &amp; DIGI_TOF_END_MASK)\n            | (DIGI_TOF_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n        )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_emc_id","title":"<code>check_emc_id(emc_digi_id)</code>","text":"<p>Check if the EMC digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef check_emc_id(emc_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Check if the EMC digi ID is valid.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (emc_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_EMC_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.emc_id_to_module","title":"<code>emc_id_to_module(emc_digi_id)</code>","text":"<p>Convert EMC digi ID to module number</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The module number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_id_to_module(emc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert EMC digi ID to module number\n\n    Parameters:\n        emc_digi_id: EMC digi ID array or value.\n\n    Returns:\n        The module number.\n    \"\"\"\n    return np.uint8((emc_digi_id &amp; DIGI_EMC_MODULE_MASK) &gt;&gt; DIGI_EMC_MODULE_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.emc_id_to_theta","title":"<code>emc_id_to_theta(emc_digi_id)</code>","text":"<p>Convert the EMC digi ID to the theta number.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The theta number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_id_to_theta(emc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the EMC digi ID to the theta number.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID array or value.\n\n    Returns:\n        The theta number.\n    \"\"\"\n    return np.uint8((emc_digi_id &amp; DIGI_EMC_THETA_MASK) &gt;&gt; DIGI_EMC_THETA_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.emc_id_to_phi","title":"<code>emc_id_to_phi(emc_digi_id)</code>","text":"<p>Convert the EMC digi ID to the phi number.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The phi number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef emc_id_to_phi(emc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the EMC digi ID to the phi number.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID array or value.\n\n    Returns:\n        The phi number.\n    \"\"\"\n    return np.uint8((emc_digi_id &amp; DIGI_EMC_PHI_MASK) &gt;&gt; DIGI_EMC_PHI_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_emc_digi_id","title":"<code>get_emc_digi_id(module, theta, phi)</code>","text":"<p>Generate EMC digi ID based on the module number, theta number, and phi number.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>IntLike</code> <p>The module number.</p> required <code>theta</code> <code>IntLike</code> <p>The theta number.</p> required <code>phi</code> <code>IntLike</code> <p>The phi number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The EMC digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_emc_digi_id(\n    module: IntLike,\n    theta: IntLike,\n    phi: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate EMC digi ID based on the module number, theta number, and phi number.\n\n    Parameters:\n        module: The module number.\n        theta: The theta number.\n        phi: The phi number.\n\n    Returns:\n        The EMC digi ID.\n    \"\"\"\n    return np.uint32(\n        ((module &lt;&lt; DIGI_EMC_MODULE_OFFSET) &amp; DIGI_EMC_MODULE_MASK)\n        | ((theta &lt;&lt; DIGI_EMC_THETA_OFFSET) &amp; DIGI_EMC_THETA_MASK)\n        | ((phi &lt;&lt; DIGI_EMC_PHI_OFFSET) &amp; DIGI_EMC_PHI_MASK)\n        | (DIGI_EMC_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_muc_id","title":"<code>check_muc_id(muc_digi_id)</code>","text":"<p>Check if the MUC digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef check_muc_id(muc_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Check if the MUC digi ID is valid.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (muc_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_MUC_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_part","title":"<code>muc_id_to_part(muc_digi_id)</code>","text":"<p>Convert MUC digi ID to part number</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The part number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef muc_id_to_part(muc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert MUC digi ID to part number\n\n    Parameters:\n        muc_digi_id: MUC digi ID array or value.\n\n    Returns:\n        The part number.\n    \"\"\"\n    return np.uint8((muc_digi_id &amp; DIGI_MUC_PART_MASK) &gt;&gt; DIGI_MUC_PART_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_segment","title":"<code>muc_id_to_segment(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the segment number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The segment number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef muc_id_to_segment(muc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the segment number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The segment number.\n    \"\"\"\n    return np.uint8((muc_digi_id &amp; DIGI_MUC_SEGMENT_MASK) &gt;&gt; DIGI_MUC_SEGMENT_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_layer","title":"<code>muc_id_to_layer(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the layer number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef muc_id_to_layer(muc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the layer number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The layer number.\n    \"\"\"\n    return np.uint8((muc_digi_id &amp; DIGI_MUC_LAYER_MASK) &gt;&gt; DIGI_MUC_LAYER_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_strip","title":"<code>muc_id_to_strip(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the strip number, which is equivalent to channel number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def muc_id_to_strip(muc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The strip number.\n    \"\"\"\n    return muc_id_to_channel(muc_digi_id)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_gap","title":"<code>muc_id_to_gap(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the gap ID, which is equivalent to layer number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The gap ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def muc_id_to_gap(muc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the gap ID, which is equivalent to layer number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The gap ID.\n    \"\"\"\n    return muc_id_to_layer(muc_digi_id)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.muc_id_to_strip","title":"<code>muc_id_to_strip(muc_digi_id)</code>","text":"<p>Convert the MUC digi ID to the strip number, which is equivalent to channel number.</p> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>def muc_id_to_strip(muc_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the MUC digi ID to the strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID array or value.\n\n    Returns:\n        The strip number.\n    \"\"\"\n    return muc_id_to_channel(muc_digi_id)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_muc_digi_id","title":"<code>get_muc_digi_id(part, segment, layer, channel)</code>","text":"<p>Generate MUC digi ID based on the part number, segment number, layer number, and channel number.</p> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>IntLike</code> <p>The part number.</p> required <code>segment</code> <code>IntLike</code> <p>The segment number.</p> required <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>channel</code> <code>IntLike</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The MUC digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_muc_digi_id(\n    part: IntLike,\n    segment: IntLike,\n    layer: IntLike,\n    channel: IntLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate MUC digi ID based on the part number, segment number, layer number, and channel number.\n\n    Parameters:\n        part: The part number.\n        segment: The segment number.\n        layer: The layer number.\n        channel: The channel number.\n\n    Returns:\n        The MUC digi ID.\n    \"\"\"\n    return np.uint32(\n        ((part &lt;&lt; DIGI_MUC_PART_OFFSET) &amp; DIGI_MUC_PART_MASK)\n        | ((segment &lt;&lt; DIGI_MUC_SEGMENT_OFFSET) &amp; DIGI_MUC_SEGMENT_MASK)\n        | ((layer &lt;&lt; DIGI_MUC_LAYER_OFFSET) &amp; DIGI_MUC_LAYER_MASK)\n        | ((channel &lt;&lt; DIGI_MUC_CHANNEL_OFFSET) &amp; DIGI_MUC_CHANNEL_MASK)\n        | (DIGI_MUC_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.check_cgem_id","title":"<code>check_cgem_id(cgem_digi_id)</code>","text":"<p>Check if the CGEM digi ID is valid.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the digi ID is valid.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef check_cgem_id(cgem_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Check if the CGEM digi ID is valid.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        Whether the digi ID is valid.\n    \"\"\"\n    return (cgem_digi_id &amp; DIGI_FLAG_MASK) &gt;&gt; DIGI_FLAG_OFFSET == DIGI_CGEM_FLAG\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_layer","title":"<code>cgem_id_to_layer(cgem_digi_id)</code>","text":"<p>Convert the CGEM digi ID to the layer number.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The layer number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef cgem_id_to_layer(cgem_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the CGEM digi ID to the layer number.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        The layer number.\n    \"\"\"\n    return np.uint8((cgem_digi_id &amp; DIGI_CGEM_LAYER_MASK) &gt;&gt; DIGI_CGEM_LAYER_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_sheet","title":"<code>cgem_id_to_sheet(cgem_digi_id)</code>","text":"<p>Convert the CGEM digi ID to the sheet number.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The sheet number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef cgem_id_to_sheet(cgem_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert the CGEM digi ID to the sheet number.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        The sheet number.\n    \"\"\"\n    return np.uint8((cgem_digi_id &amp; DIGI_CGEM_SHEET_MASK) &gt;&gt; DIGI_CGEM_SHEET_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_strip","title":"<code>cgem_id_to_strip(cgem_digi_id)</code>","text":"<p>Convert CGEM digi ID to strip number</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The strip number.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef cgem_id_to_strip(cgem_digi_id: IntLike) -&gt; IntLike:\n    \"\"\"\n    Convert CGEM digi ID to strip number\n\n    Parameters:\n        cgem_digi_id: CGEM digi ID array or value.\n\n    Returns:\n        The strip number.\n    \"\"\"\n    return np.uint16((cgem_digi_id &amp; DIGI_CGEM_STRIP_MASK) &gt;&gt; DIGI_CGEM_STRIP_OFFSET)\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.cgem_id_to_is_x_strip","title":"<code>cgem_id_to_is_x_strip(cgem_digi_id)</code>","text":"<p>Convert the CGEM digi ID to whether it is an X-strip.</p> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID array or value.</p> required <p>Returns:</p> Type Description <code>BoolLike</code> <p>Whether the strip is an X-strip</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef cgem_id_to_is_x_strip(cgem_digi_id: IntLike) -&gt; BoolLike:\n    \"\"\"\n    Convert the CGEM digi ID to whether it is an X-strip.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID array or value.\n\n    Returns:\n        Whether the strip is an X-strip\n    \"\"\"\n    return (\n        (cgem_digi_id &amp; DIGI_CGEM_STRIPTYPE_MASK) &gt;&gt; DIGI_CGEM_STRIPTYPE_OFFSET\n    ) == DIGI_CGEM_XSTRIP\n</code></pre>"},{"location":"api/pybes3.detectors/#pybes3.detectors.digi_id.get_cgem_digi_id","title":"<code>get_cgem_digi_id(layer, sheet, strip, is_x_strip)</code>","text":"<p>Generate CGEM digi ID based on the strip number, strip type, sheet number, and layer number.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>IntLike</code> <p>The layer number.</p> required <code>sheet</code> <code>IntLike</code> <p>The sheet number.</p> required <code>strip</code> <code>IntLike</code> <p>The strip number.</p> required <code>is_x_strip</code> <code>BoolLike</code> <p>Whether the strip is an X-strip.</p> required <p>Returns:</p> Type Description <code>IntLike</code> <p>The CGEM digi ID.</p> Source code in <code>src/pybes3/detectors/digi_id.py</code> <pre><code>@nb.vectorize(cache=True)\ndef get_cgem_digi_id(\n    layer: IntLike,\n    sheet: IntLike,\n    strip: IntLike,\n    is_x_strip: BoolLike,\n) -&gt; IntLike:\n    \"\"\"\n    Generate CGEM digi ID based on the strip number, strip type, sheet number, and layer number.\n\n    Parameters:\n        layer: The layer number.\n        sheet: The sheet number.\n        strip: The strip number.\n        is_x_strip: Whether the strip is an X-strip.\n\n    Returns:\n        The CGEM digi ID.\n    \"\"\"\n    return np.uint32(\n        ((strip &lt;&lt; DIGI_CGEM_STRIP_OFFSET) &amp; DIGI_CGEM_STRIP_MASK)\n        | ((~is_x_strip &lt;&lt; DIGI_CGEM_STRIPTYPE_OFFSET) &amp; DIGI_CGEM_STRIPTYPE_MASK)\n        | ((sheet &lt;&lt; DIGI_CGEM_SHEET_OFFSET) &amp; DIGI_CGEM_SHEET_MASK)\n        | ((layer &lt;&lt; DIGI_CGEM_LAYER_OFFSET) &amp; DIGI_CGEM_LAYER_MASK)\n        | (DIGI_CGEM_FLAG &lt;&lt; DIGI_FLAG_OFFSET)\n    )\n</code></pre>"},{"location":"api/pybes3/","title":"pybes3","text":""},{"location":"api/pybes3/#besio","title":"besio","text":""},{"location":"api/pybes3/#pybes3.wrap_uproot","title":"<code>wrap_uproot()</code>","text":"<p>Wraps the uproot functions to use the BES interpretation.</p> Source code in <code>src/pybes3/besio/root_io.py</code> <pre><code>def wrap_uproot():\n    \"\"\"\n    Wraps the uproot functions to use the BES interpretation.\n    \"\"\"\n    wrap_uproot_interpretation()\n</code></pre>"},{"location":"api/pybes3/#pybes3.open","title":"<code>open(file, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.open</code> that automatically calls <code>wrap_uproot</code> before opening the file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | IO | dict[str | Path | IO, str]</code> <p>The file to open.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.open</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The uproot file object.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open(file, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.open` that automatically calls `wrap_uproot` before opening the file.\n\n    Parameters:\n        file (str | Path | IO | dict[str | Path | IO, str]): The file to open.\n        **kwargs (dict): Additional arguments to pass to `uproot.open`.\n\n    Returns:\n        The uproot file object.\n    \"\"\"\n    wrap_uproot()\n    return uproot.open(file, **kwargs)\n</code></pre>"},{"location":"api/pybes3/#pybes3.concatenate","title":"<code>concatenate(files, branch, **kwargs)</code>","text":"<p>A wrapper around <code>uproot.concatenate</code> that automatically calls <code>wrap_uproot</code> before concatenating the files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str | Path | IO, str]</code> <p>The files to concatenate.</p> required <code>branch</code> <code>str</code> <p>The branch to concatenate.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to <code>uproot.concatenate</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The concatenated array.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def concatenate(files, branch: str, **kwargs) -&gt; Any:\n    \"\"\"\n    A wrapper around `uproot.concatenate` that automatically calls `wrap_uproot` before concatenating the files.\n\n    Parameters:\n        files (list[str | Path | IO, str]): The files to concatenate.\n        branch (str): The branch to concatenate.\n        **kwargs (dict): Additional arguments to pass to `uproot.concatenate`.\n\n    Returns:\n        The concatenated array.\n    \"\"\"\n    wrap_uproot()\n    return uproot.concatenate({str(f): branch for f in files}, **kwargs)\n</code></pre>"},{"location":"api/pybes3/#pybes3.open_raw","title":"<code>open_raw(file)</code>","text":"<p>Open a raw binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The file to open.</p> required <p>Returns:</p> Type Description <code>RawBinaryReader</code> <p>The raw binary reader.</p> Source code in <code>src/pybes3/besio/__init__.py</code> <pre><code>def open_raw(file: str) -&gt; RawBinaryReader:\n    \"\"\"\n    Open a raw binary file.\n\n    Parameters:\n        file (str): The file to open.\n\n    Returns:\n        (RawBinaryReader): The raw binary reader.\n    \"\"\"\n    return RawBinaryReader(file)\n</code></pre>"},{"location":"api/pybes3/#pybes3.concatenate_raw","title":"<code>concatenate_raw(files, n_block_per_batch=10000, sub_detectors=None, max_workers=None, verbose=False)</code>","text":"<p>Concatenate multiple raw binary files into <code>ak.Array</code></p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[Union[str, Path], list[Union[str, Path]]]</code> <p>files to be read.</p> required <code>n_block_per_batch</code> <code>int</code> <p>The number of blocks to read per batch. Defaults to 1000.</p> <code>10000</code> <code>sub_detectors</code> <code>Optional[list[str]]</code> <p>List of sub-detectors to read. Defaults to <code>None</code>, which means read all sub-detectors.</p> <code>None</code> <code>max_workers</code> <code>Optional[int]</code> <p>The maximum number of worker threads to use for reading the data. Defaults to <code>None</code>, which means use the default number of worker threads.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Show reading process.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>Concatenated raw data array.</p> Source code in <code>src/pybes3/besio/raw_io.py</code> <pre><code>def concatenate(\n    files: Union[Union[str, Path], list[Union[str, Path]]],\n    n_block_per_batch: int = 10000,\n    sub_detectors: Optional[list[str]] = None,\n    max_workers: Optional[int] = None,\n    verbose: bool = False,\n) -&gt; ak.Array:\n    \"\"\"\n    Concatenate multiple raw binary files into `ak.Array`\n\n    Parameters:\n        files (Union[Union[str, Path], list[Union[str, Path]]]): files to be read.\n        n_block_per_batch (int, optional): The number of blocks to read per batch. Defaults to 1000.\n        sub_detectors (Optional[list[str]]): List of sub-detectors to read. Defaults to `None`, which means read all sub-detectors.\n        max_workers (Optional[int]): The maximum number of worker threads to use for reading the data. Defaults to `None`, which means use the default number of worker threads.\n        verbose (bool): Show reading process.\n\n    Returns:\n        Concatenated raw data array.\n    \"\"\"\n\n    if not isinstance(files, list):\n        files = glob.glob(files)\n\n    files = [str(Path(file).resolve()) for file in files if _is_raw(file)]\n\n    if len(files) == 0:\n        raise ValueError(\"No valid raw files found\")\n\n    res = []\n    for i, f in enumerate(files):\n        if verbose:\n            print(f\"\\rreading file {i+1}/{len(files)} ...\", end=\"\")\n\n        res.append(\n            RawBinaryReader(f).arrays(-1, n_block_per_batch, sub_detectors, max_workers)\n        )\n\n    if verbose:\n        print()\n\n    return ak.concatenate(res)\n</code></pre>"},{"location":"api/pybes3/#detectors","title":"detectors","text":""},{"location":"api/pybes3/#pybes3.parse_cgem_digi_id","title":"<code>parse_cgem_digi_id(cgem_digi_id, flat=False, library='ak')</code>","text":"<p>Parse CGEM digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>layer</code>: The layer number.</li> <li><code>sheet</code>: The sheet ID.</li> <li><code>strip</code>: The strip ID.</li> <li><code>is_x_strip</code>: Whether the strip is an X-strip.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cgem_digi_id</code> <code>IntLike</code> <p>The CGEM digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed CGEM digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_cgem_digi_id(\n    cgem_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse CGEM digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `layer`: The layer number.\n    - `sheet`: The sheet ID.\n    - `strip`: The strip ID.\n    - `is_x_strip`: Whether the strip is an X-strip.\n\n    Parameters:\n        cgem_digi_id: The CGEM digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed CGEM digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(cgem_digi_id, ak.Array):\n        cgem_digi_id = ak.flatten(cgem_digi_id)\n\n    res = {\n        \"layer\": digi_id.cgem_id_to_layer(cgem_digi_id),\n        \"sheet\": digi_id.cgem_id_to_sheet(cgem_digi_id),\n        \"strip\": digi_id.cgem_id_to_strip(cgem_digi_id),\n        \"is_x_strip\": digi_id.cgem_id_to_is_x_strip(cgem_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_mdc_gid","title":"<code>parse_mdc_gid(gid, with_pos=True)</code>","text":"<p>Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795. When <code>gid</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>layer</code>: Layer number.</li> <li><code>wire</code>: Local wire number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>gid</code> <code>IntLike</code> <p>The gid of the wire.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_gid(gid: IntLike, with_pos: bool = True) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse the gid of MDC wires. \"gid\" is the global ID of the wire, ranges from 0 to 6795.\n    When `gid` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `layer`: Layer number.\n    - `wire`: Local wire number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        gid: The gid of the wire.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    layer = mdc_gid_to_layer(gid)\n    wire = mdc_gid_to_wire(gid)\n\n    res = {\n        \"gid\": gid,\n        \"layer\": layer,\n        \"wire\": wire,\n        \"stereo\": mdc_gid_to_stereo(gid),\n        \"is_stereo\": mdc_gid_to_is_stereo(gid),\n        \"superlayer\": mdc_gid_to_superlayer(gid),\n    }\n\n    if with_pos:\n        west_x = mdc_gid_to_west_x(gid)\n        west_y = mdc_gid_to_west_y(gid)\n        east_x = mdc_gid_to_east_x(gid)\n        east_y = mdc_gid_to_east_y(gid)\n        res[\"mid_x\"] = (west_x + east_x) / 2\n        res[\"mid_y\"] = (west_y + east_y) / 2\n        res[\"west_x\"] = west_x\n        res[\"west_y\"] = west_y\n        res[\"west_z\"] = mdc_gid_to_west_z(gid)\n        res[\"east_x\"] = east_x\n        res[\"east_y\"] = east_y\n        res[\"east_z\"] = mdc_gid_to_east_z(gid)\n\n    if isinstance(gid, ak.Array):\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_mdc_digi","title":"<code>parse_mdc_digi(mdc_digi, with_pos=False)</code>","text":"<p>Parse MDC raw digi array. The raw digi array should contain [<code>m_intId</code>, <code>m_timeChannel</code>, <code>m_chargeChannel</code>, <code>m_trackIndex</code>, <code>m_overflow</code>] fields.</p> <p>Fields of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>wire</code>: Local wire number.</li> <li><code>layer</code>: Layer number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> <li><code>charge_channel</code>: Charge channel.</li> <li><code>time_channel</code>: Time channel.</li> <li><code>track_index</code>: Track index.</li> <li><code>overflow</code>: Overflow flag.</li> <li><code>digi_id</code>: Raw digi ID.</li> </ul> <p>Optional fields of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mdc_digi</code> <code>Record</code> <p>The MDC raw digi array.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Record</code> <p>The parsed MDC digi array.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_digi(mdc_digi: ak.Record, with_pos: bool = False) -&gt; ak.Record:\n    \"\"\"\n    Parse MDC raw digi array. The raw digi array should contain [`m_intId`,\n    `m_timeChannel`, `m_chargeChannel`, `m_trackIndex`, `m_overflow`] fields.\n\n    Fields of the output:\n\n    - `gid`: Global ID of the wire.\n    - `wire`: Local wire number.\n    - `layer`: Layer number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n    - `charge_channel`: Charge channel.\n    - `time_channel`: Time channel.\n    - `track_index`: Track index.\n    - `overflow`: Overflow flag.\n    - `digi_id`: Raw digi ID.\n\n    Optional fields of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        mdc_digi: The MDC raw digi array.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed MDC digi array.\n    \"\"\"\n    gid = parse_mdc_digi_id(mdc_digi[\"m_intId\"], with_pos=with_pos)\n\n    res = {\n        \"gid\": gid[\"gid\"],\n        \"wire\": gid[\"wire\"],\n        \"layer\": gid[\"layer\"],\n        \"stereo\": gid[\"stereo\"],\n        \"is_stereo\": gid[\"is_stereo\"],\n        \"superlayer\": gid[\"superlayer\"],\n        \"charge_channel\": mdc_digi[\"m_chargeChannel\"],\n        \"time_channel\": mdc_digi[\"m_timeChannel\"],\n        \"track_index\": mdc_digi[\"m_trackIndex\"],\n        \"overflow\": mdc_digi[\"m_overflow\"],\n        \"digi_id\": mdc_digi[\"m_intId\"],\n    }\n\n    if with_pos:\n        res[\"mid_x\"] = gid[\"mid_x\"]\n        res[\"mid_y\"] = gid[\"mid_y\"]\n        res[\"west_x\"] = gid[\"west_x\"]\n        res[\"west_y\"] = gid[\"west_y\"]\n        res[\"west_z\"] = gid[\"west_z\"]\n        res[\"east_x\"] = gid[\"east_x\"]\n        res[\"east_y\"] = gid[\"east_y\"]\n        res[\"east_z\"] = gid[\"east_z\"]\n\n    return ak.zip(res)\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_mdc_digi_id","title":"<code>parse_mdc_digi_id(mdc_digi_id, with_pos=False)</code>","text":"<p>Parse MDC digi ID.</p> <p>When <code>mdc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the wire.</li> <li><code>wire</code>: Local wire number.</li> <li><code>layer</code>: Layer number.</li> <li><code>stereo</code>: Stereo type. 0 for axial, -1 for <code>phi_west &lt; phi_east</code>, 1 for <code>phi_west &gt; phi_east</code>.</li> <li><code>is_stereo</code>: Whether the wire is a stereo wire.</li> <li><code>superlayer</code>: Superlayer number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>mid_x</code>: x position of the wire at <code>z=0</code>.</li> <li><code>mid_y</code>: y position of the wire at <code>z=0</code>.</li> <li><code>west_x</code>: x position of the west end of the wire.</li> <li><code>west_y</code>: y position of the west end of the wire.</li> <li><code>west_z</code>: z position of the west end of the wire.</li> <li><code>east_x</code>: x position of the east end of the wire.</li> <li><code>east_y</code>: y position of the east end of the wire.</li> <li><code>east_z</code>: z position of the east end of the wire.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mdc_digi_id</code> <code>IntLike</code> <p>The MDC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed result.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_mdc_digi_id(\n    mdc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse MDC digi ID.\n\n    When `mdc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the wire.\n    - `wire`: Local wire number.\n    - `layer`: Layer number.\n    - `stereo`: Stereo type. 0 for axial, -1 for `phi_west &lt; phi_east`, 1 for `phi_west &gt; phi_east`.\n    - `is_stereo`: Whether the wire is a stereo wire.\n    - `superlayer`: Superlayer number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `mid_x`: x position of the wire at `z=0`.\n    - `mid_y`: y position of the wire at `z=0`.\n    - `west_x`: x position of the west end of the wire.\n    - `west_y`: y position of the west end of the wire.\n    - `west_z`: z position of the west end of the wire.\n    - `east_x`: x position of the east end of the wire.\n    - `east_y`: y position of the east end of the wire.\n    - `east_z`: z position of the east end of the wire.\n\n    Parameters:\n        mdc_digi_id: The MDC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed result.\n    \"\"\"\n    wire = digi_id.mdc_id_to_wire(mdc_digi_id)\n    layer = digi_id.mdc_id_to_layer(mdc_digi_id)\n    gid = get_mdc_gid(layer, wire)\n    return parse_mdc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_tof_digi_id","title":"<code>parse_tof_digi_id(tof_digi_id, flat=False, library='ak')</code>","text":"<p>Parse TOF digi ID. If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number. <code>0,1,2</code> for scintillator endcap0, barrel, endcap1; <code>3,4</code> for MRPC endcap0, endcap1.</li> <li><code>layer_or_module</code>: The scintillator layer or MRPC module number, based on the part number.</li> <li><code>phi_or_strip</code>: The scintillator phi or MRPC strip ID, based on the part number.</li> <li><code>end</code>: The readout end ID.</li> </ul> <p>The return value is based on the part number.</p> <p>Rows where <code>part &lt; 3</code> are scintillator and <code>layer_or_module</code> represents layer number, <code>phi_or_strip</code> represents phi number.</p> <p>Rows where <code>part &gt;= 3</code> are MRPC and <code>layer_or_module</code> represents module number, <code>phi_or_strip</code> represents strip ID.</p> <p>Parameters:</p> Name Type Description Default <code>tof_digi_id</code> <code>IntLike</code> <p>The TOF ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed TOF ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_tof_digi_id(\n    tof_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse TOF digi ID.\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number. `0,1,2` for scintillator endcap0, barrel, endcap1; `3,4` for MRPC endcap0, endcap1.\n    - `layer_or_module`: The scintillator layer or MRPC module number, based on the part number.\n    - `phi_or_strip`: The scintillator phi or MRPC strip ID, based on the part number.\n    - `end`: The readout end ID.\n\n    The return value is based on the part number.\n\n    Rows where `part &lt; 3` are scintillator and `layer_or_module` represents layer number, `phi_or_strip` represents phi number.\n\n    Rows where `part &gt;= 3` are MRPC and `layer_or_module` represents module number, `phi_or_strip` represents strip ID.\n\n    Parameters:\n        tof_digi_id: The TOF ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed TOF ID.\n\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(tof_digi_id, ak.Array):\n        tof_digi_id = ak.flatten(tof_digi_id)\n\n    part = digi_id.tof_id_to_part(tof_digi_id)\n    res = {\n        \"part\": part,\n        \"layer_or_module\": digi_id.tof_id_to_layer_or_module(tof_digi_id, part),\n        \"phi_or_strip\": digi_id.tof_id_to_phi_or_strip(tof_digi_id, part),\n        \"end\": digi_id.tof_id_to_end(tof_digi_id),\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_emc_digi_id","title":"<code>parse_emc_digi_id(emc_digi_id, with_pos=False)</code>","text":"<p>Parse EMC digi ID.</p> <p>When <code>emc_digi_id</code> is an <code>ak.Array</code>, the result is an <code>ak.Array</code>, otherwise it is a <code>dict</code>.</p> <p>Keys of the output:</p> <ul> <li><code>gid</code>: Global ID of the crystal.</li> <li><code>part</code>: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.</li> <li><code>theta</code>: Theta number.</li> <li><code>phi</code>: Phi number.</li> </ul> <p>Optional keys of the output when <code>with_pos</code> is <code>True</code>:</p> <ul> <li><code>front_center_x</code>: x position of the front center of the crystal.</li> <li><code>front_center_y</code>: y position of the front center of the crystal.</li> <li><code>front_center_z</code>: z position of the front center of the crystal.</li> <li><code>center_x</code>: x position of the center of the crystal.</li> <li><code>center_y</code>: y position of the center of the crystal.</li> <li><code>center_z</code>: z position of the center of the crystal.</li> </ul> <p>Info</p> <p>The 8 points of the crystal will not be returned here. If you need the 8 points of the crystal, use <code>emc_gid_to_point_x</code>, <code>emc_gid_to_point_y</code> and <code>emc_gid_to_point_z</code>.</p> <p>Parameters:</p> Name Type Description Default <code>emc_digi_id</code> <code>IntLike</code> <p>The EMC digi ID.</p> required <code>with_pos</code> <code>bool</code> <p>Whether to include the position information.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[IntLike, dict[str, IntLike]]</code> <p>The parsed EMC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_emc_digi_id(\n    emc_digi_id: IntLike,\n    with_pos: bool = False,\n) -&gt; Union[IntLike, dict[str, IntLike]]:\n    \"\"\"\n    Parse EMC digi ID.\n\n    When `emc_digi_id` is an `ak.Array`, the result is an `ak.Array`, otherwise it is a `dict`.\n\n    Keys of the output:\n\n    - `gid`: Global ID of the crystal.\n    - `part`: Part number, 0 for endcap0, 1 for barrel, 2 for endcap1.\n    - `theta`: Theta number.\n    - `phi`: Phi number.\n\n    Optional keys of the output when `with_pos` is `True`:\n\n    - `front_center_x`: x position of the front center of the crystal.\n    - `front_center_y`: y position of the front center of the crystal.\n    - `front_center_z`: z position of the front center of the crystal.\n    - `center_x`: x position of the center of the crystal.\n    - `center_y`: y position of the center of the crystal.\n    - `center_z`: z position of the center of the crystal.\n\n    !!! info\n        The 8 points of the crystal will not be returned here.\n        If you need the 8 points of the crystal, use `emc_gid_to_point_x`, `emc_gid_to_point_y`\n        and `emc_gid_to_point_z`.\n\n    Parameters:\n        emc_digi_id: The EMC digi ID.\n        with_pos: Whether to include the position information.\n\n    Returns:\n        The parsed EMC digi ID.\n\n    \"\"\"\n    part = digi_id.emc_id_to_module(emc_digi_id)\n    theta = digi_id.emc_id_to_theta(emc_digi_id)\n    phi = digi_id.emc_id_to_phi(emc_digi_id)\n    gid = get_emc_gid(part, theta, phi)\n    return parse_emc_gid(gid, with_pos)\n</code></pre>"},{"location":"api/pybes3/#pybes3.parse_muc_digi_id","title":"<code>parse_muc_digi_id(muc_digi_id, flat=False, library='ak')</code>","text":"<p>Parse MUC digi ID.</p> <p>If <code>library</code> is <code>ak</code>, return <code>ak.Record</code>. If <code>library</code> is <code>np</code>, return <code>dict[str, np.ndarray]</code>.</p> <p>Available keys of the output:</p> <ul> <li><code>part</code>: The part number.</li> <li><code>segment</code>: The segment number.</li> <li><code>layer</code>: The layer number.</li> <li><code>channel</code>: The channel number.</li> <li><code>gap</code>: The gap number, which is equivalent to layer number.</li> <li><code>strip</code>: The strip number, which is equivalent to channel number.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>muc_digi_id</code> <code>IntLike</code> <p>The MUC digi ID.</p> required <code>flat</code> <code>bool</code> <p>Whether to flatten the output.</p> <code>False</code> <code>library</code> <code>Literal['ak', 'np']</code> <p>The library to use as output.</p> <code>'ak'</code> <p>Returns:</p> Type Description <code>Union[Record, dict[str, ndarray], dict[str, int_]]</code> <p>The parsed MUC digi ID.</p> Source code in <code>src/pybes3/detectors/__init__.py</code> <pre><code>def parse_muc_digi_id(\n    muc_digi_id: IntLike,\n    flat: bool = False,\n    library: Literal[\"ak\", \"np\"] = \"ak\",\n) -&gt; Union[ak.Record, dict[str, np.ndarray], dict[str, np.int_]]:\n    \"\"\"\n    Parse MUC digi ID.\n\n    If `library` is `ak`, return `ak.Record`. If `library` is `np`, return `dict[str, np.ndarray]`.\n\n    Available keys of the output:\n\n    - `part`: The part number.\n    - `segment`: The segment number.\n    - `layer`: The layer number.\n    - `channel`: The channel number.\n    - `gap`: The gap number, which is equivalent to layer number.\n    - `strip`: The strip number, which is equivalent to channel number.\n\n    Parameters:\n        muc_digi_id: The MUC digi ID.\n        flat: Whether to flatten the output.\n        library: The library to use as output.\n\n    Returns:\n        The parsed MUC digi ID.\n    \"\"\"\n    if library not in [\"ak\", \"np\"]:\n        raise ValueError(f\"Unsupported library: {library}\")\n\n    if flat and isinstance(muc_digi_id, ak.Array):\n        muc_digi_id = ak.flatten(muc_digi_id)\n\n    part = digi_id.muc_id_to_part(muc_digi_id)\n    segment = digi_id.muc_id_to_segment(muc_digi_id)\n    layer = digi_id.muc_id_to_layer(muc_digi_id)\n    channel = digi_id.muc_id_to_channel(muc_digi_id)\n\n    res = {\n        \"part\": part,\n        \"segment\": segment,\n        \"layer\": layer,\n        \"channel\": channel,\n        \"gap\": layer,\n        \"strip\": channel,\n    }\n\n    if library == \"ak\":\n        return ak.zip(res)\n    else:\n        return res\n</code></pre>"},{"location":"api/pybes3/#tracks","title":"tracks","text":""},{"location":"api/pybes3/#pybes3.parse_helix","title":"<code>parse_helix(helix, library='auto')</code>","text":"<p>Parse helix parameters to physical parameters.</p> <p>Parameters:</p> Name Type Description Default <code>helix</code> <code>Union[Array, ndarray]</code> <p>helix parameters, the last dimension should be 5.</p> required <code>library</code> <code>Literal['ak', 'auto']</code> <p>the library to use, if \"auto\", return a dict when input is np.ndarray,             return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Union[Array, dict[str, ndarray]]</code> <p>parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position,             \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum,             \"charge\" for charge, \"r_trk\" for track radius.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>def parse_helix(\n    helix: Union[ak.Array, np.ndarray],\n    library: Literal[\"ak\", \"auto\"] = \"auto\",\n) -&gt; Union[ak.Array, dict[str, np.ndarray]]:\n    \"\"\"\n    Parse helix parameters to physical parameters.\n\n    Parameters:\n        helix: helix parameters, the last dimension should be 5.\n        library: the library to use, if \"auto\", return a dict when input is np.ndarray, \\\n            return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.\n\n    Returns:\n        parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position, \\\n            \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum, \\\n            \"charge\" for charge, \"r_trk\" for track radius.\n    \"\"\"\n\n    warnings.warn(\n        \"'parse_helix' is deprecated and will be removed in the future, \"\n        \"use 'helix_obj' and 'helix_awk' instead.\",\n        DeprecationWarning,\n    )\n\n    helix0 = helix[..., 0]\n    helix1 = helix[..., 1]\n    helix2 = helix[..., 2]\n    helix3 = helix[..., 3]\n    helix4 = helix[..., 4]\n\n    x = _helix01_to_x(helix0, helix1)\n    y = _helix01_to_y(helix0, helix1)\n    z = helix3\n    r = np.abs(helix0)\n\n    pt = _helix2_to_pt(helix2)\n    px = _pt_helix1_to_px(pt, helix1)\n    py = _pt_helix1_to_py(pt, helix1)\n    pz = pt * helix4\n    p = _pt_helix4_to_p(pt, helix4)\n    theta = _pz_p_to_theta(pz, p)\n    phi = np.arctan2(py, px)\n\n    charge = _helix2_to_charge(helix2)\n\n    r_trk = pt * (10 / 2.99792458)  # |pt| * [GeV/c] / 1[e] / 1[T] = |pt| * 10/3 [m]\n    r_trk = r_trk * 100  # to [cm]\n\n    res_dict = {\n        \"x\": x,\n        \"y\": y,\n        \"z\": z,\n        \"r\": r,\n        \"px\": px,\n        \"py\": py,\n        \"pz\": pz,\n        \"pt\": pt,\n        \"p\": p,\n        \"theta\": theta,\n        \"phi\": phi,\n        \"charge\": charge,\n        \"r_trk\": r_trk,\n    }\n\n    if isinstance(helix, ak.Array) or library == \"ak\":\n        return ak.zip(res_dict)\n    else:\n        return res_dict\n</code></pre>"},{"location":"api/pybes3.tracks/","title":"pybes3.tracks","text":""},{"location":"api/pybes3.tracks/#helix-operations","title":"Helix operations","text":""},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixObject","title":"<code>HelixObject</code>","text":"Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>class HelixObject:\n    def __init__(\n        self,\n        dr: float,\n        phi0: float,\n        kappa: float,\n        dz: float,\n        tanl: float,\n        *,\n        error: np.ndarray = None,\n        pivot: TypeObjPosition = (0, 0, 0),\n    ):\n        self.dr = float(dr)\n        self.phi0 = float(phi0)\n        self.kappa = float(kappa)\n        self.dz = float(dz)\n        self.tanl = float(tanl)\n        self.error = error\n        self.pivot = _regularize_obj_position(pivot)\n\n    @property\n    def radius(self) -&gt; float:\n        \"\"\"\n        Circular radius of the helix (in cm).\n        \"\"\"\n        return 1000 / 2.99792458 / np.abs(self.kappa)\n\n    @property\n    def momentum(self) -&gt; vector.MomentumObject3D:\n        \"\"\"\n        Momentum of the helix as a 3D vector.\n        Note that the momentum is relative to the pivot, so once the pivot is changed,\n        the momentum will also change accordingly.\n        \"\"\"\n        pt = 1 / abs(self.kappa)\n        pz = pt * self.tanl\n        phi = (self.phi0 + np.pi / 2) % (2 * np.pi)\n        return vector.obj(pt=pt, phi=phi, pz=pz)\n\n    @property\n    def position(self) -&gt; vector.VectorObject3D:\n        return vector.VectorObject3D(\n            x=self.dr * math.cos(self.phi0),\n            y=self.dr * math.sin(self.phi0),\n            z=self.dz,\n        )\n\n    @property\n    def charge(self) -&gt; int:\n        \"\"\"\n        Returns the charge of the helix.\n        \"\"\"\n        return 1 if self.kappa &gt; 1e-10 else -1 if self.kappa &lt; -1e-10 else 0\n\n    def change_pivot(self, *args):\n        \"\"\"\n        Change the pivot point of the helix.\n        The transformation refers to `Helix` class in `BOSS`.\n        \"\"\"\n        # transform helix parameters\n        r = self.radius\n\n        old_dr = self.dr\n        old_phi0 = self.phi0\n        old_dz = self.dz\n        tanl = self.tanl\n        kappa = self.kappa\n\n        old_pivot = self.pivot\n        new_pivot = _regularize_obj_position(args)\n\n        new_dr, new_phi0, new_dz, new_error = _change_pivot(\n            r=r,\n            old_dr=old_dr,\n            old_phi0=old_phi0,\n            old_dz=old_dz,\n            kappa=kappa,\n            tanl=tanl,\n            old_error=self.error,\n            old_pivot=old_pivot,\n            new_pivot=new_pivot,\n        )\n\n        return HelixObject(\n            dr=new_dr,\n            phi0=new_phi0,\n            kappa=kappa,\n            dz=new_dz,\n            tanl=tanl,\n            error=new_error,\n            pivot=new_pivot,\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"Bes3Helix(dr={self.dr:.3f}, phi0={self.phi0:.3f}, kappa={self.kappa:.3f}, tanl={self.tanl:.3f}, dz={self.dz:.3f})\"\n\n    def isclose(\n        self,\n        other: \"HelixObject\",\n        *,\n        rtol: float = 1e-5,\n        atol: float = 1e-8,\n        equal_nan: bool = False,\n    ) -&gt; bool:\n        if xor(\n            (self.error is not None),\n            (other.error is not None),\n        ):\n            warnings.warn(\n                \"One of the helix records has an error matrix, but the other does not. \"\n                \"Ignoring error matrix for isclose check.\",\n                UserWarning,\n            )\n\n        return _obj_isclose(self, other, rtol=rtol, atol=atol, equal_nan=equal_nan)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixObject.radius","title":"<code>radius</code>  <code>property</code>","text":"<p>Circular radius of the helix (in cm).</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixObject.momentum","title":"<code>momentum</code>  <code>property</code>","text":"<p>Momentum of the helix as a 3D vector. Note that the momentum is relative to the pivot, so once the pivot is changed, the momentum will also change accordingly.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixObject.charge","title":"<code>charge</code>  <code>property</code>","text":"<p>Returns the charge of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixObject.change_pivot","title":"<code>change_pivot(*args)</code>","text":"<p>Change the pivot point of the helix. The transformation refers to <code>Helix</code> class in <code>BOSS</code>.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>def change_pivot(self, *args):\n    \"\"\"\n    Change the pivot point of the helix.\n    The transformation refers to `Helix` class in `BOSS`.\n    \"\"\"\n    # transform helix parameters\n    r = self.radius\n\n    old_dr = self.dr\n    old_phi0 = self.phi0\n    old_dz = self.dz\n    tanl = self.tanl\n    kappa = self.kappa\n\n    old_pivot = self.pivot\n    new_pivot = _regularize_obj_position(args)\n\n    new_dr, new_phi0, new_dz, new_error = _change_pivot(\n        r=r,\n        old_dr=old_dr,\n        old_phi0=old_phi0,\n        old_dz=old_dz,\n        kappa=kappa,\n        tanl=tanl,\n        old_error=self.error,\n        old_pivot=old_pivot,\n        new_pivot=new_pivot,\n    )\n\n    return HelixObject(\n        dr=new_dr,\n        phi0=new_phi0,\n        kappa=kappa,\n        dz=new_dz,\n        tanl=tanl,\n        error=new_error,\n        pivot=new_pivot,\n    )\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.helix_obj","title":"<code>helix_obj(*args, **kwargs)</code>","text":"<pre><code>helix_obj(\n    dr: float,\n    phi0: float,\n    kappa: float,\n    dz: float,\n    tanl: float,\n    *,\n    error: Optional[np.ndarray] = None,\n    pivot: TypeObjPosition = (0, 0, 0)\n) -&gt; HelixObject\n</code></pre><pre><code>helix_obj(\n    *,\n    params: tuple[float, float, float, float, float],\n    error: Optional[np.ndarray] = None,\n    pivot: TypeObjPosition = (0, 0, 0)\n) -&gt; HelixObject\n</code></pre><pre><code>helix_obj(\n    *,\n    momentum: TypeObjMomentum,\n    position: TypeObjPosition,\n    charge: Literal[-1, 1],\n    error: Optional[np.ndarray] = None,\n    pivot: TypeObjPosition = (0, 0, 0)\n) -&gt; HelixObject\n</code></pre> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>def helix_obj(*args, **kwargs) -&gt; HelixObject:\n    pivot = _regularize_obj_position(kwargs.pop(\"pivot\", (0, 0, 0)))\n\n    error = kwargs.pop(\"error\", None)\n    if isinstance(error, ak.Array):\n        error = error.to_numpy()\n\n    # given helix parameters as positional arguments\n    if len(args) &gt; 0:\n        _check_kwargs_used_up(kwargs)\n        return HelixObject(*args, error=error, pivot=pivot)\n\n    # given helix parameters as keyword arguments\n    if \"dr\" in kwargs:\n        dr = kwargs.pop(\"dr\")\n        phi0 = kwargs.pop(\"phi0\")\n        kappa = kwargs.pop(\"kappa\")\n        dz = kwargs.pop(\"dz\")\n        tanl = kwargs.pop(\"tanl\")\n\n        _check_kwargs_used_up(kwargs)\n        return HelixObject(\n            dr=dr, phi0=phi0, kappa=kappa, dz=dz, tanl=tanl, pivot=pivot, error=error\n        )\n\n    # given helix parameters as a tuple\n    if \"params\" in kwargs:\n        params = kwargs.pop(\"params\")\n        if len(params) != 5:\n            raise ValueError(\"params must be a tuple of 5 elements\")\n\n        _check_kwargs_used_up(kwargs)\n        return HelixObject(*params, pivot=pivot, error=error)\n\n    # given momentum, position and charge\n    charge: Literal[-1, 1] = int(kwargs.pop(\"charge\"))\n    assert charge in (-1, 1), \"Charge must be either -1 or 1\"\n\n    momentum = _regularize_obj_momentum(kwargs.pop(\"momentum\"))\n    position = _regularize_obj_position(kwargs.pop(\"position\"))\n\n    # compute helix parameters\n    kappa = charge / momentum.pt\n    phi0 = (momentum.phi - np.pi / 2) % (2 * np.pi)\n\n    dist = (position - pivot).to_2D()\n    dr = dist.rho\n    if not np.isclose(dist.phi % (2 * np.pi), phi0):\n        dr *= -1\n\n    dz = position.z - pivot.z\n    tanl = momentum.pz / momentum.pt\n\n    _check_kwargs_used_up(kwargs)\n    return HelixObject(\n        dr=dr,\n        phi0=phi0,\n        kappa=kappa,\n        dz=dz,\n        tanl=tanl,\n        pivot=pivot,\n        error=error,\n    )\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.dr_phi0_to_x","title":"<code>dr_phi0_to_x(dr, phi0)</code>","text":"<p>Convert helix parameters to x location.</p> <p>Parameters:</p> Name Type Description Default <code>dr</code> <code>float</code> <p>helix[0] parameter, dr.</p> required <code>phi0</code> <code>float</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>x location of the helix.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef dr_phi0_to_x(dr: FloatLike, phi0: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameters to x location.\n\n    Parameters:\n        dr (float): helix[0] parameter, dr.\n        phi0 (float): helix[1] parameter, phi0.\n\n    Returns:\n        x location of the helix.\n    \"\"\"\n    return dr * np.cos(phi0)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.dr_phi0_to_y","title":"<code>dr_phi0_to_y(dr, phi0)</code>","text":"<p>Convert helix parameters to y location.</p> <p>Parameters:</p> Name Type Description Default <code>dr</code> <code>FloatLike</code> <p>helix[0] parameter, dr.</p> required <code>phi0</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>y location of the helix.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef dr_phi0_to_y(dr: FloatLike, phi0: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameters to y location.\n\n    Parameters:\n        dr: helix[0] parameter, dr.\n        phi0: helix[1] parameter, phi0.\n\n    Returns:\n        y location of the helix.\n    \"\"\"\n    return dr * np.sin(phi0)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.phi0_to_phi","title":"<code>phi0_to_phi(phi0)</code>","text":"<p>Convert helix parameter phi0 to momentum phi.</p> <p>Parameters:</p> Name Type Description Default <code>phi0</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>phi of the momentum vector.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef phi0_to_phi(phi0: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter phi0 to momentum phi.\n\n    Parameters:\n        phi0: helix[1] parameter, phi0.\n\n    Returns:\n        phi of the momentum vector.\n    \"\"\"\n    return (phi0 + np.pi / 2) % (2 * np.pi)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.kappa_to_pt","title":"<code>kappa_to_pt(kappa)</code>","text":"<p>Convert helix parameter to pt.</p> <p>Parameters:</p> Name Type Description Default <code>kappa</code> <code>FloatLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>pt of the helix.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef kappa_to_pt(kappa: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter to pt.\n\n    Parameters:\n        kappa: helix[2] parameter, kappa.\n\n    Returns:\n        pt of the helix.\n    \"\"\"\n    return 1 / np.abs(kappa)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.kappa_to_charge","title":"<code>kappa_to_charge(kappa)</code>","text":"<p>Convert helix parameter to charge.</p> <p>Parameters:</p> Name Type Description Default <code>kappa</code> <code>IntLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>charge of the helix.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef kappa_to_charge(kappa: IntLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter to charge.\n\n    Parameters:\n        kappa: helix[2] parameter, kappa.\n\n    Returns:\n        charge of the helix.\n    \"\"\"\n    return np.int8(1) if kappa &gt; 1e-10 else np.int8(-1) if kappa &lt; -1e-10 else np.int8(0)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.kappa_to_radius","title":"<code>kappa_to_radius(kappa)</code>","text":"<p>Convert helix parameter kappa to circular radius.</p> <p>Parameters:</p> Name Type Description Default <code>kappa</code> <code>FloatLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>circular radius of the helix in cm.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef kappa_to_radius(kappa: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter kappa to circular radius.\n\n    Parameters:\n        kappa: helix[2] parameter, kappa.\n\n    Returns:\n        circular radius of the helix in cm.\n    \"\"\"\n    return 1000 / 2.99792458 / np.abs(kappa)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardRecord","title":"<code>HelixAwkwardRecord</code>","text":"<p>               Bases: <code>Record</code></p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>class HelixAwkwardRecord(ak.Record):\n    @property\n    def momentum(self) -&gt; vector.MomentumObject3D:\n        \"\"\"\n        Returns the momentum of the helix as a 3D vector.\n\n        Returns:\n            vector.MomentumObject3D: The momentum vector of the helix.\n        \"\"\"\n        pt, phi, pz = _compute_momentum(self.kappa, self.tanl, self.phi0)\n        return ak.zip({\"pt\": pt, \"phi\": phi, \"pz\": pz}, with_name=\"Momentum3D\")\n\n    @property\n    def position(self) -&gt; vector.VectorObject3D:\n        \"\"\"\n        Returns the position of the helix at a given azimuthal angle.\n\n        Returns:\n            vector.VectorObject3D: The position vector of the helix.\n        \"\"\"\n        x, y, z = _compute_position(self.dr, self.phi0, self.dz)\n        return ak.zip({\"x\": x, \"y\": y, \"z\": z}, with_name=\"Vector3D\")\n\n    @property\n    def charge(self) -&gt; int:\n        \"\"\"\n        Returns the charge of the helix.\n\n        Returns:\n            int: The charge of the helix.\n        \"\"\"\n        return kappa_to_charge(self.kappa)\n\n    @property\n    def radius(self) -&gt; float:\n        \"\"\"\n        Returns the radius of the helix.\n\n        Returns:\n            float: The radius of the helix in mm.\n        \"\"\"\n        return kappa_to_radius(self.kappa)\n\n    def change_pivot(self, *args):\n        multi_trk = isinstance(self.pivot.x, ak.Array)\n\n        # regularize pivot\n        if multi_trk:\n            if len(args) == 3:\n                x, y, z = args\n                new_pivot = None\n            elif len(args) == 1:\n                new_pivot = args[0]\n                if isinstance(new_pivot, (vector.VectorObject3D, ak.Array, ak.Record)):\n                    x = new_pivot.x\n                    y = new_pivot.y\n                    z = new_pivot.z\n                    new_pivot = None\n                else:\n                    x = new_pivot[0]\n                    y = new_pivot[1]\n                    z = new_pivot[2]\n                    new_pivot = None\n            else:\n                raise ValueError(\n                    \"change_pivot requires either 3 arguments (x, y, z) or 1 argument (pivot).\"\n                )\n\n            if new_pivot is None:\n                x = (\n                    ak.ones_like(self.dr) * x\n                    if not isinstance(x, (ak.Array, ak.Record))\n                    else x\n                )\n                y = (\n                    ak.ones_like(self.dr) * y\n                    if not isinstance(y, (ak.Array, ak.Record))\n                    else y\n                )\n                z = (\n                    ak.ones_like(self.dr) * z\n                    if not isinstance(z, (ak.Array, ak.Record))\n                    else z\n                )\n                new_pivot = ak.Array({\"x\": x, \"y\": y, \"z\": z}, with_name=\"Vector3D\")\n\n            old_pivot_x = _flat_to_numpy(self.pivot.x)\n            old_pivot_y = _flat_to_numpy(self.pivot.y)\n            old_pivot_z = _flat_to_numpy(self.pivot.z)\n            old_pivot = vector.arr({\"x\": old_pivot_x, \"y\": old_pivot_y, \"z\": old_pivot_z})\n\n            new_pivot_x = _flat_to_numpy(new_pivot.x)\n            new_pivot_y = _flat_to_numpy(new_pivot.y)\n            new_pivot_z = _flat_to_numpy(new_pivot.z)\n            new_pivot = vector.arr({\"x\": new_pivot_x, \"y\": new_pivot_y, \"z\": new_pivot_z})\n\n        else:\n            new_pivot = _regularize_obj_position(args)\n            old_pivot = vector.obj(\n                x=self.pivot.x,\n                y=self.pivot.y,\n                z=self.pivot.z,\n            )\n\n        # do transformation\n        r = _flat_to_numpy(self.radius)\n        old_dr = _flat_to_numpy(self.dr)\n        old_phi0 = _flat_to_numpy(self.phi0)\n        old_dz = _flat_to_numpy(self.dz)\n        tanl = _flat_to_numpy(self.tanl)\n        kappa = _flat_to_numpy(self.kappa)\n\n        if \"error\" in self.fields:\n            old_error = (\n                _flat_to_numpy(self.error).reshape(-1, 5, 5)\n                if multi_trk\n                else _flat_to_numpy(self.error).reshape(5, 5)\n            )\n        else:\n            old_error = None\n\n        new_dr, new_phi0, new_dz, new_error = _change_pivot(\n            r=r,\n            old_dr=old_dr,\n            old_phi0=old_phi0,\n            old_dz=old_dz,\n            kappa=kappa,\n            tanl=tanl,\n            old_error=old_error,\n            old_pivot=old_pivot,\n            new_pivot=new_pivot,\n        )\n\n        res_dict = {\n            \"dr\": new_dr,\n            \"phi0\": new_phi0,\n            \"kappa\": kappa,\n            \"dz\": new_dz,\n            \"tanl\": tanl,\n            \"pivot\": ak.Record(\n                {\"x\": new_pivot.x, \"y\": new_pivot.y, \"z\": new_pivot.z},\n                with_name=\"Vector3D\",\n            ),\n        }\n\n        if new_error is not None:\n            res_dict[\"error\"] = new_error\n\n        res = ak.Record(res_dict, with_name=\"Bes3Helix\")\n\n        if multi_trk:\n            raw_shape = _extract_index(self.dr.layout)\n            for count in raw_shape:\n                res = ak.unflatten(res, count)\n\n        return res\n\n    def isclose(\n        self,\n        value: \"HelixAwkwardRecord\",\n        *,\n        rtol: float = 1e-5,\n        atol: float = 1e-8,\n        equal_nan: bool = False,\n    ) -&gt; bool:\n        \"\"\"\n        Check if two helix records are close to each other.\n\n        Args:\n            value (HelixAwkwardRecord): The helix record to compare with.\n\n        Returns:\n            bool: True if the records are close, False otherwise.\n        \"\"\"\n        if xor(\n            (\"error\" in self.fields),\n            (\"error\" in value.fields),\n        ):\n            warnings.warn(\n                \"One of the helix records has an error matrix, but the other does not. \"\n                \"Ignoring error matrix for isclose check.\",\n                UserWarning,\n            )\n\n        multi_trk = isinstance(self.pivot.x, ak.Array)\n        if multi_trk:\n            return _arr_isclose(self, value, rtol=rtol, atol=atol, equal_nan=equal_nan)\n        else:\n            return _obj_isclose(self, value, rtol=rtol, atol=atol, equal_nan=equal_nan)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardRecord.momentum","title":"<code>momentum</code>  <code>property</code>","text":"<p>Returns the momentum of the helix as a 3D vector.</p> <p>Returns:</p> Type Description <code>MomentumObject3D</code> <p>vector.MomentumObject3D: The momentum vector of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardRecord.position","title":"<code>position</code>  <code>property</code>","text":"<p>Returns the position of the helix at a given azimuthal angle.</p> <p>Returns:</p> Type Description <code>VectorObject3D</code> <p>vector.VectorObject3D: The position vector of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardRecord.charge","title":"<code>charge</code>  <code>property</code>","text":"<p>Returns the charge of the helix.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The charge of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardRecord.radius","title":"<code>radius</code>  <code>property</code>","text":"<p>Returns the radius of the helix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The radius of the helix in mm.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardRecord.isclose","title":"<code>isclose(value, *, rtol=1e-05, atol=1e-08, equal_nan=False)</code>","text":"<p>Check if two helix records are close to each other.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>HelixAwkwardRecord</code> <p>The helix record to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the records are close, False otherwise.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>def isclose(\n    self,\n    value: \"HelixAwkwardRecord\",\n    *,\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n    equal_nan: bool = False,\n) -&gt; bool:\n    \"\"\"\n    Check if two helix records are close to each other.\n\n    Args:\n        value (HelixAwkwardRecord): The helix record to compare with.\n\n    Returns:\n        bool: True if the records are close, False otherwise.\n    \"\"\"\n    if xor(\n        (\"error\" in self.fields),\n        (\"error\" in value.fields),\n    ):\n        warnings.warn(\n            \"One of the helix records has an error matrix, but the other does not. \"\n            \"Ignoring error matrix for isclose check.\",\n            UserWarning,\n        )\n\n    multi_trk = isinstance(self.pivot.x, ak.Array)\n    if multi_trk:\n        return _arr_isclose(self, value, rtol=rtol, atol=atol, equal_nan=equal_nan)\n    else:\n        return _obj_isclose(self, value, rtol=rtol, atol=atol, equal_nan=equal_nan)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray","title":"<code>HelixAwkwardArray</code>","text":"<p>               Bases: <code>Array</code></p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>class HelixAwkwardArray(ak.Array):\n    @property\n    def momentum(self) -&gt; vec_ak.MomentumAwkward3D:\n        \"\"\"\n        Returns the momentum of the helix as an awkward array of 3D vectors.\n\n        Returns:\n            vector.MomentumNumpy3D: The momentum vectors of the helix.\n        \"\"\"\n        pt, phi, pz = _compute_momentum(self.kappa, self.tanl, self.phi0)\n        return ak.zip({\"pt\": pt, \"phi\": phi, \"pz\": pz}, with_name=\"Momentum3D\")\n\n    @property\n    def position(self) -&gt; vec_ak.VectorAwkward3D:\n        \"\"\"\n        Returns the position of the helix at a given azimuthal angle as an awkward array of 3D vectors.\n\n        Returns:\n            vector.VectorNumpy3D: The position vectors of the helix.\n        \"\"\"\n        x, y, z = _compute_position(self.dr, self.phi0, self.dz)\n        return ak.zip({\"x\": x, \"y\": y, \"z\": z}, with_name=\"Vector3D\")\n\n    @property\n    def charge(self) -&gt; ak.Array:\n        \"\"\"\n        Returns the charge of the helix as an awkward array.\n\n        Returns:\n            ak.Array: The charge of the helix.\n        \"\"\"\n        return kappa_to_charge(self.kappa)\n\n    @property\n    def radius(self) -&gt; ak.Array:\n        \"\"\"\n        Returns the radius of the helix as an awkward array.\n\n        Returns:\n            ak.Array: The radius of the helix in mm.\n        \"\"\"\n        return kappa_to_radius(self.kappa)\n\n    def change_pivot(self, *args) -&gt; \"HelixAwkwardArray\":\n        \"\"\"\n        Changes the pivot point of the helix.\n        \"\"\"\n        if len(args) == 3:\n            x, y, z = args\n            pivot = None\n        elif len(args) == 1:\n            pivot = args[0]\n            if isinstance(pivot, vector.VectorObject3D):\n                x = pivot.x\n                y = pivot.y\n                z = pivot.z\n                pivot = None\n            elif not isinstance(pivot, ak.Array):\n                x = pivot[0]\n                y = pivot[1]\n                z = pivot[2]\n                pivot = None\n        else:\n            raise ValueError(\n                \"change_pivot requires either 3 arguments (x, y, z) or 1 argument (pivot).\"\n            )\n\n        if pivot is None:\n            x = ak.ones_like(self.dr) * x if not isinstance(x, ak.Array) else x\n            y = ak.ones_like(self.dr) * y if not isinstance(y, ak.Array) else y\n            z = ak.ones_like(self.dr) * z if not isinstance(z, ak.Array) else z\n            pivot = ak.Array({\"x\": x, \"y\": y, \"z\": z}, with_name=\"Vector3D\")\n\n        raw_shape = _extract_index(self.dr.layout)\n\n        r = _flat_to_numpy(self.radius)\n\n        old_dr = _flat_to_numpy(self.dr)\n        old_phi0 = _flat_to_numpy(self.phi0)\n        old_dz = _flat_to_numpy(self.dz)\n        tanl = _flat_to_numpy(self.tanl)\n        kappa = _flat_to_numpy(self.kappa)\n\n        old_pivot_x = _flat_to_numpy(self.pivot.x)\n        old_pivot_y = _flat_to_numpy(self.pivot.y)\n        old_pivot_z = _flat_to_numpy(self.pivot.z)\n        old_pivot = vector.arr({\"x\": old_pivot_x, \"y\": old_pivot_y, \"z\": old_pivot_z})\n\n        new_pivot_x = _flat_to_numpy(pivot.x)\n        new_pivot_y = _flat_to_numpy(pivot.y)\n        new_pivot_z = _flat_to_numpy(pivot.z)\n        new_pivot = vector.arr({\"x\": new_pivot_x, \"y\": new_pivot_y, \"z\": new_pivot_z})\n\n        old_error = (\n            _flat_to_numpy(self.error).reshape(-1, 5, 5) if \"error\" in self.fields else None\n        )\n\n        new_dr, new_phi0, new_dz, new_error = _change_pivot(\n            r=r,\n            old_dr=old_dr,\n            old_phi0=old_phi0,\n            old_dz=old_dz,\n            kappa=kappa,\n            tanl=tanl,\n            old_error=old_error,\n            old_pivot=old_pivot,\n            new_pivot=new_pivot,\n        )\n\n        res_dict = {\n            \"dr\": new_dr,\n            \"phi0\": new_phi0,\n            \"kappa\": kappa,\n            \"tanl\": tanl,\n            \"dz\": new_dz,\n            \"pivot\": ak.zip(\n                {\"x\": new_pivot.x, \"y\": new_pivot.y, \"z\": new_pivot.z},\n                with_name=\"Vector3D\",\n            ),\n        }\n\n        if new_error is not None:\n            res_dict[\"error\"] = new_error\n\n        raw_shape = _extract_index(self.dr.layout)\n        res = ak.Array(res_dict, with_name=\"Bes3Helix\")\n\n        for count in raw_shape:\n            res = ak.unflatten(res, count)\n\n        return res\n\n    def isclose(\n        self,\n        other: \"HelixAwkwardRecord\",\n        *,\n        rtol: float = 1e-5,\n        atol: float = 1e-8,\n        equal_nan: bool = False,\n    ) -&gt; ak.Array:\n        \"\"\"\n        Check if two helix records are close to each other.\n\n        Args:\n            other (HelixAwkwardRecord): The helix record to compare with.\n\n        Returns:\n            ak.Array: A boolean array indicating if the records are close.\n        \"\"\"\n        if xor(\n            (\"error\" in self.fields),\n            (\"error\" in other.fields),\n        ):\n            warnings.warn(\n                \"One of the helix records has an error matrix, but the other does not. \"\n                \"Ignoring error matrix for isclose check.\",\n                UserWarning,\n            )\n\n        return _arr_isclose(self, other, rtol=rtol, atol=atol, equal_nan=equal_nan)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray.momentum","title":"<code>momentum</code>  <code>property</code>","text":"<p>Returns the momentum of the helix as an awkward array of 3D vectors.</p> <p>Returns:</p> Type Description <code>MomentumAwkward3D</code> <p>vector.MomentumNumpy3D: The momentum vectors of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray.position","title":"<code>position</code>  <code>property</code>","text":"<p>Returns the position of the helix at a given azimuthal angle as an awkward array of 3D vectors.</p> <p>Returns:</p> Type Description <code>VectorAwkward3D</code> <p>vector.VectorNumpy3D: The position vectors of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray.charge","title":"<code>charge</code>  <code>property</code>","text":"<p>Returns the charge of the helix as an awkward array.</p> <p>Returns:</p> Type Description <code>Array</code> <p>ak.Array: The charge of the helix.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray.radius","title":"<code>radius</code>  <code>property</code>","text":"<p>Returns the radius of the helix as an awkward array.</p> <p>Returns:</p> Type Description <code>Array</code> <p>ak.Array: The radius of the helix in mm.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray.change_pivot","title":"<code>change_pivot(*args)</code>","text":"<p>Changes the pivot point of the helix.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>def change_pivot(self, *args) -&gt; \"HelixAwkwardArray\":\n    \"\"\"\n    Changes the pivot point of the helix.\n    \"\"\"\n    if len(args) == 3:\n        x, y, z = args\n        pivot = None\n    elif len(args) == 1:\n        pivot = args[0]\n        if isinstance(pivot, vector.VectorObject3D):\n            x = pivot.x\n            y = pivot.y\n            z = pivot.z\n            pivot = None\n        elif not isinstance(pivot, ak.Array):\n            x = pivot[0]\n            y = pivot[1]\n            z = pivot[2]\n            pivot = None\n    else:\n        raise ValueError(\n            \"change_pivot requires either 3 arguments (x, y, z) or 1 argument (pivot).\"\n        )\n\n    if pivot is None:\n        x = ak.ones_like(self.dr) * x if not isinstance(x, ak.Array) else x\n        y = ak.ones_like(self.dr) * y if not isinstance(y, ak.Array) else y\n        z = ak.ones_like(self.dr) * z if not isinstance(z, ak.Array) else z\n        pivot = ak.Array({\"x\": x, \"y\": y, \"z\": z}, with_name=\"Vector3D\")\n\n    raw_shape = _extract_index(self.dr.layout)\n\n    r = _flat_to_numpy(self.radius)\n\n    old_dr = _flat_to_numpy(self.dr)\n    old_phi0 = _flat_to_numpy(self.phi0)\n    old_dz = _flat_to_numpy(self.dz)\n    tanl = _flat_to_numpy(self.tanl)\n    kappa = _flat_to_numpy(self.kappa)\n\n    old_pivot_x = _flat_to_numpy(self.pivot.x)\n    old_pivot_y = _flat_to_numpy(self.pivot.y)\n    old_pivot_z = _flat_to_numpy(self.pivot.z)\n    old_pivot = vector.arr({\"x\": old_pivot_x, \"y\": old_pivot_y, \"z\": old_pivot_z})\n\n    new_pivot_x = _flat_to_numpy(pivot.x)\n    new_pivot_y = _flat_to_numpy(pivot.y)\n    new_pivot_z = _flat_to_numpy(pivot.z)\n    new_pivot = vector.arr({\"x\": new_pivot_x, \"y\": new_pivot_y, \"z\": new_pivot_z})\n\n    old_error = (\n        _flat_to_numpy(self.error).reshape(-1, 5, 5) if \"error\" in self.fields else None\n    )\n\n    new_dr, new_phi0, new_dz, new_error = _change_pivot(\n        r=r,\n        old_dr=old_dr,\n        old_phi0=old_phi0,\n        old_dz=old_dz,\n        kappa=kappa,\n        tanl=tanl,\n        old_error=old_error,\n        old_pivot=old_pivot,\n        new_pivot=new_pivot,\n    )\n\n    res_dict = {\n        \"dr\": new_dr,\n        \"phi0\": new_phi0,\n        \"kappa\": kappa,\n        \"tanl\": tanl,\n        \"dz\": new_dz,\n        \"pivot\": ak.zip(\n            {\"x\": new_pivot.x, \"y\": new_pivot.y, \"z\": new_pivot.z},\n            with_name=\"Vector3D\",\n        ),\n    }\n\n    if new_error is not None:\n        res_dict[\"error\"] = new_error\n\n    raw_shape = _extract_index(self.dr.layout)\n    res = ak.Array(res_dict, with_name=\"Bes3Helix\")\n\n    for count in raw_shape:\n        res = ak.unflatten(res, count)\n\n    return res\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.HelixAwkwardArray.isclose","title":"<code>isclose(other, *, rtol=1e-05, atol=1e-08, equal_nan=False)</code>","text":"<p>Check if two helix records are close to each other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HelixAwkwardRecord</code> <p>The helix record to compare with.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>ak.Array: A boolean array indicating if the records are close.</p> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>def isclose(\n    self,\n    other: \"HelixAwkwardRecord\",\n    *,\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n    equal_nan: bool = False,\n) -&gt; ak.Array:\n    \"\"\"\n    Check if two helix records are close to each other.\n\n    Args:\n        other (HelixAwkwardRecord): The helix record to compare with.\n\n    Returns:\n        ak.Array: A boolean array indicating if the records are close.\n    \"\"\"\n    if xor(\n        (\"error\" in self.fields),\n        (\"error\" in other.fields),\n    ):\n        warnings.warn(\n            \"One of the helix records has an error matrix, but the other does not. \"\n            \"Ignoring error matrix for isclose check.\",\n            UserWarning,\n        )\n\n    return _arr_isclose(self, other, rtol=rtol, atol=atol, equal_nan=equal_nan)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.helix.helix_awk","title":"<code>helix_awk(*args, **kwargs)</code>","text":"<pre><code>helix_awk(\n    helix: ak.Array,\n    error: Optional[ak.Array] = None,\n    pivot: TypeAwkPosition = (0, 0, 0),\n) -&gt; HelixAwkwardArray\n</code></pre><pre><code>helix_awk(\n    *,\n    dr: ak.Array,\n    phi0: ak.Array,\n    kappa: ak.Array,\n    dz: ak.Array,\n    tanl: ak.Array,\n    error: Optional[ak.Array] = None,\n    pivot: TypeAwkPosition = (0, 0, 0)\n) -&gt; HelixAwkwardArray\n</code></pre><pre><code>helix_awk(\n    *,\n    momentum: ak.Array,\n    position: ak.Array,\n    charge: Union[Literal[-1, 1], ak.Array],\n    error: Optional[ak.Array] = None,\n    pivot: TypeAwkPosition = (0, 0, 0)\n) -&gt; HelixAwkwardArray\n</code></pre> Source code in <code>src/pybes3/tracks/helix.py</code> <pre><code>def helix_awk(*args, **kwargs) -&gt; HelixAwkwardArray:\n    error = None\n    pivot = (0, 0, 0)\n\n    if len(args) &gt; 0:\n        helix = args[0]\n\n        if len(args) &gt; 1:\n            error = args[1]\n            if \"error\" in kwargs:\n                raise ValueError(\"Cannot pass both helix and error as positional arguments.\")\n\n        if len(args) &gt; 2:\n            pivot = args[2]\n            if \"pivot\" in kwargs:\n                raise ValueError(\"Cannot pass both helix and pivot as positional arguments.\")\n\n        dr = helix[..., 0]\n        phi0 = helix[..., 1]\n        kappa = helix[..., 2]\n        dz = helix[..., 3]\n        tanl = helix[..., 4]\n\n    elif \"helix\" in kwargs:\n        helix = kwargs.pop(\"helix\")\n\n        dr = helix[..., 0]\n        phi0 = helix[..., 1]\n        kappa = helix[..., 2]\n        dz = helix[..., 3]\n        tanl = helix[..., 4]\n\n    elif \"dr\" in kwargs:\n        dr = kwargs.pop(\"dr\")\n        phi0 = kwargs.pop(\"phi0\")\n        kappa = kwargs.pop(\"kappa\")\n        dz = kwargs.pop(\"dz\")\n        tanl = kwargs.pop(\"tanl\")\n\n    else:\n        momentum = kwargs.pop(\"momentum\")\n        position = kwargs.pop(\"position\")\n        charge = kwargs.pop(\"charge\")\n\n        pivot = kwargs.pop(\"pivot\", (0, 0, 0))\n        if not isinstance(pivot, ak.Array):\n            pivot = _regularize_obj_position(pivot)\n\n        # compute helix parameters\n        kappa = charge / momentum.pt\n        phi0 = (momentum.phi - np.pi / 2) % (2 * np.pi)\n\n        dist = (position - pivot).to_2D()\n        dr = _fix_dr_sign(dist.rho, phi0, dist.phi)\n\n        dz = position.z - pivot.z\n        tanl = momentum.pz / momentum.pt\n\n    error = kwargs.pop(\"error\", error)\n    pivot = kwargs.pop(\"pivot\", pivot)\n\n    if not isinstance(pivot, ak.Array):\n        pivot = _regularize_obj_position(pivot)\n\n        x0 = ak.ones_like(dr) * pivot.x\n        y0 = ak.ones_like(dr) * pivot.y\n        z0 = ak.ones_like(dr) * pivot.z\n        pivot = ak.zip({\"x\": x0, \"y\": y0, \"z\": z0}, with_name=\"Vector3D\")\n\n    res_dict = {\n        \"dr\": dr,\n        \"phi0\": phi0,\n        \"kappa\": kappa,\n        \"dz\": dz,\n        \"tanl\": tanl,\n        \"pivot\": pivot,\n    }\n\n    if error is not None:\n        res_dict[\"error\"] = error\n\n    _check_kwargs_used_up(kwargs)\n\n    raw_shape = _extract_index(dr.layout)\n    return ak.zip(res_dict, depth_limit=len(raw_shape) + 1, with_name=\"Bes3Helix\")\n</code></pre>"},{"location":"api/pybes3.tracks/#old-helix","title":"Old helix","text":"<p>Deprecated</p> <p>This component is deprecated and will be removed in the future. Please use the new <code>pybes3.tracks.helix</code> module instead.</p>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix.parse_helix","title":"<code>parse_helix(helix, library='auto')</code>","text":"<p>Parse helix parameters to physical parameters.</p> <p>Parameters:</p> Name Type Description Default <code>helix</code> <code>Union[Array, ndarray]</code> <p>helix parameters, the last dimension should be 5.</p> required <code>library</code> <code>Literal['ak', 'auto']</code> <p>the library to use, if \"auto\", return a dict when input is np.ndarray,             return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Union[Array, dict[str, ndarray]]</code> <p>parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position,             \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum,             \"charge\" for charge, \"r_trk\" for track radius.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>def parse_helix(\n    helix: Union[ak.Array, np.ndarray],\n    library: Literal[\"ak\", \"auto\"] = \"auto\",\n) -&gt; Union[ak.Array, dict[str, np.ndarray]]:\n    \"\"\"\n    Parse helix parameters to physical parameters.\n\n    Parameters:\n        helix: helix parameters, the last dimension should be 5.\n        library: the library to use, if \"auto\", return a dict when input is np.ndarray, \\\n            return an ak.Array when input is ak.Array. If \"ak\", return an ak.Array.\n\n    Returns:\n        parsed physical parameters. \"x\", \"y\", \"z\", \"r\" for position, \\\n            \"pt\", \"px\", \"py\", \"pz\", \"p\", \"theta\", \"phi\" for momentum, \\\n            \"charge\" for charge, \"r_trk\" for track radius.\n    \"\"\"\n\n    warnings.warn(\n        \"'parse_helix' is deprecated and will be removed in the future, \"\n        \"use 'helix_obj' and 'helix_awk' instead.\",\n        DeprecationWarning,\n    )\n\n    helix0 = helix[..., 0]\n    helix1 = helix[..., 1]\n    helix2 = helix[..., 2]\n    helix3 = helix[..., 3]\n    helix4 = helix[..., 4]\n\n    x = _helix01_to_x(helix0, helix1)\n    y = _helix01_to_y(helix0, helix1)\n    z = helix3\n    r = np.abs(helix0)\n\n    pt = _helix2_to_pt(helix2)\n    px = _pt_helix1_to_px(pt, helix1)\n    py = _pt_helix1_to_py(pt, helix1)\n    pz = pt * helix4\n    p = _pt_helix4_to_p(pt, helix4)\n    theta = _pz_p_to_theta(pz, p)\n    phi = np.arctan2(py, px)\n\n    charge = _helix2_to_charge(helix2)\n\n    r_trk = pt * (10 / 2.99792458)  # |pt| * [GeV/c] / 1[e] / 1[T] = |pt| * 10/3 [m]\n    r_trk = r_trk * 100  # to [cm]\n\n    res_dict = {\n        \"x\": x,\n        \"y\": y,\n        \"z\": z,\n        \"r\": r,\n        \"px\": px,\n        \"py\": py,\n        \"pz\": pz,\n        \"pt\": pt,\n        \"p\": p,\n        \"theta\": theta,\n        \"phi\": phi,\n        \"charge\": charge,\n        \"r_trk\": r_trk,\n    }\n\n    if isinstance(helix, ak.Array) or library == \"ak\":\n        return ak.zip(res_dict)\n    else:\n        return res_dict\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._helix01_to_x","title":"<code>_helix01_to_x(helix0, helix1)</code>","text":"<p>Convert helix parameters to x location.</p> <p>Parameters:</p> Name Type Description Default <code>helix0</code> <code>FloatLike</code> <p>helix[0] parameter, dr.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>x location of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _helix01_to_x(helix0: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameters to x location.\n\n    Parameters:\n        helix0: helix[0] parameter, dr.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        x location of the helix.\n    \"\"\"\n    return helix0 * np.cos(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._helix01_to_y","title":"<code>_helix01_to_y(helix0, helix1)</code>","text":"<p>Convert helix parameters to y location.</p> <p>Parameters:</p> Name Type Description Default <code>helix0</code> <code>FloatLike</code> <p>helix[0] parameter, dr.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>y location of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _helix01_to_y(helix0: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameters to y location.\n\n    Parameters:\n        helix0: helix[0] parameter, dr.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        y location of the helix.\n    \"\"\"\n    return helix0 * np.sin(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._helix2_to_pt","title":"<code>_helix2_to_pt(helix2)</code>","text":"<p>Convert helix parameter to pt.</p> <p>Parameters:</p> Name Type Description Default <code>helix2</code> <code>FloatLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>pt of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _helix2_to_pt(\n    helix2: FloatLike,\n) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter to pt.\n\n    Parameters:\n        helix2: helix[2] parameter, kappa.\n\n    Returns:\n        pt of the helix.\n    \"\"\"\n    return 1 / np.abs(helix2)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._helix2_to_charge","title":"<code>_helix2_to_charge(helix2)</code>","text":"<p>Convert helix parameter to charge.</p> <p>Parameters:</p> Name Type Description Default <code>helix2</code> <code>FloatLike</code> <p>helix[2] parameter, kappa.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>charge of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _helix2_to_charge(\n    helix2: FloatLike,\n) -&gt; FloatLike:\n    \"\"\"\n    Convert helix parameter to charge.\n\n    Parameters:\n        helix2: helix[2] parameter, kappa.\n\n    Returns:\n        charge of the helix.\n    \"\"\"\n    if -1e-10 &lt; helix2 &lt; 1e-10:\n        return np.int8(0)\n    return np.int8(1) if helix2 &gt; 0 else np.int8(-1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._pt_helix1_to_px","title":"<code>_pt_helix1_to_px(pt, helix1)</code>","text":"<p>Convert pt and helix1 to px.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>FloatLike</code> <p>pt of the helix.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>px of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _pt_helix1_to_px(pt: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert pt and helix1 to px.\n\n    Parameters:\n        pt: pt of the helix.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        px of the helix.\n    \"\"\"\n    return -pt * np.sin(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._pt_helix1_to_py","title":"<code>_pt_helix1_to_py(pt, helix1)</code>","text":"<p>Convert pt and helix1 to py.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>FloatLike</code> <p>pt of the helix.</p> required <code>helix1</code> <code>FloatLike</code> <p>helix[1] parameter, phi0.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>py of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _pt_helix1_to_py(pt: FloatLike, helix1: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert pt and helix1 to py.\n\n    Parameters:\n        pt: pt of the helix.\n        helix1: helix[1] parameter, phi0.\n\n    Returns:\n        py of the helix.\n    \"\"\"\n    return pt * np.cos(helix1)\n</code></pre>"},{"location":"api/pybes3.tracks/#pybes3.tracks.old_helix._pt_helix4_to_p","title":"<code>_pt_helix4_to_p(pt, helix4)</code>","text":"<p>Convert pt and helix4 to p.</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>FloatLike</code> <p>pt of the helix.</p> required <code>helix4</code> <code>FloatLike</code> <p>helix[4] parameter, tanl.</p> required <p>Returns:</p> Type Description <code>FloatLike</code> <p>p of the helix.</p> Source code in <code>src/pybes3/tracks/old_helix.py</code> <pre><code>@nb.vectorize(cache=True)\ndef _pt_helix4_to_p(pt: FloatLike, helix4: FloatLike) -&gt; FloatLike:\n    \"\"\"\n    Convert pt and helix4 to p.\n\n    Parameters:\n        pt: pt of the helix.\n        helix4: helix[4] parameter, tanl.\n\n    Returns:\n        p of the helix.\n    \"\"\"\n    return pt * np.sqrt(1 + helix4**2)\n</code></pre>"},{"location":"user-manual/bes3-data-reading/","title":"BES3 Data Reading","text":""},{"location":"user-manual/bes3-data-reading/#read-root-file-rtraw-dst-rec","title":"Read ROOT file (rtraw, dst, rec)","text":"<p>To make <code>uproot</code> know about BES3 ROOT files,  call <code>pybes3.wrap_uproot()</code> before opening any file:</p> <pre><code>&gt;&gt;&gt; import uproot\n&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; p3.wrap_uproot()\n</code></pre> <p>Then, open file as using <code>uproot</code>:</p> <pre><code>&gt;&gt;&gt; f = uproot.open(\"test.rtraw\")\n&gt;&gt;&gt; evt = f[\"Event\"]\n</code></pre> <p>There is a shorthand:</p> <pre><code>&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; f = p3.open(\"test.rtraw\") # will automatically call `pybes3.wrap_uproot()`\n&gt;&gt;&gt; evt = f[\"Event\"]\n</code></pre> <p>Print information about this \"event\" tree:</p> <pre><code>&gt;&gt;&gt; evt.show(name_width=40)\nname                                     | typename                 | interpretation                \n-----------------------------------------+--------------------------+-------------------------------\nTEvtHeader                               | TEvtHeader               | AsGroup(&lt;TBranchElement 'TE...\nTEvtHeader/m_eventId                     | int32_t                  | AsDtype('&gt;i4')\nTEvtHeader/m_runId                       | int32_t                  | AsDtype('&gt;i4')\n...\nTMcEvent                                 | TMcEvent                 | AsGroup(&lt;TBranchElement 'TM...\nTMcEvent/m_mdcMcHitCol                   | BES::TObjArray&lt;TMdcMc&gt;   | BES::As(BES::TObjArray&lt;TMdc...\nTMcEvent/m_emcMcHitCol                   | BES::TObjArray&lt;TEmcMc&gt;   | BES::As(BES::TObjArray&lt;TEmc...\nTMcEvent/m_tofMcHitCol                   | BES::TObjArray&lt;TTofMc&gt;   | BES::As(BES::TObjArray&lt;TTof...\nTMcEvent/m_mucMcHitCol                   | BES::TObjArray&lt;TMucMc&gt;   | BES::As(BES::TObjArray&lt;TMuc...\nTMcEvent/m_mcParticleCol                 | BES::TObjArray&lt;TMcPar... | BES::As(BES::TObjArray&lt;TMcP...\nTDigiEvent                               | TDigiEvent               | AsGroup(&lt;TBranchElement 'TD...\nTDigiEvent/m_fromMc                      | bool                     | AsDtype('bool')\n...\n</code></pre> <p>To read <code>TMcEvent</code> (Note: use <code>arrays()</code> instead of <code>array()</code> here):</p> <pre><code>&gt;&gt;&gt; mc_evt = evt[\"TMcEvent\"].arrays()\n&gt;&gt;&gt; mc_evt.fields\n['m_mdcMcHitCol', 'm_emcMcHitCol', 'm_tofMcHitCol', 'm_mucMcHitCol', 'm_mcParticleCol']\n</code></pre> <p>Now go to event 0:</p> <pre><code>&gt;&gt;&gt; evt0 = mc_evt[0]\n&gt;&gt;&gt; evt0.m_mcParticleCol.m_particleID\n&lt;Array [23, 4, -4, 91, 443, 11, ..., 111, 211, -211, 22, 22] type='12 * int32'&gt;\n\n&gt;&gt;&gt; mc_evt[0].m_mcParticleCol.m_eInitialMomentum\n&lt;Array [3.1, 1.55, 1.55, 3.1, ..., 1.23, 0.178, 1.28] type='12 * float64'&gt;\n</code></pre> <p>This indicates that in event 0, there are 12 MC particles. Their PDGIDs are <code>23, 4, -3, ...</code> and initial energies are <code>3.1, 1.55, 1.55, ... (GeV)</code>.</p> <p>It is recommended that only read the branches you need, otherwise your memory may overflow. </p> <p>To read a specific branch (Note: use <code>array()</code> instead of <code>arrays()</code> here):</p> <pre><code>&gt;&gt;&gt; pdgid_arr = evt[\"TMcEvent/m_mcParticleCol/m_particleID\"].array()\n&gt;&gt;&gt; e_init_arr = evt[\"TMcEvent/m_mcParticleCol/m_eInitialMomentum\"].array()\n</code></pre> <p>or you can retrieve branches from <code>mc_evt</code>:</p> <pre><code>&gt;&gt;&gt; pdgid_arr = mc_evt[\"m_mcParticleCol/m_particleID\"].array()\n&gt;&gt;&gt; e_init_arr = mc_evt[\"m_mcParticleCol/m_eInitialMomentum\"].array()\n</code></pre>"},{"location":"user-manual/bes3-data-reading/#read-raw-data-file","title":"Read raw data file","text":"<p>BES3 raw data files contain only digits information. To read a raw data file, use <code>pybes3.open_raw</code>:</p> <pre><code>&gt;&gt;&gt; import pybes3 as p3\n&gt;&gt;&gt; reader = p3.open_raw(\"/bes3fs/offline/data/raw/round17/231117/run_0079017_All_file001_SFO-1.raw\")\n&gt;&gt;&gt; reader\nBesRawReader\n- File: /bes3fs/offline/data/raw/round17/231117/run_0079017_All_file001_SFO-1.raw\n- Run Number: 79017\n- Entries: 100112\n- File Size: 2010 MB\n</code></pre> <p>To read all data out:</p> <pre><code>&gt;&gt;&gt; all_digi = reader.arrays()\n&gt;&gt;&gt; all_digi\n&lt;Array [{evt_header: {...}, ...}, ..., {...}] type='100112 * {evt_header: {...'&gt;\n&gt;&gt;&gt; all_digi.fields\n['evt_header', 'mdc', 'tof', 'emc', 'muc']\n&gt;&gt;&gt; all_digi.mdc.fields\n['id', 'adc', 'tdc', 'overflow']\n</code></pre> <p>To only read some sub-detectors:</p> <pre><code>&gt;&gt;&gt; mdc_tof_digi = reader.arrays(sub_detectors=['mdc', 'tof']) # 'emc', 'muc' are also available\n&gt;&gt;&gt; mdc_tof_digi.fields\n['evt_header', 'mdc', 'tof']\n</code></pre> <p>To read part of file:</p> <pre><code>&gt;&gt;&gt; some_digi = reader.arrays(n_blocks=1000)\n&gt;&gt;&gt; some_digi\n&lt;Array [{evt_header: {...}, ...}, ..., {...}] type='1000 * {evt_header: {ev...'&gt;\n</code></pre> <p>Info</p> <p><code>n_blocks</code> instead of <code>n_entries</code> is used here because only data blocks are continuous in memory. Most of the time, there is one event in a data block.</p> <p>Warning</p> <p>By so far, <code>besio</code> can only read original raw digi data without any T-Q matching or post-processing.</p>"},{"location":"user-manual/digi-identifier/","title":"Digi Identifier","text":"<p>When reading <code>TDigiEvent</code>, the <code>m_intId</code> field in <code>mdc</code>, <code>tof</code>, <code>emc</code>, <code>muc</code>, <code>cgem</code> branches are the electronics readout id (TEID), also known as <code>Identifier</code> in <code>BOSS</code>. <code>pybes3</code> provides methods to parse and calculate the digi ID for each detector.</p>"},{"location":"user-manual/digi-identifier/#digi-array-parsing","title":"Digi array parsing","text":"<p>Info</p> <p>By so far, only MDC and EMC digi parsing is supported. Whole digi parsing for other detectors is still under development. If you need to parse digi ID for other detectors, use the standalone digi ID parsing methods.</p> <pre><code>import pybes3 as p3\n\n# read raw digi array\nmdc_digi = p3.open(\"test.rtraw\")[\"Event/TDigiEvent/m_mdcDigiCol\"].array()\n\n# parse whole digi array\nmdc_digi = p3.parse_mdc_digi(mdc_digi)\n</code></pre>"},{"location":"user-manual/digi-identifier/#standalone-digi-id-parsing","title":"Standalone digi-ID parsing","text":"<p>When parsing whole digi array is not necesarry/supported, use <code>parse_xxx_digi_id</code> methods where <code>xxx</code> is the detector name (<code>cgem</code>, <code>mdc</code>, <code>tof</code>, <code>emc</code>, <code>muc</code>) to parse only the digi ID:</p> <pre><code># read raw digi array\ntof_digi = p3.open(\"test.rtraw\")[\"Event/TDigiEvent/m_tofDigiCol\"].array()\nemc_digi = p3.open(\"test.rtraw\")[\"Event/TDigiEvent/m_emcDigiCol\"].array()\n\n# parse digi ID\ntof_digi_id = p3.parse_tof_digi_id(tof_digi[\"m_intId\"])\nemc_digi_id = p3.parse_emc_digi_id(emc_digi[\"m_intId\"])\n</code></pre> <p>Info</p> <p>As the development of <code>pybes3.detectors.geometry</code>, the <code>parse_xxx_digi_id</code> methods will be updated to return more fields.</p>"},{"location":"user-manual/digi-identifier/#convert-digi-id-to-specific-field","title":"Convert digi ID to specific field","text":"<pre><code>import pybes3.detectors.digi_id as digi_id\n\n# get TOF part number\ntof_part = digi_id.tof_id_to_part(tof_digi[\"m_intId\"])\n\n# get EMC theta number\nemc_theta = digi_id.emc_id_to_theta(emc_digi[\"m_intId\"])\n</code></pre> <p>See Digi Identify API for all available methods.</p>"},{"location":"user-manual/digi-identifier/#digi-id-calculation","title":"Digi-ID calculation","text":"<p>To calculate <code>m_intId</code> of digis, use <code>get_xxx_digi_id</code> methods where <code>xxx</code> is the detector name (<code>cgem</code>, <code>mdc</code>, <code>tof</code>, <code>emc</code>, <code>muc</code>):</p> <pre><code>import pybes3.detectors as p3det\n\n# get TOF digi geometry numbers\npart = tof_digi_id[\"part\"]\nlayer_or_module = tof_digi_id[\"layer_or_module\"]\nphi_or_strip = tof_digi_id[\"phi_or_strip\"]\nend = tof_digi_id[\"end\"]\n\n# calculate TOF digi ID\ntof_digi_id = p3det.get_tof_digi_id(part, layer_or_module, phi_or_strip, end)\n</code></pre> <p>Info</p> <p><code>pybes3</code> uses different convention for TOF <code>part</code> number:</p> <ul> <li><code>0,1,2</code> for scintillator endcap0, barrel, endcap1</li> <li><code>3,4</code> for MRPC endcap0, endcap1.</li> </ul> <p>In this case, TOF ID information can be decoded to 4 fields: <code>part</code>, <code>layer_or_module</code>, <code>phi_or_strip</code>, <code>end</code>.</p>"},{"location":"user-manual/helix/","title":"Helix operations","text":"<p>In BES3, helix is represented by 5 parameters: <code>dr</code>, <code>phi0</code>, <code>kappa</code>, <code>dz</code>, <code>tanl</code>. <code>pybes3</code> provides a convenient way to parse these parameters, and do pivot transformation with parameters and error matrix.</p> <p>The implementation of helix depends on <code>vector</code>. It is recommended to take a look at Vector objects and Awkward Arrays of vectors before using helix objects, as they are used to represent helix position, momentum and pivot point.</p>"},{"location":"user-manual/helix/#transformation-rules","title":"Transformation rules","text":"<p>The implementation follows formulas below:</p> <ul> <li> <p>Position \\([\\mathrm{cm}]\\):</p> <ul> <li>\\(x = x_0 + dr \\times \\cos \\varphi_0\\)</li> <li>\\(y = y_0 + dr \\times \\sin \\varphi_0\\)</li> <li>\\(z = z_0 + dz\\)</li> </ul> </li> <li> <p>Momentum \\([\\mathrm{GeV}/c]\\):</p> <ul> <li>\\(p_t = \\frac{1}{\\left| \\kappa \\right|}\\)</li> <li>\\(\\varphi = \\varphi_0 + \\frac{\\pi}{2}\\)</li> <li>\\(p_x = p_t \\times \\cos(\\varphi)\\)</li> <li>\\(p_y = p_t \\times \\sin(\\varphi)\\)</li> <li>\\(p_z = p_t \\times \\tan\\lambda\\)</li> </ul> </li> <li> <p>Others:</p> <ul> <li>\\(\\mathrm{charge} = \\mathrm{sign}(\\kappa)\\)</li> <li>\\(r_{\\mathrm{trk}} \\ [\\mathrm{cm}] = \\frac{1000}{2.99792458} \\times p_t \\ [\\mathrm{GeV}/c]\\)</li> </ul> </li> </ul> <p>The magnetic field in BES3 is assumed to be <code>1T</code>.</p>"},{"location":"user-manual/helix/#create-helix","title":"Create helix","text":""},{"location":"user-manual/helix/#create-helix-object","title":"Create helix object","text":"<p>If you are working with a single track, you can use <code>pybes3.helix_obj</code> to create a helix object:</p> <pre><code>import pybes3 as p3\n\nhelix = p3.helix_obj(\n    params=(dr, phi0, kappa, dz, tanl), # helix parameters\n    error=error,                        # error matrix (optional\n    pivot=(x0, y0, z0),                 # initial pivot point (optional)\n)\n</code></pre> <p>When <code>error</code> is not provided, it defaults to <code>None</code>. When <code>pivot</code> is not provided, it defaults to <code>(0, 0, 0)</code>.</p> <p>Overload of <code>helix_obj</code></p> <p>When calling <code>helix_obj</code>, you can pass the helix parameters and initial pivot point in different ways:</p> Helix parametersPivot point <p>You can specify the helix parameters in two ways:</p> Directly specify each parameterAs a tuple <pre><code>p3.helix_obj(dr, phi0, kappa, dz, tanl, ...)\n# or\np3.helix_obj(dr=dr, phi0=phi0, kappa=kappa, dz=dz, tanl=tanl, ...)\n</code></pre> <pre><code>p3.helix_obj(params=(dr, phi0, kappa, dz, tanl), ...)\n</code></pre> <p>You can specify the initial pivot point in different ways:</p> As a tupleAs a Vector3D object <pre><code>p3.helix_obj(..., pivot=(x0, y0, z0))\n</code></pre> <pre><code>pivot = p3.vector.obj(x=x0, y=y0, z=z0)\np3.helix_obj(..., pivot=pivot)\n</code></pre>"},{"location":"user-manual/helix/#create-helix-array","title":"Create helix array","text":"<p>Warning</p> <p>You must import <code>pybes3</code> before creating a helix array, even though the creation may not involve any <code>pybes3</code> functions.</p> <p>The helix array is implemented with awkward \"behavior\" machanism. One can create a helix array via <code>pybes3.helix_awk</code>, or directly create an awkward array with the <code>Bes3Helix</code> behavior.</p> <p>A very common case is to read helix parameters from a BES3 file, and create a helix array:</p> <pre><code>import pybes3 as p3\n\n# Open a BES3 file and read the helix parameters\ndst_evt = p3.open(\"test.dst\")[\"Event/TDstEvent\"]\nmdc_trks = dst_evt[\"m_mdcTrackCol\"].array()\n\n# Extract the helix parameters and error matrix\nraw_helix = mdc_trks[\"m_helix\"]\nraw_helix_err = mdc_trks[\"m_err\"]\n\n# Create a helix array\nhelix = p3.helix_awk(raw_helix, raw_helix_err)\n</code></pre> <p>Info</p> <p>This overload of <code>helix_awk</code> follows such convention:</p> <pre><code>dr = raw_helix[..., 0]\nphi0 = raw_helix[..., 1]\nkappa = raw_helix[..., 2]\ndz = raw_helix[..., 3]\ntanl = raw_helix[..., 4]\n</code></pre> <p>If you want to specify the helix parameters directly, just pass them as keyword arguments:</p> <pre><code># Prepare helix parameters arrays\ndr = ak.Array(...)\nphi0 = ak.Array(...)\nkappa = ak.Array(...)\ndz = ak.Array(...)\ntanl = ak.Array(...)\n\n# Optional, if you have an error matrix\nerror = ak.Array(...)\n\n# Create a helix array with the parameters\nhelix = p3.helix_awk(\n    dr=dr,\n    phi0=phi0,\n    kappa=kappa,\n    dz=dz,\n    tanl=tanl,\n    error=error, # Optional, if you have an error matrix\n)\n</code></pre> <p>Note</p> <p>Since each track has a <code>5x5</code> error matrix, if a track array has shape <code>(n, var)</code>, the error matrix should have shape <code>(n, var, 5, 5)</code>.</p> <p>You can also specify the initial pivot point:</p> <pre><code>helix = p3.helix_awk(\n    dr=dr,\n    phi0=phi0,\n    kappa=kappa,\n    dz=dz,\n    tanl=tanl,\n    error=error,        # Optional, if you have an error matrix\n    pivot=(x0, y0, z0)  # Initial pivot point\n)\n</code></pre> <p>Different types of pivot point</p> <p>The <code>pivot</code> can be specified in different ways when using <code>helix_awk</code>:</p> As a tuple or <code>Vector3D</code> objectAs an awkward array <p>This will set all tracks to have such pivot point:</p> <pre><code># As a tuple\nhelix = p3.helix_awk(..., pivot=(x0, y0, z0))\n\n# As a Vector3D object\npivot = p3.vector.obj(x=x0, y=y0, z=z0)\nhelix = p3.helix_awk(..., pivot=pivot)\n</code></pre> <p>If you have different pivot points for each track, you can provide a <code>Vector3D</code> awkward array:</p> <pre><code>pivot = ak.Array({\n    \"x\": ak.Array(...),\n    \"y\": ak.Array(...),\n    \"z\": ak.Array(...),\n}, with_name=\"Vector3D\")\n\nhelix = p3.helix_awk(..., pivot=pivot)\n</code></pre> Directly create helix array <p>To create a helix array directly, first import necessary modules:</p> <pre><code>import pybes3\nimport awkward as ak\n</code></pre> <p>Prepare helix parameters:</p> <pre><code>dr = ak.Array(...)\nphi0 = ak.Array(...)\nkappa = ak.Array(...)\ndz = ak.Array(...)\ntanl = ak.Array(...)\n</code></pre> <p>Prepare initial pivot point:</p> <pre><code>pivot = ak.Array({\n    \"x\": ak.zeros_like(dr),\n    \"y\": ak.zeros_like(dr),\n    \"z\": ak.zeros_like(dr),\n}, with_name=\"Vector3D\")\n</code></pre> <p>Create helix array (with no error matrix)</p> <pre><code>helix = ak.Array({\n    \"dr\": dr,\n    \"phi0\": phi0,\n    \"kappa\": kappa,\n    \"dz\": dz,\n    \"tanl\": tanl,\n    \"pivot\": pivot,\n}, with_name=\"Bes3Helix\")\n</code></pre> <p>Optionally, you can also create an error matrix. </p> <pre><code>error = ak.Array(...)\n\nhelix = ak.Array({\n    \"dr\": dr,\n    \"phi0\": phi0,\n    \"kappa\": kappa,\n    \"dz\": dz,\n    \"tanl\": tanl,\n    \"error\": error,\n    \"pivot\": pivot,\n}, with_name=\"Bes3Helix\")\n</code></pre>"},{"location":"user-manual/helix/#create-helix-from-physics-parameters","title":"Create helix from physics parameters","text":"<p>Sometimes you may need to create a helix from position, momentum and charge. You can pass these parameters to <code>pybes3.helix_obj</code> or <code>pybes3.helix_awk</code> to create a helix object or array. <code>pybes3</code> will automatically calculate the helix parameters for you.</p> ObjectArray <p>To create a helix object, use:</p> <pre><code>p3.helix_obj(\n    position=(x, y, z),     # position of the track\n    momentum=(px, py, pz),  # momentum of the track\n    charge=charge,          # charge of the track\n    error=error,            # error matrix (optional)\n    pivot=(x0, y0, z0)      # initial pivot point (optional)\n)\n</code></pre> <p>where <code>charge</code> should be <code>1</code> or <code>-1</code>, and the <code>pivot</code> defaults to <code>(0, 0, 0)</code> if not provided. </p> <p>To create a helix array, use:</p> <pre><code>position = ak.Array({\n    \"x\": ak.Array(...),\n    \"y\": ak.Array(...),\n    \"z\": ak.Array(...),\n}, with_name=\"Vector3D\")\n\nmomentum = ak.Array({\n    \"px\": ak.Array(...),\n    \"py\": ak.Array(...),\n    \"pz\": ak.Array(...),\n}, with_name=\"Vector3D\")\n\ncharge = ak.Array(...)  # values should be 1 or -1\n\np3.helix_awk(\n    position=position,\n    momentum=momentum,\n    charge=charge,\n    error=error,    # error matrix (optional)\n    pivot=pivot     # initial pivot point (optional)\n)\n</code></pre> <p>where <code>charge</code> should be array of <code>1</code> or <code>-1</code>, and the <code>pivot</code> defaults to <code>(0, 0, 0)</code> if not provided. </p> <p>Create helix from MC truth</p> <p>If you are creating helix from MC truth, you should let <code>pivot</code> be the same as the MC truth position, then change the pivot point to <code>(0, 0, 0)</code> later with <code>change_pivot</code> method:</p> <pre><code>truth_helix = p3.helix_obj(\n    position=(x, y, z),\n    momentum=(px, py, pz),\n    charge=charge,\n    pivot=(x, y, z)  # use the MC truth position as pivot\n).change_pivot(0, 0, 0)  # change pivot to (0, 0, 0)\n</code></pre> <p>or, for awkward array:</p> <pre><code>truth_helix = p3.helix_awk(\n    position=position,\n    momentum=momentum,\n    charge=charge,\n    pivot=position  # use the MC truth position as pivot\n).change_pivot(0, 0, 0)  # change pivot to (0, 0, 0)\n</code></pre> <p>Then you can retrieve helix parameters of truth via <code>dr</code>, <code>phi0</code>, <code>kappa</code>, <code>dz</code>, <code>tanl</code> properties of the helix.</p>"},{"location":"user-manual/helix/#physics-information","title":"Physics information","text":"<p>Once you have an object or an awkward array of helix, you can retrieve the physical parameters such as position, momentum, charge and circular radius of the track.</p>"},{"location":"user-manual/helix/#position","title":"Position","text":"<p>The position is defined as the closest point to the pivot point on the helix. You can retrieve the position with:</p> <pre><code>position = helix.position\n</code></pre> <p>This will return a <code>Vector3D</code> object with the position of the track. You can access the <code>x</code>, <code>y</code>, and <code>z</code> coordinates with:</p> <pre><code>x = position.x\ny = position.y\nz = position.z\n</code></pre> <p>See Also</p> <p>See Interface for 3D vectors for more properties.</p>"},{"location":"user-manual/helix/#momentum","title":"Momentum","text":"<p>The momentum is defined as the momentum at the closest point to the pivot point on the helix. You can retrieve the momentum with:</p> <pre><code>momentum = helix.momentum\n</code></pre> <p>This will return a <code>Momentum3D</code> object with the momentum of the track. You can access the many components of the momentum with:</p> <pre><code>px = momentum.px\npy = momentum.py\npz = momentum.pz\npt = momentum.pt  # transverse momentum\np = momentum.p    # total momentum\ncostheta = momentum.costheta  # cosine of the polar angle\ntheta = momentum.theta  # polar angle\nphi = momentum.phi  # azimuthal angle\n</code></pre> <p>See Also</p> <p>See Interface for 3D momentum for more properties.</p> <p>Momentum changes with pivot point</p> <p>When changing pivot point, the momentum will also change. This is because the momentum is defined at the closest point to the pivot point on the helix.</p>"},{"location":"user-manual/helix/#pivot-point","title":"Pivot point","text":"<p>You can retrieve the pivot point of the helix with:</p> <pre><code>pivot = helix.pivot\n</code></pre> <p>Similar to the position, this will return a <code>Vector3D</code> object with the pivot point of the track.</p>"},{"location":"user-manual/helix/#charge","title":"Charge","text":"<p>The charge of the track can be retrieved with:</p> <pre><code>charge = helix.charge\n</code></pre> <p>This will return <code>1</code> or <code>-1</code>, or an awkward array of these values if the helix is an awkward array.</p>"},{"location":"user-manual/helix/#circular-radius","title":"Circular radius","text":"<p>The circular radius is defined as the radius of the 2D circle in the XY plane that the track follows. You can retrieve the circular radius with:</p> <pre><code>r = helix.radius\n</code></pre> <p>This will return a scalar value or an awkward array of values, depending on whether the helix is an object or an awkward array.</p>"},{"location":"user-manual/helix/#pivot-transformation","title":"Pivot transformation","text":"<p>To change pivot point of helix, use <code>change_pivot</code> method. This will transform the helix parameters and error matrix to the new pivot point:</p> ObjectArray <pre><code>helix = p3.helix_obj(...)\n\n# Change pivot point to (3, 4, 5)\nhelix = helix.change_pivot(3, 4, 5)\n</code></pre> <p>or pass a <code>Vector3D</code> object:</p> <pre><code>pivot = p3.vector.obj(x=3, y=4, z=5)\nhelix = helix.change_pivot(pivot)\n</code></pre> <p>You can change the pivot for each track in an awkward array of helix:</p> <pre><code>helix = p3.helix_awk(...)\nnew_pivot = ak.Array({\n    \"x\": ak.Array(...),\n    \"y\": ak.Array(...),\n    \"z\": ak.Array(...),\n}, with_name=\"Vector3D\")\n\nhelix = helix.change_pivot(new_pivot)\n</code></pre> <p>or change the pivot point to a specific point for each track:</p> <pre><code># Change pivot point to (3, 4, 5) for each track\nhelix = helix.change_pivot(3, 4, 5)\n</code></pre> <p>Warning</p> <p><code>change_pivot</code> will not modify the original helix object or array, but return a new one with the pivot point changed.</p>"},{"location":"user-manual/helix/#helix-comparison","title":"Helix comparison","text":"<p>You can compare two helix objects or awkward arrays of helix using <code>isclose</code> method. If two helix objects have different pivot points, the second helix will be transformed to the first helix's pivot point before comparison.</p> ObjectArray <pre><code>helix1 = p3.helix_obj(...)\nhelix2 = p3.helix_obj(...)\n\n# Compare two helix objects, returns a boolean value\nis_close = helix1.isclose(helix2)\n</code></pre> <pre><code>helix1 = p3.helix_awk(...)\nhelix2 = p3.helix_awk(...)\n\n# Compare two helix awkward arrays, returns an awkward array of boolean values\nis_close = helix1.isclose(helix2)\n</code></pre> <p>The comparison uses <code>numpy.isclose</code> to check if the helix parameters and error matrix are close enough. You can specify the <code>rtol</code>, <code>atol</code> and <code>equal_nan</code> parameters to control the comparison behavior:</p> <pre><code>is_close = helix1.isclose(helix2, rtol=1e-5, atol=1e-8, equal_nan=False)\n</code></pre> <p>See numpy.isclose for more details on these parameters.</p>"},{"location":"user-manual/detector/geometry/","title":"Geometry","text":"<p><code>pybes3</code> provides a set of methods to retrieve theoretical geometry information of detectors.</p> <p>The unit of length is <code>cm</code>.</p>"},{"location":"user-manual/detector/geometry/#mdc","title":"MDC","text":""},{"location":"user-manual/detector/geometry/#gid-conversion","title":"GID conversion","text":"<pre><code>import numpy as np\nimport pybes3 as p3\n\n# generate random wire gid\ngid = np.random.randint(0, 6796, 100)\n\n# get layer, wire, stereo, is_stereo\nlayer = p3.mdc_gid_to_layer(gid)\nwire = p3.mdc_gid_to_wire(gid)\nstereo = p3.mdc_gid_to_stereo(gid)\nis_stereo = p3.mdc_gid_to_is_stereo(gid)\nsuperlayer = p3.mdc_gid_to_superlayer(gid)\n\n# is_stereo can also be obtained by layer\nis_stereo = p3.mdc_layer_to_is_stereo(layer)\n\n# superlayer can also be obtained by layer\nsuperlayer = p3.mdc_layer_to_superlayer(layer)\n\n# get gid\ngid = p3.get_mdc_gid(layer, wire)\n</code></pre> <p>Note</p> <p><code>mdc_gid_to_stereo</code> returns the stereo type of the wire, which can be <code>0</code> (axial), <code>-1</code> for <code>west_phi &lt; east_phi</code> and <code>1</code> for <code>west_phi &gt; east_phi</code>.</p>"},{"location":"user-manual/detector/geometry/#wires-position","title":"Wires position","text":"<p>To get west/east x, y, z of wires:</p> <pre><code># get west x, y, z\nwest_x = p3.mdc_gid_to_west_x(gid)\nwest_y = p3.mdc_gid_to_west_y(gid)\nwest_z = p3.mdc_gid_to_west_z(gid)\n\n# get east x, y, z\neast_x = p3.mdc_gid_to_east_x(gid)\neast_y = p3.mdc_gid_to_east_y(gid)\neast_z = p3.mdc_gid_to_east_z(gid)\n</code></pre> <p>To get x, y of wires at a specific z:</p> <pre><code># get x, y of wire 0 at z = -1, 0, 1 cm\nz = np.array([-1, 0, 1])\nx = p3.mdc_gid_z_to_x(0, z)\ny = p3.mdc_gid_z_to_y(0, z)\n\n# get x, y of wires at z = 10 cm\nx_z10 = p3.mdc_gid_z_to_x(gid, 10)\ny_z10 = p3.mdc_gid_z_to_y(gid, 10)\n</code></pre> <p>You can get the whole wires position table of MDC:</p> <pre><code># get table in `dict[str, np.ndarray]`\nwire_position_np = p3.get_mdc_wire_position() \n\n# get table in `ak.Array`\nwire_position_ak = p3.get_mdc_wire_position(library=\"ak\")\n\n# get table in `pd.DataFrame`\nwire_position_pd = p3.get_mdc_wire_position(library=\"pd\")\n</code></pre>"},{"location":"user-manual/detector/geometry/#emc","title":"EMC","text":""},{"location":"user-manual/detector/geometry/#gid-conversion_1","title":"GID conversion","text":"<pre><code>import numpy as np\nimport pybes3 as p3\n\n# generate random crystal gid\ngid = np.random.randint(0, 6240, 100)\n\n# get part, theta, phi\npart = p3.emc_gid_to_part(gid)\ntheta = p3.emc_gid_to_theta(gid)\nphi = p3.emc_gid_to_phi(gid)\n\n# get gid\ngid = p3.get_emc_gid(part, theta, phi)\n</code></pre>"},{"location":"user-manual/detector/geometry/#crystals-position","title":"Crystals position","text":"<p>To get front center, center x, y, z of crystals:</p> <pre><code># get front center x, y, z\nfront_center_x = p3.emc_gid_to_front_center_x(gid)\nfront_center_y = p3.emc_gid_to_front_center_y(gid)\nfront_center_z = p3.emc_gid_to_front_center_z(gid)\n\n# get center x, y, z\ncenter_x = p3.emc_gid_to_center_x(gid)\ncenter_y = p3.emc_gid_to_center_y(gid)\ncenter_z = p3.emc_gid_to_center_z(gid)\n</code></pre> <p>There are total 8 points on a crystal, you can get x, y, z of these points:</p> <pre><code># get x, y, z of point-0 of crystals\nx0 = p3.emc_gid_to_point_x(gid, 0)\ny0 = p3.emc_gid_to_point_y(gid, 0)\nz0 = p3.emc_gid_to_point_z(gid, 0)\n\n# get x, y, z of point-7 of crystals\nx7 = p3.emc_gid_to_point_x(gid, 7)\ny7 = p3.emc_gid_to_point_y(gid, 7)\nz7 = p3.emc_gid_to_point_z(gid, 7)\n\n# get x, y, z of all 8 points of crystal 0\npoint_id = np.arange(8)\nx = p3.emc_gid_to_point_x(0, point_id)\ny = p3.emc_gid_to_point_y(0, point_id)\nz = p3.emc_gid_to_point_z(0, point_id)\n</code></pre> <p>You can get the whole crystals position table of EMC:</p> <pre><code># get table in `dict[str, np.ndarray]`\ncrystal_position_np = p3.get_emc_crystal_position()\n\n# get table in `ak.Array`\ncrystal_position_ak = p3.get_emc_crystal_position(library=\"ak\")\n\n# get table in `pd.DataFrame`\ncrystal_position_pd = p3.get_emc_crystal_position(library=\"pd\")\n</code></pre>"},{"location":"user-manual/detector/geometry/#barrel-geometry","title":"Barrel geometry","text":"<p>Some geometry constants of EMC barrel can be obtained:</p> <pre><code>p3.emc_barrel_h1\np3.emc_barrel_h2\np3.emc_barrel_h3\np3.emc_barrel_l\np3.emc_barrel_r\np3.emc_barrel_offset_1\np3.emc_barrel_offset_2\n</code></pre> <p>These constants are exported from <code>EmcRecGeoSvc</code> in <code>BOSS</code>.</p>"},{"location":"user-manual/detector/global-id/","title":"Global ID (gid)","text":"<p>Info</p> <p>This page only illustrates the gid of each detector element. To convert gid to other information, please refer to Geometry.</p> <p>To better locate each detector element, a global ID (gid) is defined. GID always starts from 0 and increases along the detector elements. The increasing order is described by a tuple-like structure.</p> <p>For example, MDC gid can be described as <code>(layer, wire)</code>, which means it increases first along the <code>wire</code> and then along the <code>layer</code>, as shown below:</p> layer wire gid 0 0 0 0 1 1 0 ... ... 1 0 40 1 1 41 ... ... ... <p>There are 40 wires on layer-0 in MDC.</p>"},{"location":"user-manual/detector/global-id/#mdc","title":"MDC","text":"Range Increasing Order 0~6795 (layer, wire) <p>Same as BOSS</p> <p>MDC gid is same as those given by <code>MdcGeomSvc</code> in <code>BOSS</code></p>"},{"location":"user-manual/detector/global-id/#tof","title":"TOF","text":"Range Increasing Order Part 0~95 (strip, end) Scint Endcap 0 96~447 (layer, phi, end) Scint Barrel 448~543 (phi, end) Scint Endcap 1 544~1407 (module, strip, end) MRPC Endcap 0 1408~2271 (module, strip, end) MRPC Endcap 1"},{"location":"user-manual/detector/global-id/#emc","title":"EMC","text":"Range Increasing Order Part 0~479 (theta, phi) Endcap 0 480~5759 (theta, phi) Barrel 5760~6239 (-theta, phi) Endcap 1 <p>The concrete relationship between gid and <code>(theta, phi)</code> for EMC endcap 0 is:</p> Range Number of Crystals Theta Description 0~63 64 0 Innermost layer 64~127 64 1 128~207 80 2 208~287 80 3 288~383 96 4 384~479 96 5 Outermost layer <p>The concrete relationship between gid and <code>(theta, phi)</code> for EMC endcap 1 is:</p> Range Number of Crystals Theta Description 5760~5855 96 5 Outermost layer 5856~5951 96 4 5952~6031 80 3 6032~6111 80 2 6112~6175 64 1 6176~6239 64 0 Innermost layer <p>Same as BOSS</p> <p>EMC gid is same as those given by <code>EmcCalibSvc</code> in <code>BOSS</code></p>"},{"location":"user-manual/detector/global-id/#muc","title":"MUC","text":"<p>Under development</p>"},{"location":"user-manual/detector/global-id/#cgem","title":"CGEM","text":"<p>Under development</p>"}]}